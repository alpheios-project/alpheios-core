{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///../node_modules/source-map-loader/node_modules/axios/index.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/adapters/http.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/adapters/xhr.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/axios.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/Cancel.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/CancelToken.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/isCancel.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/Axios.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/InterceptorManager.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/buildFullPath.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/createError.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/dispatchRequest.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/enhanceError.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/mergeConfig.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/settle.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/transformData.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/defaults.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/bind.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/buildURL.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/combineURLs.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/cookies.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/parseHeaders.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/spread.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/utils.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/index.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/browser.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/debug.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/index.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/node.js","webpack:///../node_modules/source-map-loader/node_modules/has-flag/index.js","webpack:///../node_modules/source-map-loader/node_modules/ms/index.js","webpack:///../node_modules/source-map-loader/node_modules/supports-color/index.js","webpack:///../node_modules/source-map-loader/node_modules/xmltojson/lib/xmlToJSON.js","webpack:///./adapters/alpheiostb/adapter.js","webpack:///./adapters/arethusa/adapter.js","webpack:///./adapters/base-adapter.js","webpack:///./adapters/chineseloc/adapter.js","webpack:///./adapters/concordance/adapter.js","webpack:///./adapters/lexicons/adapter.js","webpack:///./adapters/logeion/adapter.js","webpack:///./adapters/translations/adapter.js","webpack:///./adapters/tufts/adapter.js","webpack:///./adapters/tufts/engine/aramorph.js","webpack:///./adapters/tufts/engine/hazm.js","webpack:///./adapters/tufts/engine/morpheusgrc.js","webpack:///./adapters/tufts/engine/sedra.js","webpack:///./adapters/tufts/engine/traces.js","webpack:///./adapters/tufts/engine/whitakers.js","webpack:///./adapters/tufts/engines-set.js","webpack:///./client-adapters.js","webpack:///./errors/adapter-error.js","webpack:///./errors/no-required-param-error.js","webpack:///./errors/remote-error.js","webpack:///./errors/wrong-method-error.js","webpack:///./index.js","webpack:///./locales/locales.js","webpack:///./transformers/alpheios-lexicon-transformer.js","webpack:///./transformers/import-morph-data.js","webpack:///external \"alpheios-data-models\"","webpack:///external \"alpheios-l10n\"","webpack:///external \"alpheios-messaging\"","webpack:///external \"assert\"","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"os\"","webpack:///external \"papaparse\"","webpack:///external \"stream\"","webpack:///external \"tty\"","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///external \"zlib\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/node module decorator","webpack:///webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA,iBAAiB,mBAAO,CAAC,6DAAa,E;;;;;;;;;;;;;ACAzB;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,aAAa,mBAAO,CAAC,wEAAkB;AACvC,oBAAoB,mBAAO,CAAC,oFAAuB;AACnD,eAAe,mBAAO,CAAC,kFAAuB;AAC9C,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,iBAAiB,mGAAgC;AACjD,kBAAkB,oGAAiC;AACnD,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,UAAU,mBAAO,CAAC,sEAAsB;AACxC,kBAAkB,mBAAO,CAAC,gFAAqB;AAC/C,mBAAmB,mBAAO,CAAC,kFAAsB;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACtRa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,aAAa,mBAAO,CAAC,wEAAkB;AACvC,eAAe,mBAAO,CAAC,kFAAuB;AAC9C,oBAAoB,mBAAO,CAAC,oFAAuB;AACnD,mBAAmB,mBAAO,CAAC,0FAA2B;AACtD,sBAAsB,mBAAO,CAAC,gGAA8B;AAC5D,kBAAkB,mBAAO,CAAC,gFAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,gFAAsB;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACnLa;;AAEb,YAAY,mBAAO,CAAC,yDAAS;AAC7B,WAAW,mBAAO,CAAC,uEAAgB;AACnC,YAAY,mBAAO,CAAC,mEAAc;AAClC,kBAAkB,mBAAO,CAAC,+EAAoB;AAC9C,eAAe,mBAAO,CAAC,+DAAY;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,yEAAiB;AACxC,oBAAoB,mBAAO,CAAC,mFAAsB;AAClD,iBAAiB,mBAAO,CAAC,6EAAmB;;AAE5C;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,2EAAkB;;AAEzC;;AAEA;AACA,sBAAsB;;;;;;;;;;;;;;ACpDT;;AAEb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;AClBa;;AAEb,aAAa,mBAAO,CAAC,kEAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACxDa;;AAEb;AACA;AACA;;;;;;;;;;;;;;ACJa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,eAAe,mBAAO,CAAC,gFAAqB;AAC5C,yBAAyB,mBAAO,CAAC,wFAAsB;AACvD,sBAAsB,mBAAO,CAAC,kFAAmB;AACjD,kBAAkB,mBAAO,CAAC,0EAAe;;AAEzC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;;;;;;;AC7Fa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;;ACnDa;;AAEb,oBAAoB,mBAAO,CAAC,0FAA0B;AACtD,kBAAkB,mBAAO,CAAC,sFAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBa;;AAEb,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,oBAAoB,mBAAO,CAAC,8EAAiB;AAC7C,eAAe,mBAAO,CAAC,8EAAoB;AAC3C,eAAe,mBAAO,CAAC,gEAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;;AC9Ea;;AAEb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCa;;AAEb,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;ACxEa;;AAEb,kBAAkB,mBAAO,CAAC,0EAAe;;AAEzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxBa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;ACnBa;;AAEb,YAAY,mBAAO,CAAC,yDAAS;AAC7B,0BAA0B,mBAAO,CAAC,qGAA+B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,uEAAgB;AACtC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,yEAAiB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;AChGa;;AAEb;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtEa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C,SAAS;;AAET;AACA,4DAA4D,wBAAwB;AACpF;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B,aAAa,EAAE;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;ACnEa;;AAEb,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1Ba;;AAEb,WAAW,mBAAO,CAAC,uEAAgB;;AAEnC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC;AAChC,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvVA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,eAAe,oDAA0B;AACzC,YAAY,mBAAO,CAAC,qFAAO;;AAE3B;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,sBAAsB,uCAAuC,EAAE;AAC/D,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD,mBAAmB;;;;;;;;;;;;;ACjUnB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,uFAAS;AAC5C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,qBAAqB;AAC3B;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,gBAAgB,GAAG,mBAAO,CAAC,6CAAI;;AAE/B;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,EAAE,aAAa;AACf,EAAE,aAAa;;AAEf;AACA;AACA;;AAEA,aAAa,SAAS;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChOA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,8FAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,wFAAW;AACtC;;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,uFAAS;AAC5C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA,sBAAsB,mBAAO,CAAC,qEAAgB;AAC9C;AACA,IAAI,cAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,EAAE;AACnD,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACzLa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvJa;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,yDAAU;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,wCAAwC;AACjE;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA,uDAAuD,sCAAsC;AAC7F;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC,SAAS;;AAEV,IAAI,KAA4B;AAChC,SAAS,IAA0C,EAAE,mCAAO,aAAa,mBAAmB;AAAA,kGAAC;;;;;;;;;;;;;;;;;;;;;;;;;;ACjP4E;AAC9G;;AAEY;AACtC;;AAEjC,sCAAsC,sEAAW;AACjD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,wEAAa;AACzD,mBAAmB,MAAM,oEAAkB,OAAO,oEAAkB;AACpE;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA,gDAAgD,cAAc;;AAE9D;AACA;AACA;;AAEA;AACA,yBAAyB,4FAAyB;;AAElD,wBAAwB,4DAAqB;AAC7C,mEAAmE,QAAQ,mBAAmB;;AAE9F;AACA;AACA,OAAO;AACP,6EAA6E,gBAAgB;AAC7F;AACA,KAAK;AACL,sEAAsE,yBAAyB;AAC/F;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAgB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uDAAK;AACzB,yBAAyB,wDAAM;AAC/B,yBAAyB,4DAAU;AACnC;AACA,8BAA8B,yDAAO,CAAC,wEAAsB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAO,EAAE,2EAAyB;AACjD;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHqB;AACmC;AACf;AACT;;AAEC;AAG5C;;AAE3B,sCAAsC,sEAAW;AACjD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA;AACA,4CAA4C,wEAAa;AACzD;;AAEA;AACA,SAAS,2EAA2B;AACpC,MAAM,8EAA8B,kBAAkB,uEAAW;AACjE;AACA,WAAW,2EAA2B;AACtC;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,8DAAc;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe,EAAE;AAC1C;AACA;AACA,0DAA0D,8DAAc;AACxE,KAAK;AACL,8BAA8B,+DAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,aAAa;AAC5F;AACA;AACA,8BAA8B,uFAAqC;AACnE;AACA,iFAAiF,oCAAoC;AACrH;AACA;AACA,yBAAyB,kFAAU;AACnC;AACA;AACA,kEAAkE,mEAAiB;AACnF,mEAAmE,mEAAiB;AACpF,kEAAkE,mEAAiB;AACnF;AACA;AACA,SAAS;AACT,qCAAqC,0FAA0B;AAC/D;AACA;AACA;AACA;AACA,6CAA6C,oEAAkB,YAAY,qEAAmB;AAC9F;AACA,6CAA6C,oEAAkB,YAAY,2EAAyB;AACpG,2DAA2D,yDAAO,CAAC,oEAAkB,EAAE,gFAA8B;AACrH;AACA;AACA,OAAO;AACP,sEAAsE,gBAAgB;AACtF;AACA,KAAK;AACL,sEAAsE,yBAAyB;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,8DAAc;AAC7D,4BAA4B,YAAY,mCAAmC;AAC3E,gEAAgE,8DAAc;AAC9E;AACA,KAAK;AACL,8BAA8B,+DAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gEAAgE,8DAAc;AAC9E;AACA,KAAK;AACL,8BAA8B,+DAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5Kb;AACoB;AACT;AACuB;AACC;;AAER;AACM;AACA;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB,mBAAmB,oEAAI,EAAE,yEAAa;AACtC,mBAAmB,oEAAI,EAAE,yEAAa;AACtC,iBAAiB,yEAAa;AAC9B;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,sBAAsB,qEAAY;AAClC;AACA;;AAEA;AACA,sBAAsB,uEAAW;AACjC;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,cAAc;AACd;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA,+EAA+E,+DAA+D;AAC9I;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,0EAA0E,WAAW;AACrF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA,8EAA8E,WAAW;AACzF;AACA;AACA,WAAW;AACX,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,6BAA6B,2BAA2B;AACvF,SAAS;AACT,sBAAsB,gDAAS;AAC/B;AACA;AACA,OAAO;AACP,0EAA0E,WAAW;AACrF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,oEAAkB;AACxB,KAAK;AACL;AACA;AACA;AACA,MAAM,oEAAkB;AACxB,KAAK;AACL;AACA,MAAM,oEAAkB;AACxB;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnN1B;AAC2D;AAC6C;AAG7E;;AAEpB;AACP;AACA;AACA;;AAEA;;AAEA,wCAAwC,sEAAW;AACnD,0BAA0B;AAC1B;AACA;AACA,wBAAwB,uEAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,2EAA2B;AACpC,MAAM,8EAA8B,qBAAqB,uEAAW;AACpE;AACA;AACA;AACA,oBAAoB,sFAA0B;AAC9C,OAAO;AACP;AACA,6BAA6B,2EAA2B;AACxD;;AAEA,qBAAqB,QAAQ,iFAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,yBAAyB,WAAW,EAAE,+BAA+B;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8DAAc;AACxG,OAAO;AACP;AACA;AACA;;AAEA;AACA,4DAA4D,2DAA2D;AACvH;AACA;AACA;AACA;AACA,4DAA4D,2DAA2D;AACvH;AACA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8DAAc;AACxG,OAAO;AACP;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;;AAE3B;AACA,gDAAgD,mFAAiC;AACjF;AACA;AACA;AACA,mCAAmC,EAAE,KAAK,UAAU,GAAG;AACvD,OAAO;AACP,2CAA2C,6EAA2B;AACtE,2CAA2C,oEAAkB;AAC7D,2FAA2F,uEAAqB;AAChH,iEAAiE,yEAAuB;;AAExF,yBAAyB,wDAAM;AAC/B,2DAA2D,4DAAU;AACrE;AACA;AACA,KAAK;AACL,sBAAsB,yDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,yDAAO;AACtB;AACA;;AAEA,iEAAe,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;ACrKgC;AACc;;AAE2B;AACtD;;AAE3D,yCAAyC,sEAAW;AACpD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,yEAAa;AACzD,wBAAwB,kEAAgB;AACxC;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,wDAAwD,EAAE,8EAAsB;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yEAAyE,yBAAyB;AAClG;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,YAAY,OAAO,SAAS,EAAE;AAC9B,aAAa,OAAO;AACpB;AACA,eAAe,mBAAmB;AAClC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA,mDAAmD,iBAAiB,WAAW;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4FAA0C;AAC9D;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,4EAA4E,yBAAyB;AACrG;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,YAAY,OAAO,SAAS,EAAE;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc,gBAAgB,EAAE,uCAAuC,EAAE,gBAAgB,EAAE,oBAAoB;AAC/G;;AAEA;AACA;AACA,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB,GAAG,oBAAoB;AAC5D;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB,GAAG,2BAA2B,OAAO,+BAA+B;AACzG,KAAK;AACL,iBAAiB,oBAAoB,GAAG,2BAA2B;AACnE;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB;AACnB;AACA;AACA,KAAK;;AAEL,0BAA0B;AAC1B;AACA;AACA,KAAK;;AAEL,qBAAqB,wDAAM;AAC3B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB;AACnB;AACA;AACA,KAAK;;AAEL,0BAA0B;AAC1B;AACA;AACA,KAAK;;AAEL,uBAAuB,0DAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA,+BAA+B,kEAAgB;AAC/C,MAAM,4FAA0C;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;ACnTuD;AAC/D;;AAE0B;AACU;;AAErE;AACA;;AAEA,sCAAsC,sEAAW;AACjD;AACA;AACA,YAAY,OAAO;AACnB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,sEAAa;AACzD,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,yBAAyB;AACpG;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qEAAqE,yBAAyB;AAC9F;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,6CAA6C;AAC/F,yBAAyB,sDAAe,YAAY,gBAAgB,KAAK,mBAAmB;AAC5F;AACA;;AAEA;AACA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAkB,uFAAoB;;AAEtC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,iCAAiC,kEAAgB;AACjD,4BAA4B,4DAAU;AACtC,+BAA+B,2EAAyB;AACxD;AACA,WAAW;AACX,2EAA2E,yBAAyB;AACpG;AACA;AACA;AACA,OAAO;AACP;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA,kBAAkB,uFAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,QAAQ,KAAK,UAAU,mBAAmB;AAC5E;AACA,OAAO;AACP,uBAAuB,SAAS,QAAQ,KAAK,sCAAsC,mBAAmB;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,OAAO;AACP,kDAAkD,cAAc;AAChE;;AAEA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA,WAAW;AACX,iCAAiC,kEAAgB;AACjD,4BAA4B,4DAAU;AACtC,+BAA+B,2EAAyB;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA,yEAAyE,yBAAyB;AAClG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,OAAO;AACP,qDAAqD,cAAc;AACnE;;AAEA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F,SAAS;AACT,+BAA+B,kEAAgB;AAC/C,0BAA0B,4DAAU;AACpC,6BAA6B,2EAAyB;AACtD;AACA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,yBAAyB,4FAAyB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,8BAA8B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;ACnhB8B;AACT;;AAEkB;;AAE7E,qCAAqC,sEAAW;AAChD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,qEAAa;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA,gBAAgB,0BAA0B,OAAO,yBAAyB,KAAK,KAAK,QAAQ,qBAAqB;AACjH;AACA;;AAEA;AACA,6BAA6B,6EAA2B;AACxD;AACA,KAAK,WAAW,6EAA2B,EAAE,4EAA0B;AACvE;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA,kBAAkB,+FAA4B;AAC9C;AACA;AACA,wBAAwB,+FAA4B;AACpD;AACA;AACA;AACA,KAAK;;AAEL,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;ACjGoC;;AAEwB;AACtC;;AAE3D,+CAA+C,sEAAW;AAC1D;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,0EAAa;AACzD;AACA,wBAAwB,kEAAgB;AACxC;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,4FAAyB;AAC5C;;AAEA;;AAEA;AACA,yEAAyE,0BAA0B;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,8EAA4B;AACxC;AACA,SAAS;AACT,uEAAuE,yBAAyB;AAChG;AACA;AACA,KAAK;AACL,mEAAmE,yBAAyB;AAC5F;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,gCAAgC;;;;;;;;;;;;;;;;;;;;;;;;;;ACvH+C;;AAEnC;AACmC;;AAE5B;AACH;;AAE/D,mCAAmC,sEAAW;AAC9C;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,mEAAa;AACzD;AACA,yBAAyB,2EAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4FAAyB;;AAE9C,qBAAqB,0EAAwB;AAC7C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gFAAgF,oCAAoC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E,kCAAkC;AAC/G;AACA;AACA,qCAAqC,0FAA0B;AAC/D;;AAEA;AACA,8DAA8D,gDAAgD;AAC9G;AACA;;AAEA;AACA,+BAA+B,kFAAgC,CAAC,yEAAuB,EAAE,oEAAkB;AAC3G;;AAEA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA;AACA,qBAAqB,4FAAyB;AAC9C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;AC9GmC;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,qEAA0B;;AAEtD,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;ACLmD;AACxB;;AAE9C,eAAe,kFAAU,CAAC,sEAA2B;;AAErD;AACA,wCAAwC,oCAAoC;;AAE5E,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;ACRmD;AACxB;;AAE9C,eAAe,kFAAU,CAAC,oEAAyB;;AAEnD;AACA;AACA;AACA,GAAG,oEAAyB,gBAAgB,oEAAyB,YAAY,0EAA+B,8BAA8B,oEAAyB,YAAY,wEAA6B;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sEAA2B;AAC3C,+BAA+B,0EAA+B,OAAO,yEAA8B;;AAEnG,gBAAgB,0EAA+B;AAC/C,sBAAsB,mEAAwB,OAAO,mEAAwB;;AAE7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,sBAAsB,wEAA6B;AACnD,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;ACvCmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,qEAA0B;;AAEtD;AACA;AACA;AACA,0BAA0B,oEAAyB;AACnD,CAAC;;AAED;AACA;AACA,6CAA6C,6EAAkC;AAC/E;AACA,aAAa,4DAAiB;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;ACjCmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,mEAAwB;;AAEpD,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;ACLmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,oEAAyB;;AAErD;AACA;AACA,4BAA4B,EAAE,2EAAgC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,sEAA2B;AAC3C,mBAAmB,0EAA+B,OAAO,yEAA8B;AACvF,gBAAgB,0EAA+B,OAAO,yEAA8B,OAAO,uEAA4B;;AAEvH,gBAAgB,qEAA0B;AAC1C,yBAAyB,gFAAqC;;AAE9D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,sBAAsB,0EAA+B;AACrD,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAA8B;AAChE,mCAAmC,sEAA2B;AAC9D,mCAAmC,mEAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAA8B,oCAAoC,yEAA8B;AACrI;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAY;AAC7B;;AAEA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3GgD;AACI;AACN;AACR;AACI;AACF;;AAEO;;AAElE;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,mCAAmC,gFAAS,EAAE,kFAAW,EAAE,+EAAQ,EAAE,2EAAI,EAAE,6EAAM,EAAE,4EAAK,eAAe,uBAAuB;AAC9H;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,uBAAuB,4FAAyB;AAChD;AACA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzC4C;AACU;AACF;AACW;AACb;AACM;AACN;AACF;;AAEL;AACS;;AAEP;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAc;AAC3C,yBAAyB;AACzB,iCAAiC,uEAAc;AAC/C,8BAA8B,uEAAc;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,gBAAgB,0EAAgB;AAChC;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAoB;AACxC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,+BAA+B,uEAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,4EAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA,+BAA+B,4EAAuB;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA,6BAA6B,0EAAuB;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,mCAAmC,8EAAgC;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,6EAA0B;AAC7D;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,wBAAwB;AACxC,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,0EAAuB;;AAE5D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,yEAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,iEAAe,cAAc;;;;;;;;;;;;;;;;;;;;AC9X7B;AACA;AACA;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;;AAEA;AACA,wBAAwB,aAAa,IAAI,aAAa,GAAG,gBAAgB;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB,GAAG,mBAAmB;AAC5D;;AAEA,sBAAsB,aAAa,IAAI,aAAa,GAAG,gBAAgB;AACvE;AACA;AACA;;AAEA,iEAAe,YAAY;;;;;;;;;;;;;;;;;;;;ACzB3B;AACA;AACA,wDAAwD,UAAU,OAAO,SAAS,GAAG,YAAY,KAAK,WAAW;AACjH;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;;;;;;ACXpB;AACf;AACA;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB,GAAG,mBAAmB;AAC5D;;AAEA,sBAAsB,eAAe,IAAI,aAAa,IAAI,aAAa,GAAG,gBAAgB;AAC1F;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA,wCAAwC,SAAS,GAAG,YAAY,KAAK,WAAW;AAChF;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;AACA;;AAEA,iEAAe,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;ACV4B;AACC;;AAEtB;;;;;;;;;;;;;;;;;;;;;;ACHE;AACA;;AAExC,iEAAe;AACf;AACA;AACA;AACA,WAAW,iDAAI;AACf,WAAW,iDAAI;AACf;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;ACVuG;;AAExG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,wEAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,kEAAgB;;AAEzC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,2EAAyB;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,2EAAyB;AAC5C;AACA,WAAW;AACX;AACA;AACA,2BAA2B,wDAAM;;AAEjC;AACA,uBAAuB,2EAAyB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAU;AACrC,SAAS;AACT,8FAA8F,mBAAmB;AACjH;AACA;AACA;AACA,oCAAoC,yDAAO,CAAC,wEAAsB;AAClE;AACA;AACA;AACA;AACA;AACA,iEAAiE,+DAAa;AAC9E,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,+DAAa;AAC9E,WAAW;AACX;AACA;AACA;;AAEA;AACA,uBAAuB,uEAAqB;AAC5C,qBAAqB,qEAAmB;AACxC,qBAAqB,oEAAkB;AACvC,qBAAqB,qEAAmB;AACxC,qBAAqB,sEAAoB;AACzC,qBAAqB,0EAAwB;AAC7C,qBAAqB,wEAAsB;AAC3C,qBAAqB,yEAAuB;AAC5C,qBAAqB,uEAAqB;AAC1C,qBAAqB,qEAAmB;AACxC,qBAAqB,qEAAmB;AACxC,qBAAqB,qEAAmB;AACxC,qBAAqB,uEAAqB;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,oEAAkB;AAChD;AACA;AACA;AACA,8BAA8B,0EAAwB;AACtD,6BAA6B,oEAAkB,oBAAoB,oEAAkB,qBAAqB,oEAAkB;AAC5H;AACA;AACA;AACA,8BAA8B,2EAAyB;AACvD,6BAA6B,oEAAkB,oBAAoB,oEAAkB,qBAAqB,oEAAkB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAO;AACxB,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,0BAA0B;;;;;;;;;;;;;;;;;;;;;;ACpTzC;AACA;AACA;AACqG;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,uDAAK;;AAEzD;AACA;AACA,iDAAiD,6EAA2B;AAC5E,iBAAiB,4DAAU;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,oEAAkB;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,cAAc,gBAAgB,YAAY,QAAQ,mBAAmB,cAAc,mBAAmB;AAClJ;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,4CAA4C,mBAAmB,gBAAgB,YAAY,QAAQ,mBAAmB,cAAc,mBAAmB;AACvJ;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,iEAAe;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,qEAAqE,EAAE;AAClH,6BAA6B,+DAAa;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,qEAAqE,EAAE;AAClH,6BAA6B,+DAAa;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3Q9B,kE;;;;;;;;;;;;;ACAA,2D;;;;;;;;;;;;;ACAA,gE;;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;;ACAA,iC;;;;;;;;;;;;;ACAA,kC;;;;;;;;;;;;;ACAA,+B;;;;;;;;;;;;;ACAA,uD;;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;;ACAA,gC;;;;;;;;;;;;;ACAA,gC;;;;;;;;;;;;;ACAA,iC;;;;;;;;;;;;;ACAA,iC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCxBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;WCNA;WACA;WACA;WACA;WACA,E;;;;UCJA;UACA;UACA;UACA","file":"alpheios-client-adapters.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"alpheios-data-models\"), require(\"alpheios-l10n\"), require(\"alpheios-messaging\"), require(\"papaparse\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"alpheios-data-models\", \"alpheios-l10n\", \"alpheios-messaging\", \"papaparse\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"alpheios-data-models\"), require(\"alpheios-l10n\"), require(\"alpheios-messaging\"), require(\"papaparse\")) : factory(root[\"alpheios-data-models\"], root[\"alpheios-l10n\"], root[\"alpheios-messaging\"], root[\"papaparse\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function(__WEBPACK_EXTERNAL_MODULE_alpheios_data_models__, __WEBPACK_EXTERNAL_MODULE_alpheios_l10n__, __WEBPACK_EXTERNAL_MODULE_alpheios_messaging__, __WEBPACK_EXTERNAL_MODULE_papaparse__) {\nreturn ","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar pkg = require('./../../package.json');\nvar createError = require('../core/createError');\nvar enhanceError = require('../core/enhanceError');\n\nvar isHttps = /https:?/;\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var resolve = function resolve(value) {\n      resolvePromise(value);\n    };\n    var reject = function reject(value) {\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n\n    // Set User-Agent (required by some servers)\n    // Only set header if it hasn't been set in config\n    // See https://github.com/axios/axios/issues/69\n    if (!headers['User-Agent'] && !headers['user-agent']) {\n      headers['User-Agent'] = 'axios/' + pkg.version;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(createError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers['Content-Length'] = data.length;\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth) {\n      delete headers.Authorization;\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' &&\n                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.hostname = proxy.host;\n      options.host = proxy.host;\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      options.port = proxy.port;\n      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;\n\n      // Basic proxy authorization\n      if (proxy.auth) {\n        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n        options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n      }\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxContentLength && config.maxContentLength > -1) {\n      options.maxBodyLength = config.maxContentLength;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n      switch (res.headers['content-encoding']) {\n      /*eslint default-case:0*/\n      case 'gzip':\n      case 'compress':\n      case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n        stream = (res.statusCode === 204) ? stream : stream.pipe(zlib.createUnzip());\n\n        // remove the content-encoding in order to not confuse downstream operations\n        delete res.headers['content-encoding'];\n        break;\n      }\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              config, null, lastRequest));\n          }\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          var responseData = Buffer.concat(responseBuffer);\n          if (config.responseType !== 'arraybuffer') {\n            responseData = responseData.toString(config.responseEncoding);\n          }\n\n          response.data = responseData;\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted) return;\n      reject(enhanceError(err, config, null, req));\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(config.timeout, function handleRequestTimeout() {\n        req.abort();\n        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));\n      });\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(cancel);\n      });\n    }\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(enhanceError(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',\n    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath'\n  ];\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {\n    if (utils.isObject(config2[prop])) {\n      config[prop] = utils.deepMerge(config1[prop], config2[prop]);\n    } else if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (utils.isObject(config1[prop])) {\n      config[prop] = utils.deepMerge(config1[prop]);\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys);\n\n  var otherKeys = Object\n    .keys(config2)\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Function equal to merge with the difference being that no reference\n * to original objects is kept.\n *\n * @see merge\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction deepMerge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = deepMerge(result[key], val);\n    } else if (typeof val === 'object') {\n      result[key] = deepMerge({}, val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  deepMerge: deepMerge,\n  extend: extend,\n  trim: trim\n};\n","var url = require(\"url\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar assert = require(\"assert\");\nvar Writable = require(\"stream\").Writable;\nvar debug = require(\"debug\")(\"follow-redirects\");\n\n// RFC72314.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data and end\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC72316.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC72316.4: Automatic redirection needs to done with\n    // care for methods not known to be safe [],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC72316.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = require('supports-color');\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","/* Copyright 2015 William Summers, MetaTribal LLC\n * adapted from https://developer.mozilla.org/en-US/docs/JXON\n *\n * Licensed under the MIT License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @author William Summers\n *\n */\n\nvar xmlToJSON = (function () {\n\n    this.version = \"1.3.5\";\n\n    var options = { // set up the default options\n        mergeCDATA: true, // extract cdata and merge with text\n        grokAttr: true, // convert truthy attributes to boolean, etc\n        grokText: true, // convert truthy text/attr to boolean, etc\n        normalize: true, // collapse multiple spaces to single space\n        xmlns: true, // include namespaces as attribute in output\n        namespaceKey: '_ns', // tag name for namespace objects\n        textKey: '_text', // tag name for text nodes\n        valueKey: '_value', // tag name for attribute values\n        attrKey: '_attr', // tag for attr groups\n        cdataKey: '_cdata', // tag for cdata nodes (ignored if mergeCDATA is true)\n        attrsAsObject: true, // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.\n        stripAttrPrefix: true, // remove namespace prefixes from attributes\n        stripElemPrefix: true, // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property\n        childrenAsArray: true // force children into arrays\n    };\n\n    var prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n    var trimMatch = new RegExp(/^\\s+|\\s+$/g);\n\n    this.grokType = function (sValue) {\n        if (/^\\s*$/.test(sValue)) {\n            return null;\n        }\n        if (/^(?:true|false)$/i.test(sValue)) {\n            return sValue.toLowerCase() === \"true\";\n        }\n        if (isFinite(sValue)) {\n            return parseFloat(sValue);\n        }\n        return sValue;\n    };\n\n    this.parseString = function (xmlString, opt) {\n        return this.parseXML(this.stringToXML(xmlString), opt);\n    }\n\n    this.parseXML = function (oXMLParent, opt) {\n\n        // initialize options\n        for (var key in opt) {\n            options[key] = opt[key];\n        }\n\n        var vResult = {},\n            nLength = 0,\n            sCollectedTxt = \"\";\n\n        // parse namespace information\n        if (options.xmlns && oXMLParent.namespaceURI) {\n            vResult[options.namespaceKey] = oXMLParent.namespaceURI;\n        }\n\n        // parse attributes\n        // using attributes property instead of hasAttributes method to support older browsers\n        if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {\n            var vAttribs = {};\n\n            for (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n                var oAttrib = oXMLParent.attributes.item(nLength);\n                vContent = {};\n                var attribName = '';\n\n                if (options.stripAttrPrefix) {\n                    attribName = oAttrib.name.replace(prefixMatch, '');\n\n                } else {\n                    attribName = oAttrib.name;\n                }\n\n                if (options.grokAttr) {\n                    vContent[options.valueKey] = this.grokType(oAttrib.value.replace(trimMatch, ''));\n                } else {\n                    vContent[options.valueKey] = oAttrib.value.replace(trimMatch, '');\n                }\n\n                if (options.xmlns && oAttrib.namespaceURI) {\n                    vContent[options.namespaceKey] = oAttrib.namespaceURI;\n                }\n\n                if (options.attrsAsObject) { // attributes with same local name must enable prefixes\n                    vAttribs[attribName] = vContent;\n                } else {\n                    vResult[options.attrKey + attribName] = vContent;\n                }\n            }\n\n            if (options.attrsAsObject) {\n                vResult[options.attrKey] = vAttribs;\n            } else { }\n        }\n\n        // iterate over the children\n        if (oXMLParent.hasChildNodes()) {\n            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n                oNode = oXMLParent.childNodes.item(nItem);\n\n                if (oNode.nodeType === 4) {\n                    if (options.mergeCDATA) {\n                        sCollectedTxt += oNode.nodeValue;\n                    } else {\n                        if (vResult.hasOwnProperty(options.cdataKey)) {\n                            if (vResult[options.cdataKey].constructor !== Array) {\n                                vResult[options.cdataKey] = [vResult[options.cdataKey]];\n                            }\n                            vResult[options.cdataKey].push(oNode.nodeValue);\n\n                        } else {\n                            if (options.childrenAsArray) {\n                                vResult[options.cdataKey] = [];\n                                vResult[options.cdataKey].push(oNode.nodeValue);\n                            } else {\n                                vResult[options.cdataKey] = oNode.nodeValue;\n                            }\n                        }\n                    }\n                } /* nodeType is \"CDATASection\" (4) */\n                else if (oNode.nodeType === 3) {\n                    sCollectedTxt += oNode.nodeValue;\n                } /* nodeType is \"Text\" (3) */\n                else if (oNode.nodeType === 1) { /* nodeType is \"Element\" (1) */\n\n                    if (nLength === 0) {\n                        vResult = {};\n                    }\n\n                    // using nodeName to support browser (IE) implementation with no 'localName' property\n                    if (options.stripElemPrefix) {\n                        sProp = oNode.nodeName.replace(prefixMatch, '');\n                    } else {\n                        sProp = oNode.nodeName;\n                    }\n\n                    vContent = xmlToJSON.parseXML(oNode);\n\n                    if (vResult.hasOwnProperty(sProp)) {\n                        if (vResult[sProp].constructor !== Array) {\n                            vResult[sProp] = [vResult[sProp]];\n                        }\n                        vResult[sProp].push(vContent);\n\n                    } else {\n                        if (options.childrenAsArray) {\n                            vResult[sProp] = [];\n                            vResult[sProp].push(vContent);\n                        } else {\n                            vResult[sProp] = vContent;\n                        }\n                        nLength++;\n                    }\n                }\n            }\n        } else if (!sCollectedTxt) { // no children and no text, return null\n            if (options.childrenAsArray) {\n                vResult[options.textKey] = [];\n                vResult[options.textKey].push(null);\n            } else {\n                vResult[options.textKey] = null;\n            }\n        }\n\n        if (sCollectedTxt) {\n            if (options.grokText) {\n                var value = this.grokType(sCollectedTxt.replace(trimMatch, ''));\n                if (value !== null && value !== undefined) {\n                    vResult[options.textKey] = value;\n                }\n            } else if (options.normalize) {\n                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '').replace(/\\s+/g, \" \");\n            } else {\n                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '');\n            }\n        }\n\n        return vResult;\n    }\n\n\n    // Convert xmlDocument to a string\n    // Returns null on failure\n    this.xmlToString = function (xmlDoc) {\n        try {\n            var xmlString = xmlDoc.xml ? xmlDoc.xml : (new XMLSerializer()).serializeToString(xmlDoc);\n            return xmlString;\n        } catch (err) {\n            return null;\n        }\n    }\n\n    // Convert a string to XML Node Structure\n    // Returns null on failure\n    this.stringToXML = function (xmlString) {\n        try {\n            var xmlDoc = null;\n\n            if (window.DOMParser) {\n\n                var parser = new DOMParser();\n                xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n\n                return xmlDoc;\n            } else {\n                xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n                xmlDoc.async = false;\n                xmlDoc.loadXML(xmlString);\n\n                return xmlDoc;\n            }\n        } catch (e) {\n            return null;\n        }\n    }\n\n    return this;\n}).call({});\n\nif (typeof module != \"undefined\" && module !== null && module.exports) module.exports = xmlToJSON;\nelse if (typeof define === \"function\" && define.amd) define(function () { return xmlToJSON });\n","import { LanguageModelFactory as LMF, LatinLanguageModel, GreekLanguageModel, ResourceProvider, Lexeme, Lemma, Feature, Inflection, Homonym } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/alpheiostb/config.json'\r\nimport xmlToJSON from 'xmltojson'\r\n\r\nclass AlpheiosTreebankAdapter extends BaseAdapter {\r\n  /**\r\n   * Treebank adapter uploads config data and fills model property\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.models = { lat: LatinLanguageModel, grc: GreekLanguageModel }\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} wordref - a word reference for getting homonym from Treebank\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, wordref) {\r\n    const server = this.prepareRequest(wordref)\r\n    if (!server.url) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_URL', { word: wordref }))\r\n      return\r\n    }\r\n    try {\r\n      const res = await this.fetch(server.url, { type: 'xml' })\r\n\r\n      if (res.constructor.name === 'AdapterError') {\r\n        return\r\n      }\r\n\r\n      if (res) {\r\n        const langCode = LMF.getLanguageCodeFromId(languageID)\r\n\r\n        const jsonObj = xmlToJSON.parseString(res)\r\n        jsonObj.words[0].word[0].entry[0].dict[0].hdwd[0]._attr = { lang: { _value: langCode } }\r\n\r\n        const homonym = this.transform(jsonObj, jsonObj.words[0].word[0].form[0]._text, server.config)\r\n        return homonym\r\n      } else {\r\n        this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_ANSWER_FOR_WORD', { word: wordref }))\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method prepares the request from the config\r\n   * @param {String} wordref - a word reference for getting homonym\r\n   * @return {String} - constructed url for getting data from Treebank\r\n  */\r\n  prepareRequest (wordref) {\r\n    const [text, fragment] = wordref.split(/#/)\r\n    let requestServer = {} // eslint-disable-line prefer-const\r\n    if (text && fragment) {\r\n      for (const serverConfig of this.config.servers) {\r\n        if (serverConfig.isDefault || serverConfig.texts.includes(text)) {\r\n          requestServer.config = serverConfig\r\n          requestServer.url = serverConfig.url.replace('r_TEXT', text)\r\n          requestServer.url = requestServer.url.replace('r_WORD', fragment).replace('r_CLIENT', serverConfig.clientId)\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return requestServer\r\n  }\r\n\r\n  /**\r\n   * This method transform data from adapter to Homonym\r\n   * @param {Object} jsonObj - data from adapter\r\n   * @param {String} targetWord - word\r\n   * @param {String} config - server config\r\n   * @return {Homonym}\r\n  */\r\n  transform (jsonObj, targetWord, config) {\r\n    'use strict'\r\n    const providerUri = config.providerUri\r\n    const providerRights = config.providerRights\r\n    const provider = new ResourceProvider(providerUri, providerRights)\r\n\r\n    const hdwd = jsonObj.words[0].word[0].entry[0].dict[0].hdwd[0]\r\n    let lemmaText = hdwd._text\r\n    // the Alpheios v1 treebank data kept trailing digits on the lemmas\r\n    // these won't match morphology service lemmas which have them stripped\r\n    lemmaText = lemmaText.replace(/\\d+$/, '')\r\n\r\n    const model = this.models[hdwd._attr.lang._value]\r\n    let lemma = new Lemma(lemmaText, model.languageCode) // eslint-disable-line prefer-const\r\n    const lexmodel = new Lexeme(lemma, [])\r\n    let inflection = new Inflection(lemmaText, model.languageID, null, null, null) // eslint-disable-line prefer-const\r\n    const infl = jsonObj.words[0].word[0].entry[0].infl[0]\r\n    inflection.addFeature(new Feature(Feature.types.fullForm, targetWord, model.languageID))\r\n\r\n    const features = config.featuresArray\r\n    for (const feature of features) {\r\n      const localName = feature[0]\r\n      const featureType = feature[1]\r\n      const addToLemma = feature[2]\r\n      if (infl[localName]) {\r\n        const obj = model.typeFeature(Feature.types[featureType]).createFeatures(infl[localName][0]._text, 1)\r\n        inflection.addFeature(obj)\r\n        if (addToLemma) {\r\n          lemma.addFeature(obj)\r\n        }\r\n      }\r\n    }\r\n    lexmodel.inflections = [inflection]\r\n    return new Homonym([ResourceProvider.getProxy(provider, lexmodel)], targetWord)\r\n  }\r\n}\r\n\r\nexport default AlpheiosTreebankAdapter\r\n","import BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport AlpheiosLexiconTransformer from '@clAdapters/transformers/alpheios-lexicon-transformer'\r\nimport { LanguageModelFactory, Constants, Feature } from 'alpheios-data-models'\r\nimport ImportData from '@clAdapters/transformers/import-morph-data.js'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/alpheiostb/config.json'\r\nimport {\r\n  MessagingService, WindowIframeDestination as Destination, RequestMessage, ResponseMessage\r\n} from 'alpheios-messaging'\r\n\r\nclass ArethusaTreebankAdapter extends BaseAdapter {\r\n  /**\r\n   * Treebank adapter uploads config data and fills model property\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.engineSet = null\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n  }\r\n\r\n  getMessagingService (config) {\r\n    if (!MessagingService.hasService(config.name)) {\r\n      MessagingService.createService(config.name, new Destination(config))\r\n    }\r\n    return MessagingService.getService(config.name)\r\n  }\r\n\r\n  async _fetchArethusaData (targetURL, sentenceId, wordId) {\r\n    const config = this._getMessageConfig(targetURL)\r\n    const svc = this.getMessagingService(config)\r\n    const requestBodyNav = {\r\n      gotoSentence: { sentenceId: sentenceId }\r\n    }\r\n    const message = new RequestMessage(requestBodyNav)\r\n    await svc.sendRequestTo(config.name, message)\r\n    const requestBodyMorph = {\r\n      getMorph: {\r\n        sentenceId: sentenceId,\r\n        wordId: wordId\r\n      }\r\n    }\r\n    const responseMessage = await svc.sendRequestTo(config.name, new RequestMessage(requestBodyMorph))\r\n    return responseMessage.body\r\n  }\r\n\r\n  _getMessageConfig (targetURL) {\r\n    return {\r\n      name: targetURL,\r\n      targetURL: targetURL,\r\n      targetIframeID: 'alpheios-treebank-frame'\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method refreshes the view of the Arethusa application\r\n   */\r\n  async refreshView (provider) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const requestBody = { refreshView: { } }\r\n    let response\r\n    try {\r\n      response = await svc.sendRequestTo(config.name, new RequestMessage(requestBody))\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n      return\r\n    }\r\n    return response.body\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - the target word\r\n   * @param {String} provider - the domain which provides Arethusa\r\n   * @param {String} sentenceId - the identifier for the sentence\r\n   * @param {String} wordId - the identifier for the word\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, word, provider, sentenceId, wordId) {\r\n    try {\r\n      if (typeof sentenceId !== 'undefined' && typeof wordId !== 'undefined') {\r\n        const tbRes = await this._fetchArethusaData(provider, sentenceId, wordId)\r\n        if (!tbRes || Object.keys(tbRes).length === 0) {\r\n          this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_ANSWER_FOR_WORD', { word: word }))\r\n          return\r\n        }\r\n        const languageModel = LanguageModelFactory.getLanguageModel(languageID)\r\n        if (!languageModel) {\r\n          this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNSUPPORTED_LANGUAGE', { languageId: languageID.toString() }))\r\n          return\r\n        }\r\n        let mapper = new ImportData(languageModel, 'arethusa') // eslint-disable-line prefer-const\r\n        mapper.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n          if (propertyName === 'pers') {\r\n            propertyValue = propertyValue.replace('first person', Constants.ORD_1ST)\r\n            propertyValue = propertyValue.replace('second person', Constants.ORD_2ND)\r\n            propertyValue = propertyValue.replace('third person', Constants.ORD_3RD)\r\n          }\r\n          return [propertyValue]\r\n        })\r\n        const transformAdapter = new AlpheiosLexiconTransformer(this, mapper, 'arethusa')\r\n        const homonym = transformAdapter.transformData(tbRes, word)\r\n        // handle verb participles in a way consistent with the morpheus parser\r\n        // which reports the pofs of the lemma as verb and pofs of the inflection as verb participle\r\n        if (homonym && homonym.lexemes && homonym.lexemes.length === 1 &&\r\n           homonym.lexemes[0].lemma.features[Feature.types.part].value === Constants.POFS_VERB &&\r\n           homonym.lexemes[0].inflections.length === 1 &&\r\n           homonym.lexemes[0].inflections[0][Feature.types.mood].value === Constants.MOOD_PARTICIPLE) {\r\n          homonym.lexemes[0].inflections[0].addFeature(new Feature(Feature.types.part, Constants.POFS_VERB_PARTICIPLE, languageModel.languageID))\r\n        }\r\n        return homonym\r\n      } else {\r\n        this.addError(this.l10n.getMsg('MORPH_TREEBANK_MISSING_REF', { request: word }))\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  async findWord (provider, word, prefix, suffix, sentenceId) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const gotoSentenceBody = {\r\n      gotoSentence: { sentenceId }\r\n    }\r\n    try {\r\n      await svc.sendRequestTo(config.name, new RequestMessage(gotoSentenceBody))\r\n      const findWordBody = { findWord: { sentenceId, word, prefix, suffix } }\r\n      const response = await svc.sendRequestTo(config.name, new RequestMessage(findWordBody))\r\n      return response.body\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n    }\r\n  }\r\n\r\n  async gotoSentence (provider, sentenceId, wordIds = []) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const gotoSentenceBody = {\r\n      gotoSentence: { sentenceId, wordIds }\r\n    }\r\n    try {\r\n      const response = await svc.sendRequestTo(config.name, new RequestMessage(gotoSentenceBody))\r\n      return response.body\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ArethusaTreebankAdapter\r\n","import axios from 'axios'\r\nimport { Logger } from 'alpheios-data-models'\r\nimport { L10n } from 'alpheios-l10n'\r\nimport AdapterError from '@clAdapters/errors/adapter-error'\r\nimport RemoteError from '@clAdapters/errors/remote-error.js'\r\n\r\nimport Locales from '@clAdapters/locales/locales.js'\r\nimport enUS from '@clAdapters/locales/en-us/messages.json'\r\nimport enGB from '@clAdapters/locales/en-gb/messages.json'\r\n\r\nclass BaseAdapter {\r\n  /**\r\n   * Every adapter has errors array and L10n property for localizing messages\r\n  */\r\n  constructor () {\r\n    this.errors = []\r\n    this.l10n = new L10n()\r\n      .addMessages(enUS, Locales.en_US)\r\n      .addMessages(enGB, Locales.en_GB)\r\n      .setLocale(Locales.en_US)\r\n  }\r\n\r\n  /**\r\n   * This method is used for adding error meassage with additional data\r\n   * @param {String} message  - message text for the error\r\n  */\r\n  addError (message) {\r\n    const error = new AdapterError(this.config.category, this.config.adapterName, this.config.method, message)\r\n    this.errors.push(error)\r\n  }\r\n\r\n  addRemoteError (errorCode, message) {\r\n    const error = new RemoteError(this.config.category, this.config.adapterName, this.config.method, errorCode, message)\r\n    this.errors.push(error)\r\n  }\r\n\r\n  /**\r\n   * This method is used for uploding config property from current properties and default properties\r\n   * @param {Object} config - properties with higher priority\r\n   * @param {Object} defaultConfig - default properties\r\n   * @return {Object} - configuration data\r\n  */\r\n  uploadConfig (config, defaultConfig) {\r\n    let configRes = {} // eslint-disable-line prefer-const\r\n    Object.keys(config).forEach(configKey => {\r\n      configRes[configKey] = config[configKey]\r\n    })\r\n\r\n    Object.keys(defaultConfig).forEach(configKey => {\r\n      if (configRes[configKey] === undefined) {\r\n        configRes[configKey] = defaultConfig[configKey]\r\n      }\r\n    })\r\n\r\n    return configRes\r\n  }\r\n\r\n  /**\r\n   * This method is used for creating timeout Promise\r\n   * @param {Number} ms - amount of ms for creation timeout\r\n   * @return {Promise}\r\n  */\r\n  timeout (ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using window.fetch\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   * @return {Object|String}\r\n  */\r\n  async fetchWindow (url, options = { type: 'json' }) {\r\n    if (url) {\r\n      try {\r\n        const response = await window.fetch(url)\r\n        if (!response.ok) {\r\n          this.addError(this.l10n.getMsg('BASIC_ADAPTER_URL_RESPONSE_FAILED', { statusCode: response.status, statusText: response.statusText }))\r\n          return\r\n        }\r\n        if (options.type === 'xml') {\r\n          return response.text()\r\n        } else {\r\n          return response.json()\r\n        }\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using window.fetch with timeout reject\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Promise}\r\n  */\r\n  fetchWindowTimeout (url, options) {\r\n    if (url) {\r\n      let didTimeOut = false\r\n      return new Promise((resolve, reject) => {\r\n        const timeout = setTimeout(() => {\r\n          didTimeOut = true\r\n          reject(new Error('Request timed out', url))\r\n        }, options.timeout)\r\n\r\n        window.fetch(url)\r\n          .then((response) => {\r\n            clearTimeout(timeout)\r\n            if (!didTimeOut) {\r\n              if (options.type === 'xml') {\r\n                resolve(response.text())\r\n              } else {\r\n                resolve(response.json())\r\n              }\r\n            }\r\n          })\r\n          .catch((err) => {\r\n            this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n            if (didTimeOut) return\r\n            reject(err)\r\n          })\r\n      })\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using axios\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Object|String}\r\n  */\r\n  async fetchAxios (url, options) {\r\n    if (url) {\r\n      try {\r\n        let res\r\n        if (options && options.timeout > 0) {\r\n          res = await axios.get(encodeURI(decodeURI(url)), { timeout: options.timeout })\r\n        } else {\r\n          res = await axios.get(encodeURI(decodeURI(url)))\r\n        }\r\n        return res.data\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  printError (error) {\r\n    if (error.response) {\r\n      // The request was made and the server responded with a status code\r\n      // that falls out of the range of 2xx\r\n      Logger.getInstance().error('Alpheios error: unexpected response retrieving data from service', error)\r\n    } else if (error.request) {\r\n      // The request was made but no response was received\r\n      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\r\n      // http.ClientRequest in node.js\r\n      Logger.getInstance().error('Alpheios error: no response from service', error)\r\n    } else {\r\n      // Something happened in setting up the request that triggered an Error\r\n      Logger.getInstance().error('Alpheios error: unexpected error requesting data from service', error.message)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using different methods. If window is defined - than it would be used window.fetch.\r\n   * Otherwise axios would be used.\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Object|String}\r\n  */\r\n  async fetch (url, options) {\r\n    let res\r\n\r\n    if (url) {\r\n      try {\r\n        if (typeof window !== 'undefined' && typeof window.fetch !== 'undefined') {\r\n          if (options && options.timeout > 0) {\r\n            res = await this.fetchWindowTimeout(url, options)\r\n          } else {\r\n            res = await this.fetchWindow(url, options)\r\n          }\r\n        } else {\r\n          res = await this.fetchAxios(url, options)\r\n        }\r\n\r\n        return res\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_UNKNOWN_ERROR', { message: error.message }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseAdapter\r\n","/* eslint-disable no-unused-vars */\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport { ChineseLanguageModel, Lemma, Lexeme, Homonym, Feature, Definition } from 'alpheios-data-models'\r\nimport {\r\n  MessagingService, WindowIframeDestination as Destination, CedictDestinationConfig as CedictConfig, RequestMessage\r\n} from 'alpheios-messaging'\r\n\r\nexport const CedictCharacterForms = {\r\n  SIMPLIFIED: 'simplified',\r\n  TRADITIONAL: 'traditional'\r\n}\r\n\r\nconst msgServiceName = 'AdaptersLexisService'\r\n\r\nclass AlpheiosChineseLocAdapter extends BaseAdapter {\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = config\r\n    this.cedictConfig = CedictConfig\r\n    if (!this.config.serviceUrl) {\r\n      throw new Error('An obligatory serviceUrl parameter is missing')\r\n    }\r\n    this.cedictConfig.targetURL = this.config.serviceUrl\r\n\r\n    /*\r\n    AlpheiosChineseLocAdapter is created every time when a new lexical request for Chinese data comes in.\r\n    We do not want to create a new instance of a messaging service with that. Thus, we'll use a single\r\n    instance of the service that will be created once and reused across consecutive constructor invocations.\r\n     */\r\n    if (!MessagingService.hasService(msgServiceName)) {\r\n      MessagingService.createService(msgServiceName, new Destination({\r\n        name: this.cedictConfig.name,\r\n        targetURL: this.cedictConfig.targetURL,\r\n        targetIframeID: this.cedictConfig.targetIframeID,\r\n        commModes: [Destination.commModes.SEND]\r\n      }))\r\n    }\r\n    this._messagingService = MessagingService.getService(msgServiceName)\r\n  }\r\n\r\n  get languageID () { return ChineseLanguageModel.languageID }\r\n\r\n  /**\r\n   * Creates a list of words that will be requested from a CEDICT service.\r\n   * This method builds a list of words that would make sense in a context of a Chinese language\r\n   * out of the word selected by user and its surrounding texts (context forward represents\r\n   * the text that is located at the right of the selected word.\r\n   *\r\n   * @param {string} targetWord - A word that was selected by the user.\r\n   * @param {string} contextForward - A piece of text that follows the selected word in a text.\r\n   * @returns {[string]} An array of words that will be requested from a CEDICT service.\r\n   * @private\r\n   */\r\n  static _buildWordList (targetWord, contextForward) {\r\n    const wordList = [targetWord]\r\n    if (contextForward) {\r\n      for (let i = 0; i < contextForward.length; i++) {\r\n        wordList.push(`${targetWord}${contextForward.slice(0, i + 1)}`)\r\n      }\r\n    }\r\n    return wordList\r\n  }\r\n\r\n  async getHomonym (targetWord, contextForward) {\r\n    try {\r\n      const requestBody = {\r\n        getWords: {\r\n          words: this.constructor._buildWordList(targetWord, contextForward)\r\n        }\r\n      }\r\n      let response\r\n      try {\r\n        response = await this._messagingService.sendRequestTo(this.cedictConfig.name, new RequestMessage(requestBody))\r\n      } catch (response) {\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n        return\r\n      }\r\n\r\n      if (Object.keys(response.body).length === 0) {\r\n        this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: targetWord, languageId: this.languageID.toString() }))\r\n        return\r\n      }\r\n      const homonym = this._transformData(response.body, targetWord)\r\n      if (!homonym) {\r\n        this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: targetWord, languageId: this.languageID.toString() }))\r\n        return\r\n      }\r\n      return homonym\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  async loadData (timeout) {\r\n    try {\r\n      const requestBody = {\r\n        loadData: {}\r\n      }\r\n      let response\r\n      try {\r\n        response = await this._messagingService.sendRequestTo(this.cedictConfig.name, new RequestMessage(requestBody), timeout)\r\n      } catch (response) {\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  _transformData (cedictEntries, targetWord) {\r\n    // eslint-disable-next-line no-prototype-builtins\r\n    const characterForm = cedictEntries.hasOwnProperty(CedictCharacterForms.SIMPLIFIED)\r\n      ? CedictCharacterForms.SIMPLIFIED\r\n      : CedictCharacterForms.TRADITIONAL\r\n    let lexemes = [] // eslint-disable-line prefer-const\r\n    const wordEntries = Object.values(cedictEntries[characterForm]).flat()\r\n    wordEntries.forEach(entry => {\r\n      const cfData = entry[characterForm]\r\n      const headword = cfData.headword\r\n      let lemma = new Lemma(headword, this.languageID, []) // eslint-disable-line prefer-const\r\n\r\n      // eslint-disable-next-line prefer-const\r\n      let pronunciationValues = entry.pinyin ? [ChineseLanguageModel.formatPinyin(entry.pinyin)] : []\r\n      pronunciationValues = ['mandarin', 'cantonese', 'tang'].reduce((arr, i) => {\r\n        // Add all of the values listed above to an array or pronunciation feature. Each feature value will be preceded with its name.\r\n        // TODO: Update once we decide on a better format of storing pronunciation in a Feature object.\r\n        if (cfData[i]) arr.push(`${i} - ${cfData[i]}`); return arr\r\n      }, pronunciationValues)\r\n      lemma.addFeature(this._createFeature(Feature.types.pronunciation, pronunciationValues))\r\n      lemma.addFeature(this._createFeature(Feature.types.note, characterForm))\r\n      if (cfData.radical && cfData.radical.character) lemma.addFeature(this._createFeature(Feature.types.radical, cfData.radical.character))\r\n      if (cfData.frequency) lemma.addFeature(this._createFeature(Feature.types.frequency, cfData.frequency, 10))\r\n\r\n      let lexModel = new Lexeme(lemma, []) // eslint-disable-line prefer-const\r\n      const shortDefs = entry.definitions.map(entry => new Definition(entry, 'eng', 'text/plain', headword))\r\n      lexModel.meaning.appendShortDefs(shortDefs)\r\n      lexemes.push(lexModel)\r\n    })\r\n    let homonym = new Homonym(lexemes, targetWord) // eslint-disable-line prefer-const\r\n    /*\r\n    As a temporary measure, until HomonymSet is introduced, we will place several Chinese homonyms\r\n    into the single Homonym object as individual lexemes. We will use an `isMultiHomonym` prop set to true\r\n    to mark Homonym objects like this.\r\n     */\r\n    homonym.isMultiHomonym = AlpheiosChineseLocAdapter._wordsFound(cedictEntries[characterForm]) > 1\r\n    return homonym\r\n  }\r\n\r\n  /**\r\n   * Returns the number of words that has some matching CEDICT entries.\r\n   *\r\n   * @param {object} result - Data returned from CEDICT, an object whose keys are words and values are arrays\r\n   *        either empty (if no entries in CEDICT are found for a word) or containing CEDICT records.\r\n   * @returns {number} A number of words that has some matching CECIDT records.\r\n   * @private\r\n   */\r\n  static _wordsFound (result) {\r\n    return Object.keys(result).filter(key => result[key].length > 0).length\r\n  }\r\n\r\n  _createFeature (featureType, values) {\r\n    return new Feature(featureType, values, this.languageID)\r\n  }\r\n}\r\n\r\nexport default AlpheiosChineseLocAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/concordance/config.json'\r\nimport AuthorWorkConfigConfig from '@clAdapters/adapters/concordance/author-work.json'\r\n\r\nimport { ResourceProvider, Author, TextWork, WordUsageExample, LanguageModelFactory } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nclass AlpheiosConcordanceAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data and creates provider\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.provider = new ResourceProvider(this.config.url, this.config.rights)\r\n    this.authors = []\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of available authors and textWorks.\r\n  * For now it uploads data from json file, but later it will fetch data from cordance api\r\n  * @param {Boolean} reload - if true - data will be forced to reload from source\r\n  * @return {Author[]]}\r\n  */\r\n  async getAuthorsWorks (reload = false) {\r\n    try {\r\n      if (reload || this.authors.length === 0) {\r\n        this.authorWorkData = await this.uploadConfig({}, AuthorWorkConfigConfig)\r\n\r\n        this.authors = []\r\n        for (const authorWorkDataItem of Object.values(this.authorWorkData.authors)) {\r\n          const author = this.createAuthor(authorWorkDataItem)\r\n          this.authors.push(author)\r\n        }\r\n      }\r\n      return this.authors\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('CONCORDANCE_AUTHOR_UPLOAD_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of word usage examples from corcondance api and creates WordUsageExample-s.\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @param {Object} sort - { } - it is an empty property for future sort feature\r\n  * @return {Object} - with the following format\r\n  *         {\r\n  *           {WordUsageExample[]} wordUsageExamples - result wordUsageExamples\r\n  *           {String} targetWord - source targetWord\r\n  *           {String} language - source languageCode\r\n  *           {ResourceProvider} provider - provider data\r\n  *         }\r\n  */\r\n  async getWordUsageExamples (homonym, filters = {}, pagination = {}, sort = {}) {\r\n    try {\r\n      const url = this.createFetchURL(homonym, filters, pagination, sort)\r\n      const wordUsageListRes = await this.fetch(url)\r\n      if (Array.isArray(wordUsageListRes)) {\r\n        const parsedWordUsageList = await this.parseWordUsageResult(wordUsageListRes, homonym)\r\n        return {\r\n          wordUsageExamples: parsedWordUsageList,\r\n          targetWord: homonym.targetWord,\r\n          language: LanguageModelFactory.getLanguageCodeFromId(homonym.languageID),\r\n          provider: this.provider\r\n        }\r\n      } else {\r\n        return []\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('CONCORDANCE_WORD_USAGE_FETCH_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method constructs full url for getting data for getWordUsageExamples method using properties.\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @param {Object} sort - { } - it is an empty property for future sort feature\r\n  * @return {String}\r\n  */\r\n  createFetchURL (homonym, filters, pagination, sort) {\r\n    const filterFormatted = this.formatFilter(filters)\r\n    const paginationFormatted = this.formatPagination(pagination)\r\n    return `${this.config.url}${encodeURIComponent(homonym.targetWord)}${filterFormatted}${paginationFormatted}`\r\n  }\r\n\r\n  /**\r\n  * This method formats filters property for fetch url.\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @return {String}\r\n  */\r\n  formatFilter (filters) {\r\n    if (filters && filters.author) {\r\n      if (filters.textWork) {\r\n        return `[${filters.author.ID}:${filters.textWork.ID}]`\r\n      }\r\n      return `[${filters.author.ID}]`\r\n    }\r\n    return ''\r\n  }\r\n\r\n  /**\r\n  * This method formats pagination property for fetch url.\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @return {String}\r\n  */\r\n  formatPagination (pagination) {\r\n    // the PHI service supports two pagination parameters: authmax and max\r\n    // authmax sets the max hits to return per author and max sets the max hits to return over alpheios-data-models\r\n    // max trumps authmax - i.e. only the max number of hits will be returned, and authmax applies after that\r\n    // given that there a finite number of authors, we want to set the values for these differently depending upon whether\r\n    // the request is filtered by author or not - and allowing user specification of the max across all authors probably\r\n    // isn't a good idea, because what we really want in this case is no overall max applied, but that option is not\r\n    // avaliable from the service at the moment\r\n    if (pagination && pagination.property && (pagination.property === 'authmax') && pagination.value) {\r\n      return `?${pagination.property}=${parseInt(pagination.value)}&max=${this.config.maxResultsOverride}`\r\n    } else if (pagination && pagination.property && (pagination.property === 'max') && pagination.value) {\r\n      return `?${pagination.property}=${parseInt(pagination.value)}`\r\n    }\r\n    return ''\r\n  }\r\n\r\n  /**\r\n  * This method parses json result from concordance source for word usage examples.\r\n  * @param {Object} jsonObj - json response from url\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Author} author - author from filter\r\n  * @param {TextWork} textWork - textWork from filter\r\n  * @return {WordUsageExample[]}\r\n  */\r\n  async parseWordUsageResult (jsonObj, homonym) {\r\n    let wordUsageExamples = [] // eslint-disable-line prefer-const\r\n    let author, textWork, passage\r\n\r\n    if (this.authors.length === 0) {\r\n      await this.getAuthorsWorks()\r\n    }\r\n\r\n    for (const jsonObjItem of jsonObj) {\r\n      author = this.getAuthorByAbbr(jsonObjItem)\r\n      if (author) {\r\n        textWork = this.getTextWorkByAbbr(author, jsonObjItem)\r\n        if (textWork) {\r\n          passage = this.getPassage(jsonObjItem)\r\n\r\n          let wordUsageExample = this.createWordUsageExample(jsonObjItem, homonym, author, textWork, passage) // eslint-disable-line prefer-const\r\n          wordUsageExamples.push(wordUsageExample)\r\n        }\r\n      }\r\n    }\r\n    return wordUsageExamples\r\n  }\r\n\r\n  getAuthorByAbbr (jsonObj) {\r\n    if (jsonObj.cit && this.authors.length > 0) {\r\n      const authorAbbr = jsonObj.cit.split('.')[0]\r\n      return this.authors.find(author => Object.values(author.abbreviations).includes(authorAbbr))\r\n    }\r\n    return null\r\n  }\r\n\r\n  getTextWorkByAbbr (author, jsonObj) {\r\n    if (jsonObj.cit && author && author.works.length > 0) {\r\n      const parts = jsonObj.cit.split('.')\r\n      // if we have only 2 parts in the citation, it's probably an author without a work\r\n      // which in the phi data is really when the author and work are referenced as the same thing\r\n      // as in an anonymous work\r\n      if (parts.length > 2) {\r\n        const textWorkAbbr = parts[1]\r\n        return author.works.find(textWork => Object.values(textWork.abbreviations).includes(textWorkAbbr))\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  getPassage (jsonObj) {\r\n    let passage = null\r\n    if (jsonObj.cit) {\r\n      const parts = jsonObj.cit.split('.')\r\n      // if we have only 2 parts in the citation, it's probably an author without a work\r\n      // which in the phi data is really when the author and work are referenced as the same thing\r\n      // as in an anonymous work\r\n      if (parts.length === 2) {\r\n        passage = parts.slice(1).join('.')\r\n      } else if (parts.length > 2) {\r\n        passage = parts.slice(2).join('.')\r\n      }\r\n    }\r\n    return passage\r\n  }\r\n\r\n  /**\r\n  * This property is used to define prefix fr extract ID\r\n  * @returns {String}\r\n  */\r\n  get defaultIDPrefix () {\r\n    return 'phi'\r\n  }\r\n\r\n  /**\r\n  * Method returns Author for given jsonObj (from concordance API)\r\n  * @param {Object} jsonObj - json object with data of the Author\r\n  * @returns {Author}\r\n  */\r\n  createAuthor (jsonObj) {\r\n    let titles = {} // eslint-disable-line prefer-const\r\n    jsonObj.title.forEach(titleItem => {\r\n      titles[titleItem['@lang']] = titleItem['@value']\r\n    })\r\n\r\n    let abbreviations = {} // eslint-disable-line prefer-const\r\n    jsonObj.abbreviations.forEach(abbrItem => {\r\n      abbreviations[abbrItem['@lang']] = abbrItem['@value'].replace('.', '')\r\n    })\r\n\r\n    let author = new Author(jsonObj.urn, titles, abbreviations) // eslint-disable-line prefer-const\r\n    author.ID = this.extractIDFromURNAuthor(author.urn)\r\n    let works = [] // eslint-disable-line prefer-const\r\n\r\n    jsonObj.works.forEach(workItem => {\r\n      works.push(this.createTextWork(author, workItem))\r\n    })\r\n\r\n    author.works = works\r\n    return author\r\n  }\r\n\r\n  /**\r\n  * Method extracts ID from the urn, if it is correct. Otherwise it returns null.\r\n  * @returns {Number, null}\r\n  */\r\n  extractIDFromURNAuthor (urn) {\r\n    const partsUrn = urn.split(':')\r\n    if (Array.isArray(partsUrn) && partsUrn.length >= 4) {\r\n      const workIDPart = partsUrn[3].indexOf('.') === -1 ? partsUrn[3] : partsUrn[3].substr(0, partsUrn[3].indexOf('.'))\r\n      return parseInt(workIDPart.replace(this.defaultIDPrefix, ''))\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n  * Method returns TextWork for given jsonObj (from concordance API)\r\n  * @param {Author} author - author of the textWork\r\n  * @param {Object} jsonObj - json object with data of the TextWork\r\n  * @returns {TextWork}\r\n  */\r\n  createTextWork (author, jsonObj) {\r\n    let titles = {} // eslint-disable-line prefer-const\r\n    jsonObj.title.forEach(titleItem => {\r\n      titles[titleItem['@lang']] = titleItem['@value']\r\n    })\r\n\r\n    let abbreviations = {} // eslint-disable-line prefer-const\r\n    jsonObj.abbreviations.forEach(abbrItem => {\r\n      abbreviations[abbrItem['@lang']] = abbrItem['@value'].replace('.', '')\r\n    })\r\n\r\n    let textWork = new TextWork(author, jsonObj.urn, titles, abbreviations) // eslint-disable-line prefer-const\r\n    textWork.ID = this.extractIDFromURNTextWork(textWork.urn)\r\n    return textWork\r\n  }\r\n\r\n  /**\r\n  * Method extracts ID from the urn, if it is correct. Otherwise it returns null.\r\n  * @returns {Number, null}\r\n  */\r\n  extractIDFromURNTextWork (urn) {\r\n    const partsUrn = urn.split(':')\r\n\r\n    if (Array.isArray(partsUrn) && partsUrn.length >= 4) {\r\n      const workIDPart = partsUrn[3].indexOf('.') === -1 ? null : partsUrn[3].substr(partsUrn[3].indexOf('.') + 1)\r\n\r\n      return parseInt(workIDPart.replace(this.defaultIDPrefix, ''))\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n  * Creates WordUsageExample object from jsonObj, homonym, author, textWork and link from the adapter config\r\n  * @param {Object} jsonObj - json object from concordance api\r\n  * @param {Homonym} homonym - source homonym object\r\n  * @param {Author} author - source author object, could be undefined\r\n  * @param {TextWork} textWork - source textWork object, could be undefined\r\n  * @param {String} passage - passage string, could be null\r\n  * @returns {WordUsageExample}\r\n  */\r\n  createWordUsageExample (jsonObj, homonym, author, textWork, passage) {\r\n    const source = this.config.sourceTextUrl + jsonObj.link\r\n    let wordUsageExample = new WordUsageExample( // eslint-disable-line prefer-const\r\n      LanguageModelFactory.getLanguageCodeFromId(homonym.languageID), jsonObj.target, jsonObj.left, jsonObj.right, source, jsonObj.cit\r\n    )\r\n    wordUsageExample.author = author\r\n    wordUsageExample.textWork = textWork\r\n    wordUsageExample.passage = passage\r\n    wordUsageExample.homonym = homonym\r\n    wordUsageExample.provider = this.provider\r\n\r\n    return wordUsageExample\r\n  }\r\n}\r\n\r\nexport default AlpheiosConcordanceAdapter\r\n","import { LanguageModelFactory as LMF, Definition, ResourceProvider } from 'alpheios-data-models'\r\nimport papaparse from 'papaparse'\r\n\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport DefaultConfig from '@clAdapters/adapters/lexicons/config.json'\r\n\r\nlet cachedDefinitions = new Map() // eslint-disable-line prefer-const\r\nlet uploadStarted = new Map() // eslint-disable-line prefer-const\r\n\r\nclass AlpheiosLexiconsAdapter extends BaseAdapter {\r\n  /**\r\n  * Lexicons adapter uploads config data, defines default options and inits data\r\n  * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.options = { timeout: this.config.timeout ? this.config.timeout : 0 }\r\n    this.async = Boolean(this.config.callBackEvtSuccess)\r\n  }\r\n\r\n  /**\r\n  * This method retrieves short definitions for given homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  */\r\n  async fetchShortDefs (homonym, options = {}) {\r\n    await this.fetchDefinitions(homonym, options, 'short')\r\n  }\r\n\r\n  /**\r\n  * This method retrieves full definitions for given homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  */\r\n  async fetchFullDefs (homonym, options = {}) {\r\n    await this.fetchDefinitions(homonym, options, 'full')\r\n  }\r\n\r\n  /**\r\n  * This method creates Promise for getting short definitions, for being able to parallel requests\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {String} urlKey - urlIndex for geting data from config\r\n  */\r\n  prepareShortDefPromise (homonym, urlKey) {\r\n    const url = this.config[urlKey].urls.short\r\n    const requestType = 'shortDefs'\r\n\r\n    const resCheckCached = this.checkCachedData(url)\r\n    return resCheckCached.then(\r\n      async (result) => {\r\n        if (result) {\r\n          const res = cachedDefinitions.get(url)\r\n          await this.updateShortDefs(res, homonym, this.config[urlKey])\r\n          this.prepareSuccessCallback(requestType, homonym)\r\n        }\r\n      },\r\n      error => {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        this.prepareFailedCallback(requestType, homonym)\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n  * This method creates Promise for getting full definitions, for being able to parallel requests\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {String} urlKey - urlIndex for geting data from config\r\n  */\r\n  prepareFullDefPromise (homonym, urlKey) {\r\n    const url = this.config[urlKey].urls.index\r\n    const requestType = 'fullDefs'\r\n\r\n    const resCheckCached = this.checkCachedData(url)\r\n    return resCheckCached.then(\r\n      async (result) => {\r\n        if (result) {\r\n          const fullDefsRequests = this.collectFullDefURLs(cachedDefinitions.get(url), homonym, this.config[urlKey])\r\n          const resFullDefs = this.updateFullDefsAsync(fullDefsRequests, this.config[urlKey], homonym)\r\n          resFullDefs.catch(error => {\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n            this.prepareFailedCallback(requestType, homonym)\r\n          })\r\n        }\r\n      },\r\n      error => {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        this.prepareFailedCallback(requestType, homonym)\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n  * This method checks if there is a callBackEvtSuccess defined and publish it if exists\r\n  * @param {String} requestType - name of the request - shortDef and fullDef\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  prepareSuccessCallback (requestType, homonym) {\r\n    if (this.config.callBackEvtSuccess) {\r\n      this.config.callBackEvtSuccess.pub({\r\n        requestType: requestType,\r\n        homonym: homonym\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if there is a callBackEvtFailed defined and publish it if exists\r\n  * @param {String} requestType - name of the request - shortDef and fullDef\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  prepareFailedCallback (requestType, homonym) {\r\n    if (this.config.callBackEvtFailed) {\r\n      this.config.callBackEvtFailed.pub({\r\n        requestType: requestType,\r\n        homonym: homonym\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a generic method that retrieves definitions for homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  * @param {Object} lookupFunction - type of definitions - short, full\r\n  * @return {Boolean} - result of fetching\r\n  */\r\n  async fetchDefinitions (homonym, options, lookupFunction) {\r\n    Object.assign(this.options, options)\r\n    if (!this.options.allow || this.options.allow.length === 0) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_NO_ALLOWED_URL'))\r\n      return\r\n    }\r\n\r\n    if (this.async) {\r\n      return this.fetchDefsAsync(homonym, lookupFunction)\r\n    } else {\r\n      if (lookupFunction === 'short') {\r\n        return this.fetchShortDefsSync(homonym)\r\n      } else if (lookupFunction === 'full') {\r\n        return this.fetchFullDefsSync(homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a sync method that retrieves short definitions for homonym synchronously\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  async fetchShortDefsSync (homonym) {\r\n    try {\r\n      const languageID = homonym.lexemes[0].lemma.languageID\r\n      const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n      for (const urlKey of urlKeys) {\r\n        const url = this.config[urlKey].urls.short\r\n        const result = await this.checkCachedData(url)\r\n\r\n        if (result) {\r\n          const res = cachedDefinitions.get(url)\r\n          await this.updateShortDefs(res, homonym, this.config[urlKey])\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a sync method that retrieves full definitions for homonym synchronously\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  async fetchFullDefsSync (homonym) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n    for (const urlKey of urlKeys) {\r\n      const url = this.config[urlKey].urls.index\r\n      const result = await this.checkCachedData(url)\r\n\r\n      if (result) {\r\n        const fullDefsRequests = this.collectFullDefURLs(cachedDefinitions.get(url), homonym, this.config[urlKey])\r\n        await this.updateFullDefs(fullDefsRequests, this.config[urlKey], homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is an async method that retrieves definitions for homonym with getting result inside callbacks\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} lookupFunction - type of definitions - short, full\r\n  * @return {Boolean} - result of fetching\r\n  */\r\n\r\n  fetchDefsAsync (homonym, lookupFunction) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n    for (const urlKey of urlKeys) {\r\n      if (lookupFunction === 'short') {\r\n        this.prepareShortDefPromise(homonym, urlKey, lookupFunction)\r\n      }\r\n      if (lookupFunction === 'full') {\r\n        this.prepareFullDefPromise(homonym, urlKey, lookupFunction)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if data from url is already cached and if not - it uploads data from url to cache\r\n  * @param {String} url - url from what we need to cache data\r\n  * @param {Null|Map|String} externalData - data that would be used as fixture for the url\r\n  * @param {Boolean} skipFetch - when this check is true, then fetch would not be execute in any case, it is used for Full Definitions\r\n  * @return {Boolean} - true - if cached is successed\r\n  */\r\n  async checkCachedData (url, externalData = null, skipFetch = false) {\r\n    if (!externalData && skipFetch) {\r\n      return false\r\n    }\r\n    if (!cachedDefinitions.has(url) && !uploadStarted.has(url)) {\r\n      try {\r\n        uploadStarted.set(url, true)\r\n\r\n        let data = externalData\r\n        if (!externalData) {\r\n          const unparsed = await this.fetch(url, { type: 'xml', timeout: this.options.timeout })\r\n          const parsed = papaparse.parse(unparsed, { quoteChar: '\\u{0000}', delimiter: '|' })\r\n          data = this.fillMap(parsed.data)\r\n        }\r\n\r\n        cachedDefinitions.set(url, data)\r\n        uploadStarted.set(url, false)\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        uploadStarted.set(url, false)\r\n        return false\r\n      }\r\n    } else if (uploadStarted.has(url) && uploadStarted.get(url)) {\r\n      setTimeout(() => {\r\n        this.checkCachedData(url)\r\n      }, this.options.timeout)\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n  * This method searches for definitions in cached text, creates definitions and updates lexemes\r\n  * @param {Map} data - cached data from definition's url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  * @param {Object} config - config data for url\r\n  */\r\n  async updateShortDefs (data, homonym, config) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const model = LMF.getLanguageModel(languageID)\r\n\r\n    for (let lexeme of homonym.lexemes) { // eslint-disable-line prefer-const\r\n      const deftexts = this.lookupInDataIndex(data, lexeme.lemma, model)\r\n      if (deftexts) {\r\n        for (const d of deftexts) {\r\n          const text = d.field1\r\n          const providerCode = d.field2\r\n          const format = config.format && config.format.short ? config.format.short : 'text/plain'\r\n          try {\r\n            let rightsText = config.rights\r\n            let rightsUri = config.urls.short\r\n            if (providerCode && config.rights_keys && config.rights_keys[providerCode]) {\r\n              rightsUri = rightsUri + `#${providerCode}`\r\n              rightsText = config.rights_keys[providerCode]\r\n            }\r\n            const provider = new ResourceProvider(rightsUri, rightsText)\r\n            const def = new Definition(text, config.langs.target, format, lexeme.lemma.word)\r\n            const definition = ResourceProvider.getProxy(provider, def)\r\n            lexeme.meaning.appendShortDefs(definition)\r\n          } catch (error) {\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n            continue\r\n          }\r\n        }\r\n      } else {\r\n        const url = config.urls.short\r\n        this.addError(this.l10n.getMsg('LEXICONS_NO_DATA_FROM_URL', { url: url }))\r\n        this.prepareFailedCallback('shortDefs', homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method creates requests to full definitions url for each lexeme and given config\r\n  * @param {Map} data - cached data from definition's index url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  * @param {Object} config - config data for url\r\n  * @return {[String]} - array of urls for retrieving data\r\n  */\r\n  collectFullDefURLs (data, homonym, config) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const model = LMF.getLanguageModel(languageID)\r\n    const urlFull = config.urls.full\r\n\r\n    if (!urlFull) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_NO_FULL_URL'))\r\n      return\r\n    }\r\n\r\n    let requests = [] // eslint-disable-line prefer-const\r\n    for (const lexeme of homonym.lexemes) {\r\n      const ids = this.lookupInDataIndex(data, lexeme.lemma, model)\r\n      if (urlFull && ids) {\r\n        for (const id of ids) {\r\n          requests.push({ url: `${urlFull}&n=${id.field1}`, lexeme: lexeme })\r\n        }\r\n      } else if (urlFull) {\r\n        requests.push({ url: `${urlFull}&l=${encodeURIComponent(lexeme.lemma.word)}`, lexeme: lexeme })\r\n      }\r\n    }\r\n    return requests\r\n  }\r\n\r\n  /**\r\n  * This method fetches data from request and update homonym with full definition - it is made as Promises with calback to make it parallel\r\n  * @param {[String]} fullDefsRequests - array of full definitions url\r\n  * @param {Object} config - config data for url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  */\r\n  async updateFullDefsAsync (fullDefsRequests, config, homonym) {\r\n    for (let request of fullDefsRequests) { // eslint-disable-line prefer-const\r\n      let fullDefDataRes\r\n      if (cachedDefinitions.has(request.url)) {\r\n        fullDefDataRes = new Promise((resolve, reject) => resolve(cachedDefinitions.get(request.url)))\r\n      } else {\r\n        fullDefDataRes = this.fetch(request.url, { type: 'xml' })\r\n      }\r\n\r\n      fullDefDataRes.then(\r\n        async (fullDefData) => {\r\n          if (fullDefData && fullDefData.match(/alph:error|alpheios-lex-error/)) {\r\n            const error = fullDefData.match(/no entries found/i) ? 'No entries found.' : fullDefData\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error }))\r\n            this.prepareFailedCallback('fullDefs', homonym)\r\n          } else {\r\n            const provider = new ResourceProvider(config.urls.full, config.rights)\r\n            const def = new Definition(fullDefData, config.langs.target, 'text/plain', request.lexeme.lemma.word)\r\n            const definition = ResourceProvider.getProxy(provider, def)\r\n            request.lexeme.meaning.appendFullDefs(definition)\r\n            this.prepareSuccessCallback('fullDefs', homonym)\r\n          }\r\n        },\r\n        error => {\r\n          this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method fetches data from request and update homonym with full definition synchronously\r\n  * @param {[String]} fullDefsRequests - array of full definitions url\r\n  * @param {Object} config - config data for url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  */\r\n  async updateFullDefs (fullDefsRequests, config, homonym) {\r\n    for (let request of fullDefsRequests) { // eslint-disable-line prefer-const\r\n      let fullDefData\r\n      if (cachedDefinitions.has(request.url)) {\r\n        fullDefData = cachedDefinitions.get(request.url)\r\n      } else {\r\n        fullDefData = await this.fetch(request.url, { type: 'xml' })\r\n      }\r\n\r\n      try {\r\n        if (fullDefData && fullDefData.match(/alph:error|alpheios-lex-error/)) {\r\n          const error = fullDefData.match(/no entries found/i) ? 'No entries found.' : fullDefData\r\n          this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error }))\r\n        } else {\r\n          const provider = new ResourceProvider(config.urls.full, config.rights)\r\n          const def = new Definition(fullDefData, config.langs.target, 'text/plain', request.lexeme.lemma.word)\r\n          const definition = ResourceProvider.getProxy(provider, def)\r\n          request.lexeme.meaning.appendFullDefs(definition)\r\n        }\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This method retrieves urls from config for given languageCode\r\n  * @param {Symbol} languageID\r\n  */\r\n  getRequests (languageID) {\r\n    const languageCode = LMF.getLanguageCodeFromId(languageID)\r\n    return Object.keys(this.config).filter(url => this.config[url] && this.config[url].langs && this.config[url].langs.source === languageCode)\r\n  }\r\n\r\n  /**\r\n   * fills the data map with the rows from the parsed file\r\n   * we need a method to do this because there may be homonyms in\r\n   * the files\r\n   * @param {string[]} rows\r\n   * @return {Map} the filled map\r\n   */\r\n  fillMap (rows) {\r\n    let data = new Map() // eslint-disable-line prefer-const\r\n    for (const row of rows) {\r\n      const def = { field1: row[1], field2: null }\r\n      if (row.length > 2) {\r\n        def.field2 = row[2]\r\n      }\r\n      if (data.has(row[0])) {\r\n        data.get(row[0]).push(def)\r\n      } else {\r\n        data.set(row[0], [def])\r\n      }\r\n    }\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Lookup a Lemma object in an Alpheios v1 data index\r\n   * @param {Map} data the data inddex\r\n   * @param {Lemma} lemma the lemma to lookupInDataIndex\r\n   * @param {LanguageModel} model a language model for language specific methods\r\n   * @return {string} the index entry as a text string\r\n   */\r\n  lookupInDataIndex (data, lemma, model) {\r\n    // legacy behavior from Alpheios lemma data file indices\r\n    // first look to see if we explicitly have an instance of this lemma\r\n    // with capitalization retained\r\n    let found\r\n\r\n    let alternatives = []\r\n    let altEncodings = [] // eslint-disable-line prefer-const\r\n    for (const l of [lemma.word, ...lemma.principalParts]) {\r\n      alternatives.push(l)\r\n      for (const a of model.alternateWordEncodings({ word: l, preserveCase: true })) {\r\n        // we gather altEncodings separately because they should\r\n        // be tried last after the lemma and principalParts in their\r\n        // original form\r\n        altEncodings.push(a)\r\n      }\r\n      const nosense = l.replace(/_?\\d+$/, '')\r\n      if (l !== nosense) {\r\n        alternatives.push(nosense)\r\n      }\r\n    }\r\n    alternatives = [...alternatives, ...altEncodings]\r\n    for (const lookup of alternatives) {\r\n      // let's first just look for the word in its supplied case\r\n      found = false\r\n      if (data && lookup) {\r\n        found = data.get(lookup)\r\n\r\n        // and if we don't find it, then try lower case\r\n        if (!found) {\r\n          found = data.get(lookup.toLocaleLowerCase())\r\n        }\r\n\r\n        if (found) {\r\n          found = this._lookupSpecial(data, lookup, found)\r\n        }\r\n        if (found) {\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // if we still don't have a match, we can do a last ditch check without\r\n    // any diacritics at all in those languages that support it\r\n    if (!found) {\r\n      let lastAlt = [] // eslint-disable-line prefer-const\r\n      for (const l of [lemma.word, ...lemma.principalParts]) {\r\n        const strippedAll = model.alternateWordEncodings({\r\n          word: l,\r\n          encoding: 'strippedAll',\r\n          preserveCase: true\r\n        })\r\n        if (strippedAll.length > 0) {\r\n          lastAlt.push(strippedAll[0])\r\n        }\r\n      }\r\n      if (lastAlt.length > 0) {\r\n        for (const l of lastAlt) {\r\n          for (let entry of data.entries()) { // eslint-disable-line prefer-const\r\n            // a normal lookup in the dataset map would only return\r\n            // an entry preceding with '@' as a result of the _lookupSpecial\r\n            // test but because we are looping through and testing each entry\r\n            // the test on case without any diacritics will find those matches\r\n            // and we need to remove the @ flag to make sure it doesn't fail them\r\n            const originalKey = entry[0].replace(/^@/, '')\r\n            const value = entry[1]\r\n            const strippedKey = model.alternateWordEncodings({\r\n              word: originalKey,\r\n              encoding: 'strippedAll',\r\n              preserveCase: true\r\n            })\r\n            if (strippedKey.length > 0 && strippedKey[0] === l) {\r\n              found = this._lookupSpecial(data, originalKey, value)\r\n              if (found) {\r\n                break\r\n              }\r\n            }\r\n          }\r\n          if (found) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return found\r\n  }\r\n\r\n  /**\r\n   * When we created the lexicon indices we normalized the lemmas\r\n   * as all lower case and applied some additional character normalizations\r\n   * in the case of homonyms however, sometimes the normalization meant 1\r\n   * index entry for two distinct words. In these cases, we created a \"special\"\r\n   * syntax, whereby we set the value of the normalized index entry to '@'\r\n   * which mean to look for the word under it's pre-normalized entry,\r\n   * which was kept and made available in an entry prefixed with '@'\r\n   * @param {Map} data the dataset to search in\r\n   * @param {lookup} lookup the original pre-normalized lemma\r\n   * @param {lemmas} the value returned by the lookup on the normalized lemma\r\n   **/\r\n  _lookupSpecial (data, lookup, lemmas) {\r\n    if (lemmas.length === 1 && lemmas[0].field1 === '@') {\r\n      return data.get(`@${lookup}`)\r\n    } else {\r\n      return lemmas\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosLexiconsAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/logeion/config.json'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nimport { LanguageModelFactory as LMF, Constants } from 'alpheios-data-models'\r\n\r\nclass AlpheiosLogeionAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.limit = parseInt(this.config.limit)\r\n    this.available = this.config.availableLangs.includes(this.config.lang)\r\n    this.sourceData = config.sourceData\r\n    this.fetchOptions = config.fetchOptions\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of words for lookup autocomplete\r\n  * @param {String} text - text for retrieving variants\r\n  * @return {Array} - array of words\r\n  */\r\n  async getWords (text) {\r\n    try {\r\n      const url = this.createFetchURL(text)\r\n      if (!url) {\r\n        this.addError(this.l10n.getMsg('LOGEION_FETCH_OPTIONS_ERROR'))\r\n        return\r\n      }\r\n\r\n      if (this.sourceData) {\r\n        return this.sourceData\r\n      } else {\r\n        const wordsVariants = await this.fetch(url)\r\n\r\n        if (wordsVariants.words && Array.isArray(wordsVariants.words)) {\r\n          return this.filterAndLimitWords(wordsVariants.words)\r\n        } else {\r\n          return []\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('LOGEION_FETCH_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method constructs full url for getting words\r\n  * @param {String} text - text for retrieving variants\r\n  * @return {String}\r\n  */\r\n  createFetchURL (text) {\r\n    if (this.fetchOptions) {\r\n      return `${this.fetchOptions.baseurl}?key=${this.fetchOptions.apikey}&q=${text}&lang=${this.logeionLangCode}`\r\n    }\r\n  }\r\n\r\n  get logeionLangCode () {\r\n    if (this.config.lang === Constants.STR_LANG_CODE_GRC) {\r\n      return 'greek'\r\n    } else if ([Constants.STR_LANG_CODE_LAT, Constants.STR_LANG_CODE_LA].includes(this.config.lang)) {\r\n      return 'latin'\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method removes words from the other language - checks two variants - greek and the other\r\n  * @param {[Array]} words - list of words that should be checked and filtered\r\n  * @return {Array}\r\n  */\r\n  filterAndLimitWords (words) {\r\n    const finalWords = []\r\n    const model = LMF.getLanguageModelFromCode(this.config.lang)\r\n    const otherModels = []\r\n    this.config.availableLangs.forEach(lang => {\r\n      const modelLang = LMF.getLanguageModelFromCode(lang)\r\n      if (lang !== this.config.lang && modelLang.isValidUnicode) {\r\n        otherModels.push(modelLang)\r\n      }\r\n    })\r\n\r\n    for (let i = 0; i < words.length; i++) {\r\n      if ((model.isValidUnicode && model.isValidUnicode(words[i])) ||\r\n          (!model.isValidUnicode && otherModels.every(modelLang => !modelLang.isValidUnicode(words[i])))) {\r\n        finalWords.push(words[i])\r\n      }\r\n\r\n      if (finalWords.length === this.limit) {\r\n        break\r\n      }\r\n    }\r\n    return finalWords\r\n  }\r\n}\r\n\r\nexport default AlpheiosLogeionAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/translations/config.json'\r\n\r\nimport { ResourceProvider, Translation, LanguageModelFactory as LMF } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nclass AlpheiosLemmaTranslationsAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data, creates provider and inits mapLangUri (Object for storing data for available languages)\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.mapLangUri = {}\r\n    this.provider = new ResourceProvider(this.config.url, this.config.rights)\r\n    this.sourceData = config.sourceData\r\n  }\r\n\r\n  /**\r\n   * This method updates homonym with retrieved translations, if an error occurs it will be added to errors property of an adapter\r\n   * @param {Homonym} homonym\r\n   * @param {String} browserLang - language of the translation (for example its, spa)\r\n  */\r\n  async getTranslationsList (homonym, browserLang) {\r\n    let lemmaList = [] // eslint-disable-line prefer-const\r\n    if (!homonym || !homonym.lexemes) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_INCORRECT_LEXEMES'))\r\n      return\r\n    }\r\n\r\n    for (const lexeme of homonym.lexemes) {\r\n      lemmaList.push(lexeme.lemma)\r\n    }\r\n\r\n    const inLang = LMF.getLanguageCodeFromId(homonym.lexemes[0].lemma.languageID)\r\n    const outLang = this.config.langMap[browserLang] || this.config.defaultLang\r\n\r\n    const input = this.prepareInput(lemmaList)\r\n\r\n    if (!input) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_INPUT_PREPARE_ERROR', { input: input.toString() }))\r\n      return\r\n    }\r\n\r\n    try {\r\n      const urlLang = await this.getAvailableResLang(inLang, outLang)\r\n      if (urlLang && urlLang.constructor.name === 'AdapterError') {\r\n        return\r\n      }\r\n\r\n      if (input && urlLang) {\r\n        try {\r\n          const url = urlLang + '?input=' + input\r\n          let translationsList\r\n          if (this.sourceData && this.sourceData.translations) {\r\n            translationsList = this.sourceData.translations\r\n          } else {\r\n            translationsList = await this.fetch(url)\r\n          }\r\n          if (translationsList && translationsList.constructor.name === 'AdapterError') {\r\n            return\r\n          }\r\n\r\n          for (const lemma of lemmaList) {\r\n            Translation.loadTranslations(lemma, outLang, translationsList, this.provider)\r\n          }\r\n        } catch (error) {\r\n          this.addError(this.l10n.getMsg('TRANSLATION_UNKNOWN_ERROR', { message: error.message }))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method creates a string with unique lemma's words form lemmas list\r\n   * @param {[Lemma]} lemmaList\r\n  */\r\n  prepareInput (lemmaList) {\r\n    const inputList = lemmaList.map(lemma => encodeURIComponent(lemma.word)).filter((item, index, self) => self.indexOf(item) === index)\r\n    return inputList.length > 0 ? inputList.join(',') : undefined\r\n  }\r\n\r\n  /**\r\n   * This method fetches an url for translation\r\n   * @param {String} inLang  - translate from language  (for example, lat)\r\n   * @param {String} outLang  - translate to language  (for example, es, it)\r\n  */\r\n  async getAvailableResLang (inLang, outLang) {\r\n    if (this.mapLangUri[inLang] === undefined) {\r\n      const urlAvaLangsRes = this.config.url + '/' + inLang + '/'\r\n\r\n      let unparsed\r\n\r\n      if (!this.sourceData || !this.sourceData.langs) {\r\n        unparsed = await this.fetch(urlAvaLangsRes)\r\n      } else {\r\n        unparsed = this.sourceData.langs\r\n      }\r\n\r\n      if (unparsed && unparsed.constructor.name === 'AdapterError') {\r\n        return unparsed\r\n      }\r\n\r\n      let mapLangUri = {} // eslint-disable-line prefer-const\r\n      unparsed.forEach(function (langItem) {\r\n        mapLangUri[langItem.lang] = langItem.uri\r\n      })\r\n\r\n      if (Object.keys(mapLangUri).length > 0) {\r\n        this.mapLangUri[inLang] = mapLangUri\r\n      }\r\n    }\r\n\r\n    return this.mapLangUri[inLang] ? this.mapLangUri[inLang][outLang] : undefined\r\n  }\r\n}\r\n\r\nexport default AlpheiosLemmaTranslationsAdapter\r\n","import { LanguageModelFactory as LMF, Lexeme, Feature, Constants } from 'alpheios-data-models'\r\n\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport AlpheiosLexiconTransformer from '@clAdapters/transformers/alpheios-lexicon-transformer'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/tufts/config.json'\r\nimport EnginesSet from '@clAdapters/adapters/tufts/engines-set'\r\n\r\nclass AlpheiosTuftsAdapter extends BaseAdapter {\r\n  /**\r\n   * Tufts adapter uploads config data, uploads available engines and creates EnginesSet from them\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.uploadEngines(this.config.engine)\r\n    this.engineSet = new EnginesSet(this.engines)\r\n    this.sourceData = config.sourceData\r\n  }\r\n\r\n  /**\r\n   * This method creates engines object with the following format:\r\n   * LanguageID: array of available engines from config files, for example Symbol(Latin): [\"whitakerLat\"]\r\n   * @param {Object} engineConfig - engines config data\r\n  */\r\n  uploadEngines (engineConfig) {\r\n    if (this.engine === undefined) {\r\n      this.engines = {}\r\n    }\r\n    Object.keys(engineConfig).forEach(langCode => {\r\n      const langID = LMF.getLanguageIdFromCode(langCode)\r\n\r\n      if (langID !== Constants.LANG_UNDEFINED && this.engines[langID] === undefined) {\r\n        this.engines[langID] = engineConfig[langCode]\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - a word for getting homonym\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, word) {\r\n    let res\r\n    try {\r\n      if (this.sourceData) {\r\n        res = this.sourceData\r\n      } else {\r\n        const url = this.prepareRequestUrl(languageID, word)\r\n        if (!url) {\r\n          this.addError(this.l10n.getMsg('MORPH_TUFTS_NO_ENGINE_FOR_LANGUAGE', { languageID: languageID.toString() }))\r\n          return\r\n        }\r\n        res = await this.fetch(url)\r\n        if (res.constructor.name === 'AdapterError') {\r\n          return\r\n        }\r\n      }\r\n\r\n      if (res) {\r\n        const mappingData = this.engineSet.getEngineByCode(languageID)\r\n        if (!mappingData) {\r\n          this.addError(this.l10n.getMsg('MORPH_TRANSFORM_NO_MAPPING_DATA', { language: languageID.toString() }))\r\n          return\r\n        }\r\n        const transformAdapter = new AlpheiosLexiconTransformer(this, mappingData, this)\r\n        let homonym = transformAdapter.transformData(res, word) // eslint-disable-line prefer-const\r\n\r\n        if (!homonym) {\r\n          this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: word, languageID: languageID.toString() }))\r\n          return\r\n        }\r\n\r\n        if (homonym && homonym.lexemes) {\r\n          homonym.lexemes.sort(Lexeme.getSortByTwoLemmaFeatures(Feature.types.frequency, Feature.types.part))\r\n        }\r\n\r\n        return homonym\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method creates url with url from config and chosen engine\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - a word for getting homonym\r\n   * Returned url:\r\n   *     - {String} - constructed url for getting data from Tufts if engine is correct\r\n   *     - {null} - if engine is not correct\r\n  */\r\n  prepareRequestUrl (languageID, word) {\r\n    const langCode = LMF.getLanguageCodeFromId(languageID)\r\n    const engine = this.engineSet.getEngineByCode(languageID)\r\n\r\n    if (engine) {\r\n      const code = engine.engine\r\n      return this.config.url.replace('r_WORD', encodeURIComponent(word)).replace('r_ENGINE', code).replace('r_LANG', langCode).replace('r_CLIENT', this.config.clientId)\r\n    } else {\r\n      return null\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosTuftsAdapter\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.ArabicLanguageModel, 'aramorph')\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nlet data = new ImportData(Models.PersianLanguageModel, 'hazm') // eslint-disable-line prefer-const\r\n\r\n// hazm allow all lemmas in without respect features as all we use it for is lemmatizing\r\ndata.setLexemeFilter(function (lexeme) { return Boolean(lexeme.lemma.word) })\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nlet data = new ImportData(Models.GreekLanguageModel, 'morpheusgrc') // eslint-disable-line prefer-const\r\n\r\n// Morpheus uses 'irregular' as pofs for some pronouns, override with lemma\r\n// the dictionary entry's conjugation if it's available\r\ndata.inflectionOverrides = {\r\n  [Models.Feature.types.part]: (i, ls) => i[Models.Feature.types.part].value === Models.Constants.TYPE_IRREGULAR && ls.filter(l => l.features[Models.Feature.types.part].value === Models.Constants.POFS_PRONOUN)\r\n}\r\n/*\r\nBelow are value conversion maps for each grammatical feature to be parsed.\r\nFormat:\r\ndata.addFeature(typeName).add(providerValueName, LibValueName);\r\n(functions are chainable)\r\nTypes and values that are unknown (undefined) will be skipped during parsing.\r\n */\r\n\r\ndata.addFeature(Models.Feature.types.gender).importer\r\n  .map('masculine feminine', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2]])\r\n\r\ndata.addFeature(Models.Feature.types.declension).importer\r\n  .map('1st & 2nd', [[Models.Constants.ORD_1ST, 1], [Models.Constants.ORD_2ND, 2]])\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'decl') {\r\n    propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n  } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n    propertyValues = []\r\n  } else if (propertyName === 'pofs' && propertyValue === 'irregular' &&\r\n    inputElem.hdwd && inputElem.hdwd.$ === '') {\r\n    propertyValues = [Models.Constants.POFS_PRONOUN]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.SyriacLanguageModel, 'sedra')\r\n\r\n// allow lexemes  if they have at least a meaning or a part of speech\r\ndata.setLexemeFilter(function (lexeme) {\r\n  return Boolean(lexeme.meaning.shortDefs.length > 0 ||\r\n    lexeme.lemma.features[Models.Feature.types.part])\r\n})\r\n\r\n//\r\ndata.setMeaningParser(function (meaning, targetWord) {\r\n  const lang = meaning.lang ? meaning.lang : Models.Constants.STR_LANG_CODE_ENG\r\n  const meaningText = meaning.$ || ''\r\n  return new Models.Definition(meaningText, lang, 'text/html', targetWord)\r\n})\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'paradigm') {\r\n    // state has some extra \"\" around values\r\n    propertyValues = [propertyValue.replace(/\"/g, '')]\r\n  } else if (propertyName === 'src') {\r\n    // replace the '[from sedra.bethmardutho.org, accessed on XXXXX]' as duplicative\r\n    // with rights\r\n    propertyValues = [propertyValue.replace(/\\[from sedra.bethmardutho.org, .*?\\]/g, '')]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.GeezLanguageModel, 'traces')\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.LatinLanguageModel, 'whitakerLat')\r\n\r\n// Whitaker's has weird inflection data for conjugation, we prefer\r\n// the dictionary entry's conjugation if it's available\r\ndata.inflectionOverrides = { [Models.Feature.types.conjugation]: (i, ls) => true }\r\n\r\n/*\r\nBelow are value conversion maps for each grammatical feature to be parsed.\r\nFormat:\r\ndata.addFeature(typeName).add(providerValueName, LibValueName);\r\n(functions are chainable)\r\nTypes and values that are unknown (undefined) will be skipped during parsing.\r\n */\r\n\r\n// TODO  - per inflections.xsd\r\n// Whitakers Words uses packon and tackon in POFS, not sure how\r\n\r\ndata.addFeature(Models.Feature.types.gender).importer\r\n  .map('common', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2]])\r\n  .map('all', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2], [Models.Constants.GEND_NEUTER, 3]])\r\n\r\ndata.addFeature(Models.Feature.types.tense).importer\r\n  .map('future_perfect', Models.Constants.TENSE_FUTURE_PERFECT)\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'decl') {\r\n    propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n  } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n    propertyValues = []\r\n  } else if (propertyName === 'conj' && propertyValue.match(/5th|6th|7th|8th/)) {\r\n    // these are irregular verbs\r\n    propertyValues = [Models.Constants.TYPE_IRREGULAR]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\ndata.setLexemeAggregator(function (lexemeSet, inflections) {\r\n  let lexemes = [] // eslint-disable-line prefer-const\r\n  for (let lex of lexemeSet) { // eslint-disable-line prefer-const\r\n    if (this.reportLexeme(lex)) {\r\n      if (lex.meaning.shortDefs.length === 0 && lexemeSet.length > 1) {\r\n        for (let otherLex of lexemeSet) { // eslint-disable-line prefer-const\r\n          // same headword and same part of speech\r\n          if (otherLex.meaning.shortDefs.length > 0 && otherLex.lemma.isFullHomonym(lex.lemma)) {\r\n            let featuresMatch = true\r\n            for (const feature of Object.entries(lex.lemma.features)) {\r\n              // check the other features excluding frequency, source and age\r\n              if ((feature[0] !== Models.Feature.types.frequency) &&\r\n                   (feature[0] !== Models.Feature.types.source) &&\r\n                   (feature[0] !== Models.Feature.types.age) &&\r\n                   !(feature[1].isEqual(otherLex.lemma.features[feature[0]]))) {\r\n                featuresMatch = false\r\n                break\r\n              }\r\n            }\r\n            // same lemma, same features, must be principal parts mismatch\r\n            if (featuresMatch) {\r\n              // if this lemma has a higher frequency, make it the main lemma of the Lexeme and the existing one an alternative\r\n              if (lex.lemma.features[Models.Feature.types.frequency].compareTo(otherLex.lemma.features[Models.Feature.types.frequency]) < 1) {\r\n                otherLex.addAltLemma(otherLex.lemma)\r\n                otherLex.lemma = lex.lemma\r\n              } else {\r\n                // otherwise just add it to the alternative lemmas\r\n                otherLex.addAltLemma(lex.lemma)\r\n              }\r\n            } else {\r\n              lex.inflections = inflections.map(inflection => inflection.clone())\r\n              lexemes.push(lex)\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        lex.inflections = inflections.map(inflection => inflection.clone())\r\n        lexemes.push(lex)\r\n      }\r\n    }\r\n  }\r\n  return lexemes\r\n}\r\n)\r\n\r\ndata.setLemmaParser(function (lemma) {\r\n  // Whitaker's Words returns principal parts for some words\r\n  // and sometimes has a space separted stem and suffix\r\n  let parsed, primary\r\n  let parts = [] // eslint-disable-line prefer-const\r\n  const lemmas = lemma.split(', ')\r\n  for (const [index, l] of lemmas.entries()) {\r\n    const normalized = l.split(' ')[0]\r\n    if (index === 0) {\r\n      primary = normalized\r\n    }\r\n    parts.push(normalized)\r\n  }\r\n  if (primary) {\r\n    parsed = new Models.Lemma(primary, this.model.languageCode, parts)\r\n  }\r\n\r\n  return parsed\r\n})\r\n\r\nexport default data\r\n","import Whitakers from '@clAdapters/adapters/tufts/engine/whitakers'\r\nimport Morpheusgrc from '@clAdapters/adapters/tufts/engine/morpheusgrc'\r\nimport Aramorph from '@clAdapters/adapters/tufts/engine/aramorph'\r\nimport Hazm from '@clAdapters/adapters/tufts/engine/hazm'\r\nimport Traces from '@clAdapters/adapters/tufts/engine/traces'\r\nimport Sedra from '@clAdapters/adapters/tufts/engine/sedra'\r\n\r\nimport { LanguageModelFactory as LMF } from 'alpheios-data-models'\r\n\r\nclass EnginesSet {\r\n  /**\r\n   * @param {Object} adapterConfigEngines - it is the following format - Symbol(Latin): [\"whitakerLat\"]\r\n  */\r\n  constructor (adapterConfigEngines) {\r\n    this.engine = adapterConfigEngines\r\n  }\r\n\r\n  /**\r\n   * This method returns engine class by languageID\r\n   * @param {Symbol} languageID\r\n   * @return {Engine Class}\r\n  */\r\n  getEngineByCode (languageID) {\r\n    if (this.engine[languageID]) {\r\n      const engineCode = this.engine[languageID][0]\r\n      const allEngines = new Map(([Whitakers, Morpheusgrc, Aramorph, Hazm, Traces, Sedra]).map((e) => { return [e.engine, e] }))\r\n      return allEngines.get(engineCode)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method returns engine class by languageCode\r\n   * @param {String} languageCode\r\n   * @return {Engine Class}\r\n  */\r\n  getEngineByCodeFromLangCode (languageCode) {\r\n    const languageID = LMF.getLanguageIdFromCode(languageCode)\r\n    return this.getEngineByCode(languageID)\r\n  }\r\n}\r\n\r\nexport default EnginesSet\r\n","import AlpheiosTuftsAdapter from '@clAdapters/adapters/tufts/adapter'\r\nimport AlpheiosChineseLocAdapter from '@clAdapters/adapters/chineseloc/adapter'\r\nimport AlpheiosTreebankAdapter from '@clAdapters/adapters/alpheiostb/adapter'\r\nimport AlpheiosLemmaTranslationsAdapter from '@clAdapters/adapters/translations/adapter'\r\nimport AlpheiosLexiconsAdapter from '@clAdapters/adapters/lexicons/adapter'\r\nimport AlpheiosConcordanceAdapter from '@clAdapters/adapters/concordance/adapter'\r\nimport ArethusaTreebankAdapter from '@clAdapters/adapters/arethusa/adapter'\r\nimport AlpheiosLogeionAdapter from '@clAdapters/adapters/logeion/adapter'\r\n\r\nimport WrongMethodError from '@clAdapters/errors/wrong-method-error'\r\nimport NoRequiredParamError from '@clAdapters/errors/no-required-param-error'\r\n\r\nimport AdaptersConfig from '@clAdapters/adapters/adapters-config.json'\r\n\r\nlet cachedConfig = new Map() // eslint-disable-line prefer-const\r\nlet cachedAdaptersList = new Map() // eslint-disable-line prefer-const\r\n\r\nclass ClientAdapters {\r\n  /**\r\n   * it is used for uploading data from AdaptersConfig to cachedConfig and CachedAdaptersList\r\n  */\r\n  static init () {\r\n    if (cachedConfig.size === 0) {\r\n      for (const category in AdaptersConfig) {\r\n        let adapters = {} // eslint-disable-line prefer-const\r\n        for (const adapterKey in AdaptersConfig[category]) {\r\n          const adapterData = AdaptersConfig[category][adapterKey]\r\n\r\n          adapters[adapterKey] = {\r\n            adapter: ClientAdapters[adapterData.adapter],\r\n            methods: adapterData.methods,\r\n            params: adapterData.params\r\n          }\r\n        }\r\n        cachedConfig.set(category, adapters)\r\n      }\r\n\r\n      for (const key of cachedConfig.keys()) {\r\n        const res = {}\r\n        Object.keys(cachedConfig.get(key)).forEach(typeAdapter => {\r\n          res[typeAdapter] = cachedConfig.get(key)[typeAdapter].adapter\r\n        })\r\n\r\n        cachedAdaptersList.set(key, res)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  *  Additional abstraction layer for structuring adapters\r\n  *  it is used for retrieving data from morphology category\r\n  */\r\n  static get morphology () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('morphology')\r\n  }\r\n\r\n  /**\r\n  * it is used for retrieving data from lexicon category\r\n  */\r\n  static get lexicon () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('lexicon')\r\n  }\r\n\r\n  /**\r\n  * it is used for retrieving data from lemmatranslation category\r\n  */\r\n  static get lemmatranslation () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('lemmatranslation')\r\n  }\r\n\r\n  static get wordusageExamples () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('wordusageExamples')\r\n  }\r\n\r\n  static get autocompleteWords () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('autocompleteWords')\r\n  }\r\n\r\n  /**\r\n  * This method checks if given method is registered in config for category.adapterName\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {String} methodName - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkMethod (category, adapterName, methodName) {\r\n    if (!cachedConfig.get(category)[adapterName].methods.includes(methodName)) {\r\n      throw new WrongMethodError(category, adapterName, methodName)\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if given array with parameteres doesn't have required parameters, registered in config file\r\n  * @param {[String]} params - array of parameter's names for being checked\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {String} methodName - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkParam (params, category, adapterName, methodName) {\r\n    if (cachedConfig.get(category)[adapterName].params) {\r\n      cachedConfig.get(category)[adapterName].params[methodName].forEach(paramName => {\r\n        // Param values other than `undefined` such as `null` or empty strings could be valid values\r\n        if (typeof params[paramName] === 'undefined') {\r\n          throw new NoRequiredParamError(category, adapterName, methodName, paramName)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This method executes both checks for given options - checks method and given parameters from options\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {Object} options - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkMethodParam (category, adapterName, options) {\r\n    ClientAdapters.checkMethod(category, adapterName, options.method)\r\n    ClientAdapters.checkParam(options.params, category, adapterName, options.method)\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from morph adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {String} options.params.word - target word for what we will receive morph data\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n  */\r\n  static async maAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'tufts', options)\r\n\r\n    const localMaAdapter = new AlpheiosTuftsAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'tufts',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      sourceData: options.sourceData\r\n    })\r\n\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localMaAdapter.getHomonym(options.params.languageID, options.params.word)\r\n      return { result: homonym, errors: localMaAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async chineseAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'chineseloc', options)\r\n\r\n    const localChineseAdapter = new AlpheiosChineseLocAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'chineseloc',\r\n      method: options.method,\r\n      // A URL of a CEDICT service\r\n      serviceUrl: options.serviceUrl\r\n    })\r\n\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localChineseAdapter.getHomonym(options.params.word, options.params.checkContextForward)\r\n      return { result: homonym, errors: localChineseAdapter.errors }\r\n    }\r\n    if (options.method === 'loadData') {\r\n      const result = await localChineseAdapter.loadData(options.params.timeout)\r\n      return { result, errors: localChineseAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from treebank adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {String} options.params.wordref - target wordref for getting data from treebank adapter\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n*/\r\n\r\n  static async tbAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'alpheiosTreebank', options)\r\n\r\n    const localTbAdapter = new AlpheiosTreebankAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'alpheiosTreebank',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localTbAdapter.getHomonym(options.params.languageID, options.params.wordref)\r\n      return { result: homonym, errors: localTbAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from arethusa\r\n   * @param {Object} options - object contains parameters:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {Symbol} options.params.word - target word\r\n   *    @param {String} options.params.provider - the provider url for Arethusa\r\n   *    @param {String} options.params.sentenceId - the sentence identifier\r\n   *    @param {String} options.params.wordId - the word identifier\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n*/\r\n\r\n  static async arethusaAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'arethusaTreebank', options)\r\n\r\n    const localAdapter = new ArethusaTreebankAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'arethusaTreebank',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localAdapter.getHomonym(options.params.languageID,\r\n        options.params.word,\r\n        options.params.provider,\r\n        options.params.sentenceId,\r\n        options.params.wordId)\r\n      return { result: homonym, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'refreshView') {\r\n      const resp = await localAdapter.refreshView(options.params.provider)\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'gotoSentence') {\r\n      const resp = await localAdapter.gotoSentence(\r\n        options.params.provider,\r\n        options.params.sentenceId,\r\n        options.params.wordIds\r\n      )\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'findWord') {\r\n      const resp = await localAdapter.findWord(\r\n        options.params.provider,\r\n        options.params.word,\r\n        options.params.prefix,\r\n        options.params.suffix,\r\n        options.params.sentenceId\r\n      )\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from translations adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"fetchTranslations\" - action that should be done wth the help of adapter\r\n   *    @param {Homonym} options.params.homonym - homonym for retrieving translations\r\n   *    @param {String} options.params.browserLang - language for translations\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Boolean, errors: [AdapterError] }\r\n*/\r\n  static async lemmaTranslations (options) {\r\n    ClientAdapters.checkMethodParam('lemmatranslation', 'alpheios', options)\r\n\r\n    const localLemmasAdapter = new AlpheiosLemmaTranslationsAdapter({\r\n      category: 'lemmatranslation',\r\n      adapterName: 'alpheios',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      sourceData: options.sourceData\r\n    })\r\n\r\n    if (options.method === 'fetchTranslations') {\r\n      await localLemmasAdapter.getTranslationsList(options.params.homonym, options.params.browserLang)\r\n      return { errors: localLemmasAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async wordUsageExamples (options) {\r\n    ClientAdapters.checkMethodParam('wordusageExamples', 'concordance', options)\r\n\r\n    const localLemmasAdapter = new AlpheiosConcordanceAdapter({\r\n      category: 'wordUsage',\r\n      adapterName: 'concordance',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n\r\n    if (options.method === 'getAuthorsWorks') {\r\n      const res = await localLemmasAdapter.getAuthorsWorks()\r\n      return { result: res, errors: localLemmasAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'getWordUsageExamples') {\r\n      const res = await localLemmasAdapter.getWordUsageExamples(options.params.homonym, options.params.filters, options.params.pagination, options.params.sort)\r\n      return { result: res, errors: localLemmasAdapter.errors }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from lexicons adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - action that should be done wth the help of adapter - fetchShortDefs and fetchFullDefs\r\n   *    @param {Homonym} options.params.homonym - homonym for retrieving translations\r\n   *    @param {Object(allow: [String])} options.params.opts - an object with array of urls for dictionaries\r\n   *    @param {PSEvent} options.params.callBackEvtSuccess - an event that should be published on success result\r\n   *    @param {PSEvent} options.params.callBackEvtFailed - an event that should be published on failed result\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Boolean, errors: [AdapterError] }\r\n*/\r\n  static async lexicons (options) {\r\n    ClientAdapters.checkMethodParam('lexicon', 'alpheios', options)\r\n\r\n    const adapterParams = {\r\n      category: 'lexicon',\r\n      adapterName: 'alpheios',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      timeout: options.params && options.params.timeout ? options.params.timeout : 3000,\r\n      callBackEvtSuccess: options.params ? options.params.callBackEvtSuccess : null,\r\n      callBackEvtFailed: options.params ? options.params.callBackEvtFailed : null\r\n    }\r\n\r\n    const localLexiconsAdapter = new AlpheiosLexiconsAdapter(adapterParams)\r\n\r\n    if (options.method === 'fetchShortDefs') {\r\n      await localLexiconsAdapter.fetchShortDefs(options.params.homonym, options.params.opts)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n    if (options.method === 'fetchFullDefs') {\r\n      await localLexiconsAdapter.fetchFullDefs(options.params.homonym, options.params.opts)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'checkCachedData') {\r\n      await localLexiconsAdapter.checkCachedData(options.params.url, options.params.externalData, options.params.skipFetch)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'getConfig') {\r\n      return localLexiconsAdapter.config\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async autoCompleteWords (options) {\r\n    ClientAdapters.checkMethodParam('autocompleteWords', 'logeion', options)\r\n\r\n    const localLogeionAdapter = new AlpheiosLogeionAdapter({\r\n      category: 'autocompleteWords',\r\n      adapterName: 'logeion',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      limit: options.params.limit,\r\n      lang: options.params.lang,\r\n      sourceData: options.params.sourceData,\r\n      fetchOptions: options.params.fetchOptions\r\n    })\r\n\r\n    if (localLogeionAdapter.available && options.method === 'getWords') {\r\n      const res = await localLogeionAdapter.getWords(options.params.text)\r\n      return { result: res, errors: localLogeionAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n}\r\n\r\nexport default ClientAdapters\r\n","class AdapterError extends Error {\r\n  constructor (category, adapterName, methodName, messageError) {\r\n    super(messageError)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.methodName = methodName\r\n\r\n    if (this.adapter && this.methodName) {\r\n      this.message = `${this.message} (${this.adapter}.${this.methodName})`\r\n    }\r\n    try {\r\n      Error.captureStackTrace(this, AdapterError)\r\n    } catch (e) {\r\n      // Continue if environment does not support captureStackTrace.\r\n    }\r\n  }\r\n\r\n  update (config) {\r\n    this.adapter = `${config.category}.${config.adapterName}`\r\n    this.methodName = config.method\r\n\r\n    this.message = `${this.message} (${this.adapter}.${this.methodName})`\r\n    return this\r\n  }\r\n}\r\n\r\nexport default AdapterError\r\n","class NoRequiredParamError extends Error {\r\n  constructor (category, adapterName, methodName, paramName) {\r\n    const message = `There is no required parameter - ${paramName} for ${category}.${adapterName} - ${methodName}`\r\n    super(message)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.methodName = methodName\r\n    this.paramName = paramName\r\n    Error.captureStackTrace(this, NoRequiredParamError)\r\n  }\r\n}\r\n\r\nexport default NoRequiredParamError\r\n","export default class RemoteError extends Error {\n  constructor (category, adapterName, methodName, errorCode, errorMessage) {\n    super(errorMessage)\n    this.adapter = `${category}.${adapterName}`\n    this.methodName = methodName\n    this.errorCode = errorCode\n  }\n\n  update (config) {\n    this.adapter = `${config.category}.${config.adapterName}`\n    this.methodName = config.method\n\n    this.message = `${this.errorCode}: ${this.message} (${this.adapter}.${this.methodName})`\n    return this\n  }\n}\n","class WrongMethodError extends Error {\r\n  constructor (category, adapterName, methodName) {\r\n    const message = `Wrong method for ${category}.${adapterName} - ${methodName}`\r\n    super(message)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.method = methodName\r\n    Error.captureStackTrace(this, WrongMethodError)\r\n  }\r\n}\r\n\r\nexport default WrongMethodError\r\n","import ClientAdapters from '@clAdapters/client-adapters.js'\r\nimport RemoteError from '@clAdapters/errors/remote-error.js'\r\n\r\nexport { ClientAdapters, RemoteError }\r\n","import EnUs from './en-us/messages.json'\r\nimport EnGb from './en-gb/messages.json'\r\n\r\nexport default {\r\n  en_US: 'en-US',\r\n  en_GB: 'en-GB',\r\n  messages: {\r\n    en_US: EnUs,\r\n    en_GB: EnGb\r\n  }\r\n}\r\n","import { ResourceProvider, Lexeme, Constants, Feature, Inflection, Homonym } from 'alpheios-data-models'\r\n\r\n/**\r\n Transforms morphological output adhering to the Alpheios lexicon\r\n schema to an Alpheios Homonym data model object\r\n*/\r\n\r\nconst featuresArray = [\r\n  ['pofs', 'part'],\r\n  ['case', 'grmCase'],\r\n  ['gend', 'gender'],\r\n  ['decl', 'declension'],\r\n  ['conj', 'conjugation'],\r\n  ['area', 'area'],\r\n  ['age', 'age'],\r\n  ['geo', 'geo'],\r\n  ['freq', 'frequency'],\r\n  ['note', 'note'],\r\n  ['pron', 'pronunciation'],\r\n  ['kind', 'kind'],\r\n  ['src', 'source']\r\n]\r\n\r\nconst featuresArrayAll = [\r\n  ['pofs', 'part'],\r\n  ['case', 'grmCase'],\r\n  ['gend', 'gender'],\r\n  ['decl', 'declension'],\r\n  ['conj', 'conjugation'],\r\n  ['num', 'number'],\r\n  ['tense', 'tense'],\r\n  ['voice', 'voice'],\r\n  ['mood', 'mood'],\r\n  ['pers', 'person'],\r\n  ['comp', 'comparison'],\r\n  ['stemtype', 'stemtype'],\r\n  ['derivtype', 'derivtype'],\r\n  ['dial', 'dialect'],\r\n  ['morph', 'morph']\r\n]\r\n\r\nconst attributeBasedFeatures = [\r\n  ['paradigm', 'cat']\r\n]\r\n\r\nclass AlpheiosLexiconTransformer {\r\n  constructor (adapter, mappingData) {\r\n    this.adapter = adapter\r\n    this.mappingData = mappingData\r\n    this.allowUnknownValues = true\r\n  }\r\n\r\n  /**\r\n   * This method extract parameter by defined path\r\n   * @param {Object} source - json object to retrieve data from\r\n   * @param {String} nameParam - parameter name that should be retrieved\r\n   * @return {String|Object} - extracted data\r\n  */\r\n  extractData (source, nameParam) {\r\n    const schema = {\r\n      providerUri: ['RDF', 'Annotation', 'creator', 'Agent', 'about'],\r\n      providerRights: ['RDF', 'Annotation', 'rights', '$'],\r\n      inflections: ['rest', 'entry', 'infl'],\r\n      dictData: ['rest', 'entry', 'dict']\r\n    }\r\n    let res\r\n\r\n    if (schema[nameParam]) {\r\n      res = source\r\n      for (const pathPart of schema[nameParam]) {\r\n        if (res[pathPart]) {\r\n          res = res[pathPart]\r\n        } else {\r\n          res = undefined\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  }\r\n\r\n  /**\r\n   * This method checks if data is array, if not - converts to array\r\n   * @param {?} data - value that should be checked\r\n   * @param {?} defaultData - default value, if data is null\r\n   * @return {Array}\r\n  */\r\n  checkToBeArray (data, defaultData = []) {\r\n    let resData = data\r\n    if (!Array.isArray(data)) {\r\n      if (data) {\r\n        resData = [data]\r\n      } else {\r\n        resData = defaultData\r\n      }\r\n    }\r\n    return resData\r\n  }\r\n\r\n  /**\r\n   * This method creates hdwd from source json object\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * @param {Symbol} direction - define the word direction\r\n   * @return {Array} - array with parts for hdwr\r\n  */\r\n  collectHdwdArray (data, term, direction) {\r\n    let hdwd = [] // eslint-disable-line prefer-const\r\n\r\n    if (data && !Array.isArray(data) && (!data.hdwd || !data.hdwd.$) && term) {\r\n      hdwd.push(term.prefix ? term.prefix.$ : '')\r\n      hdwd.push(term.stem ? term.stem.$ : '')\r\n      hdwd.push(term.suff ? term.suff.$ : '')\r\n\r\n      if (direction === Constants.LANG_DIR_RTL) {\r\n        hdwd.reverse()\r\n      }\r\n    }\r\n\r\n    return hdwd\r\n  }\r\n\r\n  /**\r\n   * This method defines language from dictData nd inflections data\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * @return {String}  - language code\r\n  */\r\n  defineLanguage (data, term) {\r\n    let lemmaData = Array.isArray(data) ? data[0] : data // eslint-disable-line prefer-const\r\n    if (!lemmaData.hdwd && term) {\r\n      lemmaData.hdwd = {}\r\n      lemmaData.hdwd.lang = term.lang\r\n    }\r\n    return lemmaData.hdwd ? lemmaData.hdwd.lang : lemmaData.lang\r\n  }\r\n\r\n  /**\r\n   * This method defines language from dictData nd inflections data\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * Returned values:\r\n   *     - {Homonym}\r\n   *     - {undefined}\r\n  */\r\n  transformData (jsonObj, targetWord) {\r\n    let lexemes = [] // eslint-disable-line prefer-const\r\n    const annotationBody = this.checkToBeArray(jsonObj.RDF.Annotation.Body)\r\n\r\n    const providerUri = this.extractData(jsonObj, 'providerUri')\r\n    const providerRights = this.extractData(jsonObj, 'providerRights')\r\n\r\n    const provider = new ResourceProvider(providerUri, providerRights)\r\n\r\n    for (const lexeme of annotationBody) {\r\n      const inflectionsJSON = this.checkToBeArray(this.extractData(lexeme, 'inflections'))\r\n      const inflectionsJSONTerm = inflectionsJSON.length > 0 ? inflectionsJSON[0].term : undefined\r\n\r\n      const dictData = this.extractData(lexeme, 'dictData')\r\n\r\n      const lemmaElements = this.checkToBeArray(dictData, inflectionsJSONTerm ? [inflectionsJSONTerm] : [])\r\n      const language = this.defineLanguage(lemmaElements, inflectionsJSONTerm)\r\n      if (!language) {\r\n        this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_NO_LANGUAGE'))\r\n        continue\r\n      }\r\n\r\n      const reconstructHdwd = this.collectHdwdArray(dictData, inflectionsJSONTerm, this.mappingData.model.direction)\r\n      if (reconstructHdwd.length > 0) {\r\n        lemmaElements[0].hdwd.$ = reconstructHdwd.join('')\r\n      }\r\n\r\n      let lemmas = [] // eslint-disable-line prefer-const\r\n      let lexemeSet = [] // eslint-disable-line prefer-const\r\n\r\n      for (const entry of lemmaElements.entries()) {\r\n        const index = entry[0]\r\n        const elem = entry[1]\r\n\r\n        // if the parser has a number in the hdwd the JSON will have it as a number\r\n        // and not a String\r\n        const lemmaText = elem.hdwd && elem.hdwd.$ ? `${elem.hdwd.$}` : ''\r\n        if (!lemmaText) {\r\n          this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_NO_LEMMA'))\r\n          continue\r\n        }\r\n        const lemma = this.mappingData.parseLemma(lemmaText, language)\r\n        lemmas.push(lemma)\r\n\r\n        const features = featuresArray\r\n        for (const feature of features) {\r\n          this.mappingData.mapFeature(lemma, elem, ...feature, this.allowUnknownValues)\r\n        }\r\n\r\n        let shortdefs = [] // eslint-disable-line prefer-const\r\n        let meanings = lexeme.rest.entry.mean\r\n        if (!Array.isArray(meanings)) {\r\n          meanings = [meanings]\r\n        }\r\n        meanings = meanings.filter((m) => m)\r\n\r\n        // if we have multiple dictionary elements, take the meaning with the matching index\r\n        if (lemmaElements.length > 1) {\r\n          if (meanings && meanings[index] && meanings[index].$) {\r\n            const meaning = meanings[index]\r\n            shortdefs.push(ResourceProvider.getProxy(provider,\r\n              this.mappingData.parseMeaning(meaning, lemmas[index].word)))\r\n          }\r\n        } else {\r\n          // Changed to prevent some weird \"Array Iterator.prototype.next called on incompatible receiver [object Unknown]\" error\r\n          const sDefs = meanings.filter((m) => m.$).map(meaning => {\r\n            return ResourceProvider.getProxy(provider,\r\n              this.mappingData.parseMeaning(meaning, lemma.word))\r\n          })\r\n          shortdefs.push(...sDefs)\r\n        }\r\n        let lexmodel = new Lexeme(lemma, []) // eslint-disable-line prefer-const\r\n\r\n        lexmodel.meaning.appendShortDefs(shortdefs)\r\n        lexemeSet.push(ResourceProvider.getProxy(provider, lexmodel))\r\n      }\r\n\r\n      if (lemmas.length === 0) {\r\n        continue\r\n      }\r\n\r\n      const inflections = []\r\n      for (const inflectionJSON of inflectionsJSON) {\r\n        const stem = inflectionJSON.term && inflectionJSON.term.stem ? inflectionJSON.term.stem.$ : null\r\n        const form = inflectionJSON.term && inflectionJSON.term.form ? inflectionJSON.term.form.$ : null\r\n        const suffix = inflectionJSON.term && inflectionJSON.term.suff ? inflectionJSON.term.suff.$ : null\r\n        const prefix = inflectionJSON.term && inflectionJSON.term.pref ? inflectionJSON.term.pref.$ : null\r\n        const xmpl = inflectionJSON.xmpl ? inflectionJSON.xmpl.$ : null\r\n        const inflWord = stem || form\r\n        let inflection\r\n        try {\r\n          inflection = new Inflection(inflWord, this.mappingData.model.languageID, suffix, prefix, xmpl)\r\n        } catch (e) {\r\n          this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_INFLECTION_ERROR', { error: e.message }))\r\n          continue\r\n        }\r\n        if (targetWord) {\r\n          inflection.addFeature(new Feature(Feature.types.fullForm, targetWord, this.mappingData.model.languageID))\r\n        }\r\n        // Parse whatever grammatical features we're interested in and are provided\r\n        for (const f of featuresArrayAll) {\r\n          try {\r\n            this.mappingData.mapFeature(inflection, inflectionJSON, ...f, this.allowUnknownValues)\r\n            this.mappingData.overrideInflectionFeatureIfRequired(Feature.types[f[1]], inflection, lemmas)\r\n          } catch (e) {\r\n            // quietly continue\r\n          }\r\n        }\r\n\r\n        // Parse attribute based features\r\n        for (const f of attributeBasedFeatures) {\r\n          try {\r\n            this.mappingData.mapFeatureByAttribute(inflection, inflectionJSON, ...f, this.allowUnknownValues)\r\n            this.mappingData.overrideInflectionFeatureIfRequired(Feature.types[f[1]], inflection, lemmas)\r\n          } catch (e) {\r\n            // quietly continue\r\n          }\r\n        }\r\n\r\n        // we only use the inflection if it tells us something the dictionary details do not\r\n        if (inflection[Feature.types.grmCase] ||\r\n          inflection[Feature.types.tense] ||\r\n          inflection[Feature.types.mood] ||\r\n          inflection[Feature.types.voice] ||\r\n          inflection[Feature.types.person] ||\r\n          inflection[Feature.types.comparison] ||\r\n          inflection[Feature.types.stemtype] || /** greek - morpheus **/\r\n          inflection[Feature.types.derivtype] || /** greek - morpheus **/\r\n          inflection[Feature.types.dialect] || /** greek **/\r\n          inflection[Feature.types.morph] || /** arabic - aramorph **/\r\n          inflection[Feature.types.kaylo] || /** syriac - sedra **/\r\n          inflection[Feature.types.state] || /** syriac - sedra **/\r\n          inflection[Feature.types.example]) {\r\n          inflections.push(inflection)\r\n        }\r\n        // inflection can provide lemma decl, pofs, conj\r\n        for (const lemma of lemmas) {\r\n          if (!lemma.features[Feature.types.part]) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'pofs', 'part', this.allowUnknownValues)\r\n          }\r\n          // only take declension from inflection if lemma has no part of speech or its the same as the inflection\r\n          if (!lemma.features[Feature.types.declension] &&\r\n            (!lemma.features[Feature.types.part] || lemma.features[Feature.types.part].isEqual(inflection[Feature.types.part]))) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'decl', 'declension', this.allowUnknownValues)\r\n          }\r\n          // only take conjugation from inflection if lemma has a part of speech and its the same as the inflection\r\n          if (!lemma.features[Feature.types.conjugation] &&\r\n            (!lemma.features[Feature.types.part] || lemma.features[Feature.types.part].isEqual(inflection[Feature.types.part]))) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'conj', 'conjugation', this.allowUnknownValues)\r\n          }\r\n        }\r\n      }\r\n      const aggregated = this.mappingData.aggregateLexemes(lexemeSet, inflections)\r\n      lexemes.push(...aggregated)\r\n    }\r\n    if (lexemes.length > 0) {\r\n      return new Homonym(lexemes, targetWord)\r\n    } else {\r\n      return undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosLexiconTransformer\r\n","/*\r\nObjects of a morphology analyzer's library\r\n */\r\nimport { Feature, Lemma, FeatureImporter, Definition, Constants, Logger } from 'alpheios-data-models'\r\n\r\n/**\r\n * Holds all information required to transform from morphological analyzer's grammatical feature values to the\r\n * library standards. There is one ImportMorphData object per language.\r\n */\r\nclass ImportMorphData {\r\n  /**\r\n     * Creates an ImportMorphData object for the language provided.\r\n     * @param {Function<LanguageModel>} model - A language model of the import data.\r\n     * @param {String} engine - a code for the engine that is using this mapping model\r\n     */\r\n  constructor (model, engine) {\r\n    'use strict'\r\n    this.model = model\r\n    this.engine = engine\r\n    // add all the features that the language supports so that we\r\n    // can return the default values if we don't need to import a mapping\r\n    for (const featureName of Object.keys(this.model.features)) {\r\n      this.addFeature(featureName)\r\n    }\r\n    // may be overridden by specific engine to handle vagaries in reporting of dictionary entries\r\n    // default just returns them as provided\r\n    this.aggregateLexemes = function (lexemeSet, inflections) {\r\n      let lexemes = [] // eslint-disable-line prefer-const\r\n      for (const lex of lexemeSet) {\r\n        // only process if we have a lemma that differs from the target\r\n        // word or if we have at least a part of speech\r\n        if (this.reportLexeme(lex)) {\r\n          lex.inflections = inflections.map(inflection => inflection.clone())\r\n          lexemes.push(lex)\r\n        }\r\n      }\r\n      return lexemes\r\n    }\r\n    // may be overridden by specific engine use via setLemmaParser\r\n    this.parseLemma = function (lemma) { return new Lemma(lemma, this.model.languageID) }\r\n\r\n    // may be overridden by specific engine use via setMeaningParser\r\n    this.parseMeaning = function (meaning, targetWord) {\r\n      const lang = meaning.lang ? meaning.lang : Constants.STR_LANG_CODE_ENG\r\n      return new Definition(meaning.$, lang, 'text/plain', targetWord)\r\n    }\r\n\r\n    // may be overridden by specific engine use via setPropertyParser - default just returns the property value\r\n    // as a list\r\n    this.parseProperty = function (propertyName, propertyValue, inputElem) {\r\n      let propertyValues = []\r\n      if (propertyName === 'decl') {\r\n        propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n      } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n        propertyValues = []\r\n      } else {\r\n        propertyValues = [propertyValue]\r\n      }\r\n      return propertyValues\r\n    }\r\n\r\n    // may be overridden by specifc engine use via setLexemeFilter - default assumes we will have a part of speech\r\n    this.reportLexeme = function (lexeme) {\r\n      return lexeme.lemma.features[Feature.types.part]\r\n    }\r\n\r\n    // may be overriden by specific engine use to a list of of featureTypes which\r\n    // should be overridden in the inflection data from the lemma data\r\n    this.inflectionOverrides = []\r\n  }\r\n\r\n  /**\r\n     * Adds a grammatical feature whose values to be mapped.\r\n     * @param {string} featureName - A name of a grammatical feature (i.e. declension, number, etc.)\r\n     * @return {Object} An object that represent a newly created grammatical feature.\r\n     */\r\n  addFeature (featureName) {\r\n    this[featureName] = {}\r\n    const model = this.model\r\n\r\n    this[featureName].add = function add (providerValue, alpheiosValue) {\r\n      this[providerValue] = alpheiosValue\r\n      return this\r\n    }\r\n\r\n    this[featureName].get = function get (providerValue, sortOrder = 1, allowUnknownValues = false) {\r\n      let mappedValue = []\r\n      if (!this.importer.has(providerValue)) {\r\n        // if the providerValue matches the model value or the model value\r\n        // is unrestricted, return a feature with the providerValue and order\r\n        if (model.typeFeature(featureName).hasValue(providerValue) ||\r\n            model.typeFeature(featureName).valuesUnrestricted) {\r\n          mappedValue = model.typeFeature(featureName).createFeature(providerValue, sortOrder)\r\n        } else {\r\n          const message = `Unknown value \"${providerValue}\" of feature \"${featureName}\" for ${model.languageCode} (allowed = ${allowUnknownValues})`\r\n          if (allowUnknownValues) {\r\n            mappedValue = model.typeFeature(featureName).createFeature(providerValue, sortOrder)\r\n          } else {\r\n            throw new Error(message)\r\n          }\r\n        }\r\n      } else {\r\n        const tempValue = this.importer.get(providerValue)\r\n        if (Array.isArray(tempValue)) {\r\n          mappedValue = model.typeFeature(featureName).createFeatures(tempValue, sortOrder)\r\n        } else {\r\n          mappedValue = model.typeFeature(featureName).createFeature(tempValue, sortOrder)\r\n        }\r\n      }\r\n      return mappedValue\r\n    }\r\n\r\n    /**\r\n     * @param {Object[]} data - An array of objects with `providerData` (an item value) and `sortOrder` fields\r\n     * @param allowUnknownValues\r\n     * @return {Feature}\r\n     */\r\n    this[featureName].getMultiple = function get (data, allowUnknownValues = false) {\r\n      let values = [] // Converts values from `data` into `values` array\r\n      for (const item of data) {\r\n        if (this.importer.has(item.providerValue)) {\r\n          const value = this.importer.get(item.providerValue)\r\n          if (Array.isArray(value)) {\r\n            // if the import returns an array, it should already have the sortOrder\r\n            values = value\r\n          } else {\r\n            values = [[value, item.sortOrder]]\r\n          }\r\n        } else if (model.typeFeature(featureName).hasValue(item.providerValue) ||\r\n          model.typeFeature(featureName).valuesUnrestricted) {\r\n          values.push([item.providerValue, item.sortOrder])\r\n        } else {\r\n          const message = `Unknown value \"${item.providerValue}\" of feature \"${featureName}\" for ${model.languageCode} (allowed = ${allowUnknownValues})`\r\n          if (allowUnknownValues) {\r\n            values.push([item.providerValue, item.sortOrder])\r\n          } else {\r\n            throw new Error(message)\r\n          }\r\n        }\r\n      }\r\n      return model.typeFeature(featureName).createFeatures(values)\r\n    }\r\n\r\n    this[featureName].importer = new FeatureImporter()\r\n\r\n    return this[featureName]\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific lexeme aggregator\r\n   */\r\n  setLexemeAggregator (callback) {\r\n    this.aggregateLexemes = callback\r\n  }\r\n\r\n  /**\r\n  /**\r\n   * Add an engine-specific lemma parser\r\n   */\r\n  setLemmaParser (callback) {\r\n    this.parseLemma = callback\r\n  }\r\n\r\n  setMeaningParser (callback) {\r\n    this.parseMeaning = callback\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific property parser\r\n   */\r\n  setPropertyParser (callback) {\r\n    this.parseProperty = callback\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific lexeme filter\r\n   */\r\n  setLexemeFilter (callback) {\r\n    this.reportLexeme = callback\r\n  }\r\n\r\n  /**\r\n   * Maps property of a single feature type to a single Feature object with one or more values\r\n   * (if this feature has multiple values). Feature is stored as a property of the supplied model object.\r\n   * @param {object} model the model object to which the feature will be added\r\n   * @param {object} inputElem the input data element\r\n   * @param {object} inputName the  property name in the input data\r\n   * @param {string} featureName the name of the feature it will be mapped to\r\n   * @param {boolean} allowUnknownValues flag to indicate if unknown values are allowed\r\n   */\r\n  mapFeature (model, inputElem, inputName, featureName, allowUnknownValues) {\r\n    const inputItem = inputElem[inputName]\r\n    if (inputItem && (Array.isArray(inputItem) || inputItem.$)) {\r\n      let values = []\r\n      if (Array.isArray(inputItem)) {\r\n        // There are multiple values of this feature\r\n        for (const e of inputItem) {\r\n          values.push(...this.parseProperty(inputName, e.$, inputElem))\r\n        }\r\n      } else {\r\n        values = this.parseProperty(inputName, inputItem.$, inputElem)\r\n      }\r\n      // `values` is always an array as an array is a return value of `parseProperty`\r\n      if (values.length > 0) {\r\n        // There are some values found\r\n        values = values.map(v => { return { providerValue: v, sortOrder: inputItem.order ? inputItem.order : 1 } })\r\n        const feature = this[Feature.types[featureName]].getMultiple(values, allowUnknownValues)\r\n        model.addFeature(feature)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Maps property of a single feature type to a single Feature object with one\r\n   * or more values, using an attribute to determine the mapped-to feature name\r\n   * (if this feature has multiple values). Feature is stored as a property of\r\n   * the supplied model object.\r\n   * @param {object} model the model object to which the feature will be added\r\n   * @param {object} inputElem the input data element\r\n   * @param {object} inputName the  property name in the input data\r\n   * @param {string} attributeName the attribute to use to get the feature name\r\n   * @param {boolean} allowUnknownValues flag to indicate if unknown values are allowed\r\n   */\r\n  mapFeatureByAttribute (model, inputElem, inputName, attributeName, allowUnknownValues) {\r\n    const inputItem = inputElem[inputName]\r\n    let featureName\r\n    if (inputItem && (Array.isArray(inputItem) || inputItem.$)) {\r\n      let values = []\r\n      if (Array.isArray(inputItem)) {\r\n        // There are multiple values of this feature\r\n        for (const e of inputItem) {\r\n          if (featureName && featureName !== e[attributeName]) {\r\n            Logger.getInstance().warn('Mutiple feature values with mismatching attribute value', inputElem)\r\n          }\r\n          featureName = e[attributeName]\r\n          values.push(...this.parseProperty(inputName, e.$, inputElem))\r\n        }\r\n      } else {\r\n        featureName = inputItem[attributeName]\r\n        values = this.parseProperty(inputName, inputItem.$, inputElem)\r\n      }\r\n      // `values` is always an array as an array is a return value of `parseProperty`\r\n      if (values.length > 0) {\r\n        // There are some values found\r\n        values = values.map(v => { return { providerValue: v, sortOrder: inputItem.order ? inputItem.order : 1 } })\r\n        const feature = this[Feature.types[featureName]].getMultiple(values, allowUnknownValues, inputItem.cat)\r\n        model.addFeature(feature)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overrides feature data from an inflection with feature data from the lemma\r\n   * if required by an engine-specific list of featureTypes\r\n   * @param {String} featureType the feature type name\r\n   * @param {Inflection} inflection the inflection object\r\n   * @param {Lemma[]} lemmas the lemma objects\r\n   */\r\n  overrideInflectionFeatureIfRequired (featureType, inflection, lemmas) {\r\n    if (this.inflectionOverrides[featureType] &&\r\n        this.inflectionOverrides[featureType](inflection, lemmas)) {\r\n      for (const lemma of lemmas.filter(l => l.features[featureType])) {\r\n        inflection.addFeature(lemma.features[featureType])\r\n      }\r\n    }\r\n  }\r\n}\r\nexport default ImportMorphData\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE_alpheios_data_models__;","module.exports = __WEBPACK_EXTERNAL_MODULE_alpheios_l10n__;","module.exports = __WEBPACK_EXTERNAL_MODULE_alpheios_messaging__;","module.exports = require(\"assert\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = __WEBPACK_EXTERNAL_MODULE_papaparse__;","module.exports = require(\"stream\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./index.js\");\n"],"sourceRoot":""}