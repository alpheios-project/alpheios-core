{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///../../webpack/universalModuleDefinition","webpack:///../../webpack/bootstrap","webpack:///../../index.js","webpack:///../../node_modules/uuid/dist/esm-browser/bytesToUuid.js","webpack:///../../node_modules/uuid/dist/esm-browser/index.js","webpack:///../../node_modules/uuid/dist/esm-browser/md5.js","webpack:///../../node_modules/uuid/dist/esm-browser/rng.js","webpack:///../../node_modules/uuid/dist/esm-browser/sha1.js","webpack:///../../node_modules/uuid/dist/esm-browser/v1.js","webpack:///../../node_modules/uuid/dist/esm-browser/v3.js","webpack:///../../node_modules/uuid/dist/esm-browser/v35.js","webpack:///../../node_modules/uuid/dist/esm-browser/v4.js","webpack:///../../node_modules/uuid/dist/esm-browser/v5.js","webpack:///../../src/configurations/destinations.js","webpack:///../../src/core/messaging-service.js","webpack:///../../src/core/stored-request.js","webpack:///../../src/destinations/destination.js","webpack:///../../src/destinations/window-iframe-destination.js","webpack:///../../src/messages/message.js","webpack:///../../src/messages/request-message.js","webpack:///../../src/messages/response-message.js","webpack:///../node_modules/source-map-loader/node_modules/axios/index.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/adapters/http.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/adapters/xhr.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/axios.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/Cancel.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/CancelToken.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/cancel/isCancel.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/Axios.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/InterceptorManager.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/buildFullPath.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/createError.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/dispatchRequest.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/enhanceError.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/mergeConfig.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/settle.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/core/transformData.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/defaults.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/bind.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/buildURL.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/combineURLs.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/cookies.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/parseHeaders.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/helpers/spread.js","webpack:///../node_modules/source-map-loader/node_modules/axios/lib/utils.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/index.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/browser.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/debug.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/index.js","webpack:///../node_modules/source-map-loader/node_modules/follow-redirects/node_modules/debug/src/node.js","webpack:///../node_modules/source-map-loader/node_modules/has-flag/index.js","webpack:///../node_modules/source-map-loader/node_modules/ms/index.js","webpack:///../node_modules/source-map-loader/node_modules/papaparse/papaparse.js","webpack:///../node_modules/source-map-loader/node_modules/supports-color/index.js","webpack:///../node_modules/source-map-loader/node_modules/xmltojson/lib/xmlToJSON.js","webpack:///./adapters/alpheiostb/adapter.js","webpack:///./adapters/arethusa/adapter.js","webpack:///./adapters/base-adapter.js","webpack:///./adapters/chineseloc/adapter.js","webpack:///./adapters/concordance/adapter.js","webpack:///./adapters/lexicons/adapter.js","webpack:///./adapters/logeion/adapter.js","webpack:///./adapters/translations/adapter.js","webpack:///./adapters/tufts/adapter.js","webpack:///./adapters/tufts/engine/aramorph.js","webpack:///./adapters/tufts/engine/hazm.js","webpack:///./adapters/tufts/engine/morpheusgrc.js","webpack:///./adapters/tufts/engine/sedra.js","webpack:///./adapters/tufts/engine/traces.js","webpack:///./adapters/tufts/engine/whitakers.js","webpack:///./adapters/tufts/engines-set.js","webpack:///./client-adapters.js","webpack:///./errors/adapter-error.js","webpack:///./errors/no-required-param-error.js","webpack:///./errors/remote-error.js","webpack:///./errors/wrong-method-error.js","webpack:///./index.js","webpack:///./locales/locales.js","webpack:///./transformers/alpheios-lexicon-transformer.js","webpack:///./transformers/import-morph-data.js","webpack:///external \"alpheios-data-models\"","webpack:///external \"alpheios-messaging\"","webpack:///external \"assert\"","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"os\"","webpack:///external \"stream\"","webpack:///external \"tty\"","webpack:///external \"url\"","webpack:///external \"util\"","webpack:///external \"zlib\"","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/node module decorator","webpack:///webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,aAKJ;AACF,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA,WAAW,8BAAmB;;QAE9B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA,kEAAkE,8BAAmB;;QAErF;QACA;;QAEA;QACA;QACA;;;QAGA;QACA,EAAE,8BAAmB;;QAErB;QACA,EAAE,8BAAmB;;QAErB;QACA,EAAE,8BAAmB;QACrB,OAAO,8BAAmB;QAC1B,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA,EAAE,8BAAmB;QACrB;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA,EAAE,8BAAmB;QACrB,wBAAwB,8BAAmB;QAC3C;QACA;QACA;QACA,GAAG,8BAAmB;QACtB,yCAAyC,iCAAiC;QAC1E,kEAAkE,8BAAmB,2BAA2B,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA,EAAE,8BAAmB;QACrB;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD,GAAG,8BAAmB;QACtB;QACA;;QAEA;QACA,EAAE,8BAAmB,iCAAiC,+DAA+D;;QAErH;QACA,EAAE,8BAAmB;;;QAGrB;QACA,SAAS,8BAAmB,CAAC,8BAAmB;;;;;;;;;;;;;AClFhD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkE;AACuB;AACvB;AACE;AAC0C;;AAK7G;;;;;;;;;;;;;ACTD;AAAA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEe,0EAAW,E;;;;;;;;;;;;ACjB1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACA;AACA;;;;;;;;;;;;;ACFxC;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,aAAa,mBAAmB;AAChC;AACA;;AAEA;;AAEA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,kEAAG,E;;;;;;;;;;;;ACzNlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAEhB;AACf;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACdA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,OAAO;AACxB;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;AC1FnB;AAAA;AAAA;AAA2B;AACgB;AAC3C;AACA;AACA;;AAEA;;AAEA,cAAc;;;AAGd;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;;AAEA;AACA,sDAAsD,+CAAG;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA,iFAAiF;AACjF;;AAEA,2EAA2E;;AAE3E,6DAA6D;;AAE7D;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;;AAEvB,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,sBAAsB;;AAEtB,mCAAmC;;AAEnC,6BAA6B;;AAE7B,iCAAiC;;AAEjC,2BAA2B;;AAE3B,iBAAiB,OAAO;AACxB;AACA;;AAEA,qBAAqB,+DAAW;AAChC;;AAEe,iEAAE,E;;;;;;;;;;;;AC9FjB;AAAA;AAAA;AAA2B;AACA;AAC3B,SAAS,uDAAG,aAAa,+CAAG;AACb,iEAAE,E;;;;;;;;;;;;ACHjB;AAAA;AAAA;AAAA;AAA2C;;AAE3C;AACA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA,GAAG;AACH;AACA;;AAEA;AACA,0CAA0C;;AAE1C;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEO;AACA;AACQ;AACf;AACA;AACA;AACA;AACA;AACA,6IAA6I;;AAE7I;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;AAEA,kBAAkB,+DAAW;AAC7B,IAAI;;;AAGJ;AACA;AACA,GAAG,eAAe;;;AAGlB;AACA;AACA;AACA,C;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAA2B;AACgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,+CAAG,IAAI;;AAEtD;AACA,kCAAkC;;AAElC;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA,gBAAgB,+DAAW;AAC3B;;AAEe,iEAAE,E;;;;;;;;;;;;AC1BjB;AAAA;AAAA;AAA2B;AACE;AAC7B,SAAS,uDAAG,aAAa,gDAAI;AACd,iEAAE,E;;;;;;;;;;;;ACHjB;AAAA;AAAA;AAAA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACiB;AACR;;AAE5D;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,0BAA0B;AACvC;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA,SAAS,qEAAO;AAChB;AACA;AACA;AACA,SAAS,8EAAe;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,8EAAe;AACxC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA,wEAAwE,WAAW;AACnF,4BAA4B,wEAAa;AACzC;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,eAAe;AAC5B,aAAa,OAAO;AACpB,eAAe,4DAA4D;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA,KAAK;AACL,oCAAoC,SAAS,WAAW,YAAY;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChNA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA,gBAAgB,iDAAiD,KAAK;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACY;;AAE/D;AACe,sCAAsC,6EAAW;AAChE;AACA,aAAa,OAAO,kBAAkB;AACtC,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,gBAAgB,yDAAyD,KAAK;AAC9E,WAAW,kBAAkB;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6DAA6D,qEAAO;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AACA;AACA;AACmC;;AAEnC;AACe;AACf;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,+BAA+B,oBAAoB;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA,4FAA4F,oBAAoB;AAChH;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,+CAAM;;AAEpB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;;AAEnD;AACe,6BAA6B,qEAAO;AACnD;AACA,aAAa,OAAO,SAAS;AAC7B;AACA,wBAAwB;AACxB;AACA,gBAAgB,qEAAO;;AAEvB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACmD;AACe;;AAElE;AACe,8BAA8B,qEAAO;AACpD;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,iCAAiC,2DAA2D,YAAY,KAAK;AAC7G;AACA;AACA;AACA,gBAAgB,qEAAO;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,OAAO,SAAS;AAC7B,eAAe,gBAAgB;AAC/B;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA,aAAa,eAAe;AAC5B,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,0EAA0E,YAAY;AACtF;;AAEA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C,eAAe,QAAQ;AACvB;AACA;AACA;AACA,uBAAuB,qEAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1GA,iBAAiB,mBAAO,CAAC,6DAAa,E;;;;;;;;;;;;;;ACAzB;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,aAAa,mBAAO,CAAC,wEAAkB;AACvC,oBAAoB,mBAAO,CAAC,oFAAuB;AACnD,eAAe,mBAAO,CAAC,kFAAuB;AAC9C,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,iBAAiB,mGAAgC;AACjD,kBAAkB,oGAAiC;AACnD,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,UAAU,mBAAO,CAAC,sEAAsB;AACxC,kBAAkB,mBAAO,CAAC,gFAAqB;AAC/C,mBAAmB,mBAAO,CAAC,kFAAsB;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;ACtRa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,aAAa,mBAAO,CAAC,wEAAkB;AACvC,eAAe,mBAAO,CAAC,kFAAuB;AAC9C,oBAAoB,mBAAO,CAAC,oFAAuB;AACnD,mBAAmB,mBAAO,CAAC,0FAA2B;AACtD,sBAAsB,mBAAO,CAAC,gGAA8B;AAC5D,kBAAkB,mBAAO,CAAC,gFAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,gFAAsB;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;ACnLa;;AAEb,YAAY,mBAAO,CAAC,yDAAS;AAC7B,WAAW,mBAAO,CAAC,uEAAgB;AACnC,YAAY,mBAAO,CAAC,mEAAc;AAClC,kBAAkB,mBAAO,CAAC,+EAAoB;AAC9C,eAAe,mBAAO,CAAC,+DAAY;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,yEAAiB;AACxC,oBAAoB,mBAAO,CAAC,mFAAsB;AAClD,iBAAiB,mBAAO,CAAC,6EAAmB;;AAE5C;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,2EAAkB;;AAEzC;;AAEA;AACA,sBAAsB;;;;;;;;;;;;;;;ACpDT;;AAEb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;;;AClBa;;AAEb,aAAa,mBAAO,CAAC,kEAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACxDa;;AAEb;AACA;AACA;;;;;;;;;;;;;;;ACJa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,eAAe,mBAAO,CAAC,gFAAqB;AAC5C,yBAAyB,mBAAO,CAAC,wFAAsB;AACvD,sBAAsB,mBAAO,CAAC,kFAAmB;AACjD,kBAAkB,mBAAO,CAAC,0EAAe;;AAEzC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;;;;;;;;AC7Fa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;;;ACnDa;;AAEb,oBAAoB,mBAAO,CAAC,0FAA0B;AACtD,kBAAkB,mBAAO,CAAC,sFAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBa;;AAEb,mBAAmB,mBAAO,CAAC,4EAAgB;;AAE3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;AAChC,oBAAoB,mBAAO,CAAC,8EAAiB;AAC7C,eAAe,mBAAO,CAAC,8EAAoB;AAC3C,eAAe,mBAAO,CAAC,gEAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;;;AC9Ea;;AAEb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzCa;;AAEb,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;ACxEa;;AAEb,kBAAkB,mBAAO,CAAC,0EAAe;;AAEzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxBa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;ACnBa;;AAEb,YAAY,mBAAO,CAAC,yDAAS;AAC7B,0BAA0B,mBAAO,CAAC,qGAA+B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,uEAAgB;AACtC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,yEAAiB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;;;AChGa;;AAEb;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;ACtEa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C,SAAS;;AAET;AACA,4DAA4D,wBAAwB;AACpF;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,kCAAkC;AAClC,+BAA+B,aAAa,EAAE;AAC9C;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;ACnEa;;AAEb,YAAY,mBAAO,CAAC,0DAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,4DAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1Ba;;AAEb,WAAW,mBAAO,CAAC,uEAAgB;;AAEnC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC;AAChC,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvVA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,eAAe,oDAA0B;AACzC,YAAY,mBAAO,CAAC,qFAAO;;AAE3B;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,sBAAsB,uCAAuC,EAAE;AAC/D,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD,mBAAmB;;;;;;;;;;;;;;ACjUnB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,uFAAS;AAC5C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,qBAAqB;AAC3B;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,gBAAgB,GAAG,mBAAO,CAAC,6CAAI;;AAE/B;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,EAAE,aAAa;AACf,EAAE,aAAa;;AAEf;AACA;AACA;;AAEA,aAAa,SAAS;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AChOA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,8FAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,wFAAW;AACtC;;;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,uFAAS;AAC5C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA,sBAAsB,mBAAO,CAAC,qEAAgB;AAC9C;AACA,IAAI,cAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,EAAE;AACnD,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACzLa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,IAA0C;AAC/C;AACA;AACA,EAAE,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACrB;AACA,MAAM,EAWJ;AACF;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD,sCAAsC,eAAe;AACrD,sCAAsC,eAAe;;AAErD;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,yFAAyF,KAAK,wBAAwB;AACtH;;AAEA;AACA,oEAAoE;AACpE,iBAAiB;;AAEjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA,iCAAiC;AACjC,MAAM;AACN;AACA,IAAI;;AAEJ,mBAAmB;AACnB,eAAe;;;AAGf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE,gDAAgD,EAAE;AAClH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,gCAAgC,2CAA2C;AAC3E;AACA;AACA,6BAA6B;AAC7B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;;AAElC,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU,cAAc,EAAE,EAAE;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA,eAAe,kDAAwB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE,yEAAyE,EAAE,oEAAoE,EAAE;AACzK;AACA,uBAAuB;AACvB,sBAAsB;AACtB,aAAa;AACb,cAAc;AACd,sBAAsB;AACtB,uBAAuB;AACvB,sBAAsB;AACtB,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,qBAAqB,QAAQ,eAAe,EAAE,iBAAiB,QAAQ,gBAAgB,EAAE;AACzF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,8CAA8C;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+DAA+D;;AAE/D,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B,gBAAgB,EAAE;AAClF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;;ACn4DY;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,yDAAU;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,wCAAwC;AACjE;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA,uDAAuD,sCAAsC;AAC7F;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,gDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2BAA2B;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC,SAAS;;AAEV,IAAI,KAA4B;AAChC,SAAS,IAA0C,EAAE,mCAAO,aAAa,mBAAmB;AAAA,kGAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACjP4E;AAC9G;;AAEY;AACtC;;AAEjC,sCAAsC,sEAAW;AACjD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,wEAAa;AACzD,mBAAmB,MAAM,oEAAkB,OAAO,oEAAkB;AACpE;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB;AAC/E;AACA;AACA;AACA,gDAAgD,cAAc;;AAE9D;AACA;AACA;;AAEA;AACA,yBAAyB,4FAAyB;;AAElD,wBAAwB,4DAAqB;AAC7C,mEAAmE,QAAQ,mBAAmB;;AAE9F;AACA;AACA,OAAO;AACP,6EAA6E,gBAAgB;AAC7F;AACA,KAAK;AACL,sEAAsE,yBAAyB;AAC/F;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAgB;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,uDAAK;AACzB,yBAAyB,wDAAM;AAC/B,yBAAyB,4DAAU;AACnC;AACA,8BAA8B,yDAAO,CAAC,wEAAsB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+DAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAO,EAAE,2EAAyB;AACjD;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHqB;AACmC;AACf;AACT;;AAEC;AAGb;;AAE1D,sCAAsC,sEAAW;AACjD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA;AACA,4CAA4C,wEAAa;AACzD;;AAEA;AACA,SAAS,0GAA2B;AACpC,MAAM,6GAA8B,kBAAkB,sGAAW;AACjE;AACA,WAAW,0GAA2B;AACtC;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,6FAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,6FAAc;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe,EAAE;AAC1C;AACA;AACA,0DAA0D,6FAAc;AACxE,KAAK;AACL,8BAA8B,8FAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,aAAa;AAC5F;AACA;AACA,8BAA8B,uFAAqC;AACnE;AACA,iFAAiF,oCAAoC;AACrH;AACA;AACA,yBAAyB,kFAAU;AACnC;AACA;AACA,kEAAkE,mEAAiB;AACnF,mEAAmE,mEAAiB;AACpF,kEAAkE,mEAAiB;AACnF;AACA;AACA,SAAS;AACT,qCAAqC,0FAA0B;AAC/D;AACA;AACA;AACA;AACA,6CAA6C,oEAAkB,YAAY,qEAAmB;AAC9F;AACA,6CAA6C,oEAAkB,YAAY,2EAAyB;AACpG,2DAA2D,yDAAO,CAAC,oEAAkB,EAAE,gFAA8B;AACrH;AACA;AACA,OAAO;AACP,sEAAsE,gBAAgB;AACtF;AACA,KAAK;AACL,sEAAsE,yBAAyB;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,6FAAc;AAC7D,4BAA4B,YAAY,mCAAmC;AAC3E,gEAAgE,6FAAc;AAC9E;AACA,KAAK;AACL,8BAA8B,8FAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gEAAgE,6FAAc;AAC9E;AACA,KAAK;AACL,8BAA8B,8FAAe;AAC7C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5Kb;AAC0B;AACQ;AACC;;AAER;AACM;AACA;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAI;AACxB,mBAAmB,oEAAI,EAAE,yEAAa;AACtC,mBAAmB,oEAAI,EAAE,yEAAa;AACtC,iBAAiB,yEAAa;AAC9B;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,sBAAsB,qEAAY;AAClC;AACA;;AAEA;AACA,sBAAsB,uEAAW;AACjC;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,cAAc;AACd;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA,+EAA+E,+DAA+D;AAC9I;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,0EAA0E,WAAW;AACrF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA,8EAA8E,WAAW;AACzF;AACA;AACA,WAAW;AACX,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gDAAS,6BAA6B,2BAA2B;AACvF,SAAS;AACT,sBAAsB,gDAAS;AAC/B;AACA;AACA,OAAO;AACP,0EAA0E,WAAW;AACrF;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,oEAAkB;AACxB,KAAK;AACL;AACA;AACA;AACA,MAAM,oEAAkB;AACxB,KAAK;AACL;AACA,MAAM,oEAAkB;AACxB;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,iBAAiB,OAAO;AACxB;AACA,iBAAiB,OAAO;AACxB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;AClN1B;AAC2D;AAC6C;AAG7E;;AAEpB;AACP;AACA;AACA;;AAEA;;AAEA,wCAAwC,sEAAW;AACnD,0BAA0B;AAC1B;AACA;AACA,wBAAwB,uEAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,2EAA2B;AACpC,MAAM,8EAA8B,qBAAqB,uEAAW;AACpE;AACA;AACA;AACA,oBAAoB,sFAA0B;AAC9C,OAAO;AACP;AACA,6BAA6B,2EAA2B;AACxD;;AAEA,qBAAqB,QAAQ,iFAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD,yBAAyB,WAAW,EAAE,+BAA+B;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8DAAc;AACxG,OAAO;AACP;AACA;AACA;;AAEA;AACA,4DAA4D,2DAA2D;AACvH;AACA;AACA;AACA;AACA,4DAA4D,2DAA2D;AACvH;AACA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,8DAAc;AACxG,OAAO;AACP;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAK;;AAE3B;AACA,gDAAgD,mFAAiC;AACjF;AACA;AACA;AACA,mCAAmC,EAAE,KAAK,UAAU,GAAG;AACvD,OAAO;AACP,2CAA2C,6EAA2B;AACtE,2CAA2C,oEAAkB;AAC7D,2FAA2F,uEAAqB;AAChH,iEAAiE,yEAAuB;;AAExF,yBAAyB,wDAAM;AAC/B,2DAA2D,4DAAU;AACrE;AACA;AACA,KAAK;AACL,sBAAsB,yDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,yDAAO;AACtB;AACA;;AAEA,iEAAe,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;ACrKgC;AACc;;AAE2B;AACtD;;AAE3D,yCAAyC,sEAAW;AACpD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,yEAAa;AACzD,wBAAwB,kEAAgB;AACxC;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA,wDAAwD,EAAE,8EAAsB;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yEAAyE,yBAAyB;AAClG;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,YAAY,OAAO,SAAS,EAAE;AAC9B,aAAa,OAAO;AACpB;AACA,eAAe,mBAAmB;AAClC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA,mDAAmD,iBAAiB,WAAW;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4FAA0C;AAC9D;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,4EAA4E,yBAAyB;AACrG;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,YAAY,OAAO,SAAS,EAAE;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc,gBAAgB,EAAE,uCAAuC,EAAE,gBAAgB,EAAE,oBAAoB;AAC/G;;AAEA;AACA;AACA,YAAY,OAAO,YAAY,UAAU,OAAO,aAAa,SAAS,EAAE;AACxE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB,GAAG,oBAAoB;AAC5D;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO,eAAe,0BAA0B,QAAQ,EAAE;AACtE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB,GAAG,2BAA2B,OAAO,+BAA+B;AACzG,KAAK;AACL,iBAAiB,oBAAoB,GAAG,2BAA2B;AACnE;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB;AACnB;AACA;AACA,KAAK;;AAEL,0BAA0B;AAC1B;AACA;AACA,KAAK;;AAEL,qBAAqB,wDAAM;AAC3B;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA,mBAAmB;AACnB;AACA;AACA,KAAK;;AAEL,0BAA0B;AAC1B;AACA;AACA,KAAK;;AAEL,uBAAuB,0DAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA,+BAA+B,kEAAgB;AAC/C,MAAM,4FAA0C;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;;;ACnTuD;AAC/D;;AAE0B;AACU;;AAErE;AACA;;AAEA,sCAAsC,sEAAW;AACjD;AACA;AACA,YAAY,OAAO;AACnB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,sEAAa;AACzD,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,yBAAyB;AACpG;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qEAAqE,yBAAyB;AAC9F;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,6CAA6C;AAC/F,yBAAyB,sDAAe,YAAY,gBAAgB,KAAK,mBAAmB;AAC5F;AACA;;AAEA;AACA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA,kBAAkB,uFAAoB;;AAEtC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,iCAAiC,kEAAgB;AACjD,4BAA4B,4DAAU;AACtC,+BAA+B,2EAAyB;AACxD;AACA,WAAW;AACX,2EAA2E,yBAAyB;AACpG;AACA;AACA;AACA,OAAO;AACP;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA,kBAAkB,uFAAoB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,QAAQ,KAAK,UAAU,mBAAmB;AAC5E;AACA,OAAO;AACP,uBAAuB,SAAS,QAAQ,KAAK,sCAAsC,mBAAmB;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,OAAO;AACP,kDAAkD,cAAc;AAChE;;AAEA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA,WAAW;AACX,iCAAiC,kEAAgB;AACjD,4BAA4B,4DAAU;AACtC,+BAA+B,2EAAyB;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA,yEAAyE,yBAAyB;AAClG;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,OAAO;AACP,qDAAqD,cAAc;AACnE;;AAEA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F,SAAS;AACT,+BAA+B,kEAAgB;AAC/C,0BAA0B,4DAAU;AACpC,6BAA6B,2EAAyB;AACtD;AACA;AACA,OAAO;AACP,uEAAuE,yBAAyB;AAChG;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,yBAAyB,4FAAyB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,8BAA8B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;ACnhB8B;AACT;;AAEkB;;AAE7E,qCAAqC,sEAAW;AAChD;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,qEAAa;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA,gBAAgB,0BAA0B,OAAO,yBAAyB,KAAK,KAAK,QAAQ,qBAAqB;AACjH;AACA;;AAEA;AACA,6BAA6B,6EAA2B;AACxD;AACA,KAAK,WAAW,6EAA2B,EAAE,4EAA0B;AACvE;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,aAAa;AACb;AACA;AACA;AACA,kBAAkB,+FAA4B;AAC9C;AACA;AACA,wBAAwB,+FAA4B;AACpD;AACA;AACA;AACA,KAAK;;AAEL,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;ACjGoC;;AAEwB;AACtC;;AAE3D,+CAA+C,sEAAW;AAC1D;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,0EAAa;AACzD;AACA,wBAAwB,kEAAgB;AACxC;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,4FAAyB;AAC5C;;AAEA;;AAEA;AACA,yEAAyE,0BAA0B;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,8EAA4B;AACxC;AACA,SAAS;AACT,uEAAuE,yBAAyB;AAChG;AACA;AACA,KAAK;AACL,mEAAmE,yBAAyB;AAC5F;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iEAAe,gCAAgC;;;;;;;;;;;;;;;;;;;;;;;;;ACvH+C;;AAEnC;AACmC;;AAE5B;AACH;;AAE/D,mCAAmC,sEAAW;AAC9C;AACA;AACA,aAAa,OAAO;AACpB;AACA,0BAA0B;AAC1B;AACA,4CAA4C,mEAAa;AACzD;AACA,yBAAyB,2EAAU;AACnC;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4FAAyB;;AAE9C,qBAAqB,0EAAwB;AAC7C;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gFAAgF,oCAAoC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E,kCAAkC;AAC/G;AACA;AACA,qCAAqC,0FAA0B;AAC/D;;AAEA;AACA,8DAA8D,gDAAgD;AAC9G;AACA;;AAEA;AACA,+BAA+B,kFAAgC,CAAC,yEAAuB,EAAE,oEAAkB;AAC3G;;AAEA;AACA;AACA,KAAK;AACL,6DAA6D,yBAAyB;AACtF;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA;AACA,qBAAqB,4FAAyB;AAC9C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;;;;;;;;AC9GmC;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,qEAA0B;;AAEtD,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;ACLmD;AACxB;;AAE9C,eAAe,kFAAU,CAAC,sEAA2B;;AAErD;AACA,wCAAwC,oCAAoC;;AAE5E,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;ACRmD;AACxB;;AAE9C,eAAe,kFAAU,CAAC,oEAAyB;;AAEnD;AACA;AACA;AACA,GAAG,oEAAyB,gBAAgB,oEAAyB,YAAY,0EAA+B,8BAA8B,oEAAyB,YAAY,wEAA6B;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sEAA2B;AAC3C,+BAA+B,0EAA+B,OAAO,yEAA8B;;AAEnG,gBAAgB,0EAA+B;AAC/C,sBAAsB,mEAAwB,OAAO,mEAAwB;;AAE7E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,sBAAsB,wEAA6B;AACnD,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;ACvCmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,qEAA0B;;AAEtD;AACA;AACA;AACA,0BAA0B,oEAAyB;AACnD,CAAC;;AAED;AACA;AACA,6CAA6C,6EAAkC;AAC/E;AACA,aAAa,4DAAiB;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;ACjCmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,mEAAwB;;AAEpD,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;ACLmD;AACxB;;AAE9C,iBAAiB,kFAAU,CAAC,oEAAyB;;AAErD;AACA;AACA,4BAA4B,EAAE,2EAAgC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,sEAA2B;AAC3C,mBAAmB,0EAA+B,OAAO,yEAA8B;AACvF,gBAAgB,0EAA+B,OAAO,yEAA8B,OAAO,uEAA4B;;AAEvH,gBAAgB,qEAA0B;AAC1C,yBAAyB,gFAAqC;;AAE9D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,sBAAsB,0EAA+B;AACrD,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAA8B;AAChE,mCAAmC,sEAA2B;AAC9D,mCAAmC,mEAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAA8B,oCAAoC,yEAA8B;AACrI;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAY;AAC7B;;AAEA;AACA,CAAC;;AAED,iEAAe,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3GgD;AACI;AACN;AACR;AACI;AACF;;AAEO;;AAElE;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA,mCAAmC,gFAAS,EAAE,kFAAW,EAAE,+EAAQ,EAAE,2EAAI,EAAE,6EAAM,EAAE,4EAAK,eAAe,uBAAuB;AAC9H;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,uBAAuB,4FAAyB;AAChD;AACA;AACA;;AAEA,iEAAe,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzC4C;AACU;AACF;AACW;AACb;AACM;AACN;AACF;;AAEL;AACS;;AAEP;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAAc;AAC3C,yBAAyB;AACzB,iCAAiC,uEAAc;AAC/C,8BAA8B,uEAAc;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,gBAAgB,0EAAgB;AAChC;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAoB;AACxC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,+BAA+B,uEAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,4EAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA,+BAA+B,4EAAuB;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA,6BAA6B,0EAAuB;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,mCAAmC,8EAAgC;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,6EAA0B;AAC7D;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,gBAAgB,OAAO;AACvB,gBAAgB,QAAQ;AACxB,gBAAgB,wBAAwB;AACxC,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,0EAAuB;;AAE5D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,yEAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,iEAAe,cAAc;;;;;;;;;;;;;;;;;;;AC9X7B;AACA;AACA;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;;AAEA;AACA,wBAAwB,aAAa,IAAI,aAAa,GAAG,gBAAgB;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB,GAAG,mBAAmB;AAC5D;;AAEA,sBAAsB,aAAa,IAAI,aAAa,GAAG,gBAAgB;AACvE;AACA;AACA;;AAEA,iEAAe,YAAY;;;;;;;;;;;;;;;;;;;ACzB3B;AACA;AACA,wDAAwD,UAAU,OAAO,SAAS,GAAG,YAAY,KAAK,WAAW;AACjH;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;AACA;AACA;;AAEA,iEAAe,oBAAoB;;;;;;;;;;;;;;;;;;;ACXpB;AACf;AACA;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB,GAAG,mBAAmB;AAC5D;;AAEA,sBAAsB,eAAe,IAAI,aAAa,IAAI,aAAa,GAAG,gBAAgB;AAC1F;AACA;AACA;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA,wCAAwC,SAAS,GAAG,YAAY,KAAK,WAAW;AAChF;AACA,sBAAsB,SAAS,GAAG,YAAY;AAC9C;AACA;AACA;AACA;;AAEA,iEAAe,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;ACV4B;AACC;;AAEtB;;;;;;;;;;;;;;;;;;;;;ACHE;AACA;;AAExC,iEAAe;AACf;AACA;AACA;AACA,WAAW,iDAAI;AACf,WAAW,iDAAI;AACf;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;ACVuG;;AAExG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,MAAM;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,wEAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,kEAAgB;;AAEzC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,2EAAyB;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,2EAAyB;AAC5C;AACA,WAAW;AACX;AACA;AACA,2BAA2B,wDAAM;;AAEjC;AACA,uBAAuB,2EAAyB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAU;AACrC,SAAS;AACT,8FAA8F,mBAAmB;AACjH;AACA;AACA;AACA,oCAAoC,yDAAO,CAAC,wEAAsB;AAClE;AACA;AACA;AACA;AACA;AACA,iEAAiE,+DAAa;AAC9E,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,+DAAa;AAC9E,WAAW;AACX;AACA;AACA;;AAEA;AACA,uBAAuB,uEAAqB;AAC5C,qBAAqB,qEAAmB;AACxC,qBAAqB,oEAAkB;AACvC,qBAAqB,qEAAmB;AACxC,qBAAqB,sEAAoB;AACzC,qBAAqB,0EAAwB;AAC7C,qBAAqB,wEAAsB;AAC3C,qBAAqB,yEAAuB;AAC5C,qBAAqB,uEAAqB;AAC1C,qBAAqB,qEAAmB;AACxC,qBAAqB,qEAAmB;AACxC,qBAAqB,qEAAmB;AACxC,qBAAqB,uEAAqB;AAC1C;AACA;AACA;AACA;AACA,8BAA8B,oEAAkB;AAChD;AACA;AACA;AACA,8BAA8B,0EAAwB;AACtD,6BAA6B,oEAAkB,oBAAoB,oEAAkB,qBAAqB,oEAAkB;AAC5H;AACA;AACA;AACA,8BAA8B,2EAAyB;AACvD,6BAA6B,oEAAkB,oBAAoB,oEAAkB,qBAAqB,oEAAkB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAO;AACxB,KAAK;AACL;AACA;AACA;AACA;;AAEA,iEAAe,0BAA0B;;;;;;;;;;;;;;;;;;;;;ACpTzC;AACA;AACA;AACqG;;AAErG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,uDAAK;;AAEzD;AACA;AACA,iDAAiD,6EAA2B;AAC5E,iBAAiB,4DAAU;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,oEAAkB;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,cAAc,gBAAgB,YAAY,QAAQ,mBAAmB,cAAc,mBAAmB;AAClJ;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,4CAA4C,mBAAmB,gBAAgB,YAAY,QAAQ,mBAAmB,cAAc,mBAAmB;AACvJ;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,iEAAe;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,qEAAqE,EAAE;AAClH,6BAA6B,+DAAa;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAkB;AAC9B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS,qEAAqE,EAAE;AAClH,6BAA6B,+DAAa;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3Q9B,kE;;;;;;;;;;;;;;;;;;ACAA,gE;;;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;;;ACAA,iC;;;;;;;;;;;;;;ACAA,kC;;;;;;;;;;;;;;ACAA,+B;;;;;;;;;;;;;;;;ACAA,mC;;;;;;;;;;;;;;ACAA,gC;;;;;;;;;;;;;;ACAA,gC;;;;;;;;;;;;;;ACAA,iC;;;;;;;;;;;;;;ACAA,iC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCxBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;WCNA;WACA;WACA;WACA;WACA,E;;;;UCJA;UACA;UACA;UACA","file":"alpheios-client-adapters.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"alpheios-data-models\"), require(\"alpheios-messaging\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"alpheios-data-models\", \"alpheios-messaging\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"alpheios-data-models\"), require(\"alpheios-messaging\")) : factory(root[\"alpheios-data-models\"], root[\"alpheios-messaging\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function(__WEBPACK_EXTERNAL_MODULE_alpheios_data_models__, __WEBPACK_EXTERNAL_MODULE_alpheios_messaging__) {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import MessagingService from '@messServ/core/messaging-service.js'\r\nimport WindowIframeDestination from '@messServ/destinations/window-iframe-destination.js'\r\nimport RequestMessage from '@messServ/messages/request-message.js'\r\nimport ResponseMessage from '@messServ/messages/response-message.js'\r\nimport { CedictDestinationConfig, CedictDestinationDevConfig } from '@messServ/configurations/destinations.js'\r\n\r\nexport {\r\n  MessagingService, WindowIframeDestination, RequestMessage, ResponseMessage,\r\n  CedictDestinationConfig, CedictDestinationDevConfig\r\n}\r\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';","/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes == 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Array(msg.length);\n\n    for (var i = 0; i < msg.length; i++) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var i;\n  var x;\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n  var hex;\n\n  for (i = 0; i < length32; i += 8) {\n    x = input[i >> 5] >>> i % 32 & 0xff;\n    hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[(len + 64 >>> 9 << 4) + 14] = len;\n  var i;\n  var olda;\n  var oldb;\n  var oldc;\n  var oldd;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (i = 0; i < x.length; i += 16) {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  var i;\n  var output = [];\n  output[(input.length >> 2) - 1] = undefined;\n\n  for (i = 0; i < output.length; i += 1) {\n    output[i] = 0;\n  }\n\n  var length8 = input.length * 8;\n\n  for (i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes == 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Array(msg.length);\n\n    for (var i = 0; i < msg.length; i++) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var i = 0; i < N; i++) {\n    M[i] = new Array(16);\n\n    for (var j = 0; j < 16; j++) {\n      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var i = 0; i < N; i++) {\n    var W = new Array(80);\n\n    for (var t = 0; t < 16; t++) {\n      W[t] = M[i][t];\n    }\n\n    for (var t = 16; t < 80; t++) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var t = 0; t < 80; t++) {\n      var s = Math.floor(t / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;","import bytesToUuid from './bytesToUuid.js';\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  var bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = new Array(str.length);\n\n  for (var i = 0; i < str.length; i++) {\n    bytes[i] = str.charCodeAt(i);\n  }\n\n  return bytes;\n}\n\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  var generateUUID = function generateUUID(value, namespace, buf, offset) {\n    var off = buf && offset || 0;\n    if (typeof value == 'string') value = stringToBytes(value);\n    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);\n    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');\n    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3\n\n    var bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      for (var idx = 0; idx < 16; ++idx) {\n        buf[off + idx] = bytes[idx];\n      }\n    }\n\n    return buf || bytesToUuid(bytes);\n  }; // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name;\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;","/**\r\n * This is a configuration of a WindowsIframeDestination that can be used to connect to CEDICT client service.\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nexport const CedictDestinationConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'https://lexis-dev.alpheios.net',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n/**\r\n * This is a development version of the above configuration\r\n *\r\n * @type {{targetIframeID: string, name: string, targetURL: string}}\r\n */\r\nexport const CedictDestinationDevConfig = {\r\n  name: 'cedict',\r\n  targetURL: 'https://lexis-dev.alpheios.net/index-dev.html',\r\n  targetIframeID: 'alpheios-lexis-cs'\r\n}\r\n","/**\r\n * @module MessagingService\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport ResponseMessage from '@messServ/messages/response-message.js'\r\nimport StoredRequest from '@messServ/core/stored-request.js'\r\n\r\n/**\r\n * A map to keep \"single\" instances of MessagingService objects.\r\n *\r\n * @type {Map<string, MessagingService>}\r\n */\r\nlet services = new Map() // eslint-disable-line prefer-const\r\n\r\n/** A messaging for sending and receiving messages to and from various destinations */\r\nexport default class MessagingService {\r\n  /**\r\n   * Creates an instance of a messaging service.\r\n   *\r\n   * @param {string} name - A name of a messaging service. Useful in identifying the service when\r\n   *        several clients need to share the same instance of a service.\r\n   * @param {Destination || Destination[]} destinations - One or several\r\n   *        destination objects to be used with the messaging service.\r\n   */\r\n  constructor (name, destinations = []) {\r\n    if (!name) throw new Error(MessagingService.errMsgs.NO_NAME)\r\n    this.name = name\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is the message ID and the value is an object\r\n     * that stores details about the message being sent.\r\n     *\r\n     * @type {Map<string, StoredRequest>}\r\n     */\r\n    this._messages = new Map()\r\n\r\n    /**\r\n     * A map object where outgoing messages will be stored. The key is a destination name and the value is\r\n     * the Destination object.\r\n     *\r\n     * @type {Map<string, Destination>}\r\n     */\r\n    this._destinations = new Map()\r\n\r\n    // If provided as a singular value convert destination into an array\r\n    if (!Array.isArray(destinations)) { destinations = [destinations] }\r\n    destinations.forEach(destination => this.registerDestination(destination))\r\n  }\r\n\r\n  /**\r\n   * Check if service with a given name has already been created.\r\n   *\r\n   * @param {string} name - A name of a service.\r\n   * @returns {boolean} Returns true if service has already been created or false otherwise.\r\n   */\r\n  static hasService (name) {\r\n    return services.has(name)\r\n  }\r\n\r\n  /**\r\n   * Returns an instance of a service or `undefined` if service does not exist.\r\n   *\r\n   * @param {string} name - A name of a service.\r\n   * @returns {MessagingService|undefined} If service exists, returns an instance of a service.\r\n   *          If it does not, returns `undefined`.\r\n   */\r\n  static getService (name) {\r\n    return services.get(name)\r\n  }\r\n\r\n  /**\r\n   * Creates an instance of a MessagingService and adds it to the map of instances.\r\n   *\r\n   * @param {string} name - A map of messaging service to create.\r\n   * @param {Destination|Destination[]} destinations - One or several\r\n   *        destination objects to be used with the messaging service.\r\n   * @returns {MessagingService} An instance of a newly created messaging service.\r\n   */\r\n  static createService (name, destinations = []) {\r\n    const service = new MessagingService(name, destinations)\r\n    services.set(name, service)\r\n    return service\r\n  }\r\n\r\n  /**\r\n   * Removes an instance of a MessagingService form the map of instances.\r\n   *\r\n   * @param {string} name - A name of a service to remove.\r\n   * @returns {boolean} True if a service in the map existed and has been removed,\r\n   *          or false if the service does not exist.\r\n   */\r\n  static deleteService (name) {\r\n    return services.delete(name)\r\n  }\r\n\r\n  /**\r\n   * Registers a new destination by adding it to the destinations map and setting a response callback.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  registerDestination (destination) {\r\n    if (this._destinations.has(destination.name)) {\r\n      throw new Error('Destination already exists')\r\n    }\r\n    this._destinations.set(destination.name, destination)\r\n    if (destination.ableToSend) { destination.registerResponseCallback(this.dispatchMessage.bind(this)) }\r\n  }\r\n\r\n  /**\r\n   * Updates a destinations that is already registered.\r\n   *\r\n   * @param {Destination} destination - A destination object to register.\r\n   */\r\n  updateDestination (destination) {\r\n    if (!this._destinations.has(destination.name)) {\r\n      throw new Error('Cannot update a destination that does not exist')\r\n    }\r\n    // Call `deregister` on the destination in order to let it clean the things up\r\n    this._destinations.get(destination.name).deregister()\r\n    this._destinations.set(destination.name, destination)\r\n    // Register a response callback only if destination supports a SEND mode\r\n    if (destination.ableToSend) { destination.registerResponseCallback(this.dispatchMessage.bind(this)) }\r\n  }\r\n\r\n  /**\r\n   * A function to handle incoming messages.\r\n   *\r\n   * @param {ResponseMessage} message - An incoming response message.\r\n   */\r\n  dispatchMessage (message) {\r\n    if (!Message.isKnownType(message.type)) {\r\n      // Ignore messages that we do not support\r\n      return\r\n    }\r\n    if (!ResponseMessage.isResponse(message)) {\r\n      console.error('A message not following a response format will be ignored:', message)\r\n      return\r\n    }\r\n\r\n    if (!this._messages.has(message.requestID)) {\r\n      /*\r\n      Silently ignore a message with request ID not registered in the map.\r\n      It may be a message that is handled by the other messaging service.\r\n      */\r\n      return\r\n    }\r\n    const requestInfo = this._messages.get(message.requestID)\r\n    window.clearTimeout(requestInfo.timeoutID) // Clear a timeout\r\n    const responseCode = message.responseCode\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // The message returned an error. The message body may contain additional information about an error.\r\n      requestInfo.reject(message)\r\n    } else {\r\n      // Request was processed without errors\r\n      requestInfo.resolve(message)\r\n    }\r\n    this._messages.delete(message.requestID) // Remove request info from the map\r\n  }\r\n\r\n  /**\r\n   * Registers an outgoing request within a request map. Returns a promise that will be fulfilled when\r\n   * a response will be received or rejected when a timeout will expire.\r\n   *\r\n   * @param {RequestMessage} request - An outgoing request.\r\n   * @param {number} timeout - A number of milliseconds we'll wait for response before rejecting a promise.\r\n   * @returns {Promise} - A promise that will be resolved with the message response or rejected with an error info.\r\n   */\r\n  registerRequest (request, timeout = 10000) {\r\n    if (this._messages.has(request.ID)) throw new Error(`Request with ${request.ID} ID is already registered`)\r\n    let storedRequest = new StoredRequest(request) // eslint-disable-line prefer-const\r\n    this._messages.set(request.ID, storedRequest)\r\n    storedRequest.timeoutID = window.setTimeout((requestID) => {\r\n      storedRequest.reject(new Error(`Timeout has been expired for a message with request ID ${request.ID}`))\r\n      this._messages.delete(requestID) // Remove request record from the map\r\n    }, timeout)\r\n    return storedRequest.promise\r\n  }\r\n\r\n  /**\r\n   * Sends a request message to a specific destination.\r\n   *\r\n   * @param {string} destName - A name of a destination where request will be sent to.\r\n   * @param {RequestMessage} request - A request message to be sent.\r\n   * @param {number} timeout - How many milliseconds to wait for a response.\r\n   * @returns {Promise<ResponseMessage> | Promise<Error> | Promise<object>} - A promise either resolved\r\n   *          with response message or rejected with the error info.\r\n   */\r\n  sendRequestTo (destName, request, timeout = 10000) {\r\n    if (!destName) {\r\n      throw new Error('Destination name is not provided')\r\n    }\r\n\r\n    if (!this._destinations.has(destName)) {\r\n      throw new Error(`Unknown destination ${destName}`)\r\n    }\r\n\r\n    try {\r\n      this._destinations.get(destName).sendRequest(request)\r\n    } catch (err) {\r\n      throw new Error(`Request to ${destName} failed: ${err.message}`)\r\n    }\r\n    // Do not register request before we're sure that the message is sent successfully.\r\n    return this.registerRequest(request, timeout)\r\n  }\r\n}\r\n\r\nMessagingService.errMsgs = {\r\n  NO_NAME: 'MessagingService must be created with a name'\r\n}\r\n","/**\r\n * @module StoredRequest\r\n */\r\n\r\n/** Stores information about request being sent via the messaging service */\r\nexport default class StoredRequest {\r\n  constructor () {\r\n    /**\r\n     * A function to resolve the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.resolve = null\r\n\r\n    /**\r\n     * A function to reject the request's promise.\r\n     *\r\n     * @type {Function}\r\n     */\r\n    this.reject = null\r\n\r\n    // A promise that will be resolved or rejected when the response will arrive or the timeout will expire\r\n    this.promise = new Promise(this.executor.bind(this))\r\n  }\r\n\r\n  executor (resolve, reject) {\r\n    this.resolve = resolve\r\n    this.reject = reject\r\n  }\r\n}\r\n","/**\r\n * @module Destination\r\n */\r\n\r\n/** Destination represents a place where messages are sent to and are received from (e.g. a windows) */\r\nexport default class Destination {\r\n  /**\r\n   * Creates an instance of a Destination object. Descendants may take configuration parameters through\r\n   * a second argument that they can define.\r\n   *\r\n   * @param {object} [configuration={}] - A configuration object for a destination.\r\n   * @param {string} configuration.name - A name of a particular destination.\r\n   * @param {string[]} configuration.commModes - A list of communication modes that should be enabled for\r\n   *        a destination. A list of available modes is defined in Destination.commModes.\r\n   *        Defaults to a SEND mode.\r\n   */\r\n  constructor ({ name, commModes = [Destination.commModes.SEND] } = {}) {\r\n    if (!name) {\r\n      throw new Error('Destination name is missing')\r\n    }\r\n\r\n    /**\r\n     * A name of a destination. Used to refer to it within a messaging service.\r\n     *\r\n     * @type {string}\r\n     * @public\r\n     */\r\n    this.name = name\r\n\r\n    /**\r\n     * An array of communication modes that are enabled for a destination.\r\n     *\r\n     * @type {string[]}\r\n     * @public\r\n     */\r\n    this.commModes = commModes\r\n\r\n    /**\r\n     * A function that will be called when a response from destination is received.\r\n     *\r\n     * @type {Function}\r\n     * @private\r\n     */\r\n    this._responseCallback = null\r\n  }\r\n\r\n  /**\r\n   * Checks if a SEND communication mode is enabled for this destination.\r\n   *\r\n   * @returns {boolean} True if destination is in the SEND mode.\r\n   */\r\n  get ableToSend () {\r\n    return this.commModes.includes(Destination.commModes.SEND)\r\n  }\r\n\r\n  /**\r\n   * Checks if a RECEIVE communication mode is enabled for this destination.\r\n   *\r\n   * @returns {boolean} True if destination is in the RECEIVE mode.\r\n   */\r\n  get ableToReceive () {\r\n    return this.commModes.includes(Destination.commModes.RECEIVE)\r\n  }\r\n\r\n  /**\r\n   * This function will be called by the messaging service when a destination is deregistered or deleted.\r\n   * It must do a cleanup necessary for a destination object. Its functionality should be defined within a subclass.\r\n   */\r\n  deregister () {\r\n    throw new Error('Deregister method must be defined in a subclass')\r\n  }\r\n}\r\n\r\n/*\r\nA list of communication modes that a destination can support.\r\n */\r\nDestination.commModes = {\r\n  /*\r\n  If a SEND mode is enabled, this destination can send messages to other destinations of the same type.\r\n   */\r\n  SEND: 'Send',\r\n\r\n  /*\r\n  A RECEIVE mode enables destination to receive messages from other destinations of the same type.\r\n   */\r\n  RECEIVE: 'Receive'\r\n}\r\n","/**\r\n * @module WindowIframeDestination\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport Destination from '@messServ/destinations/destination.js'\r\n\r\n/** WindowIframeDestination represents a content window within an iframe */\r\nexport default class WindowIframeDestination extends Destination {\r\n  /**\r\n   * @param {object} [configuration={}] - An object containing configuration parameters.\r\n   * @param {string} configuration.name - A name of a destination (for addressing a destination in a messaging service).\r\n   * @param {string} configuration.targetURL - A URL of a document within an iframe where messages will be sent.\r\n   * @param {string} configuration.targetIframeID - An ID of an iframe element (without `#`).\r\n   * @param {string[]} configuration.commModes - A list of communication modes that should be enabled for\r\n   *        a destination. A list of available modes is defined in Destination.commModes.\r\n   * @param {Function} configuration.receiverCB - A function that will be called when destination is in the\r\n   *        RECEIVE mode and the incoming request has arrived. This function will receive two parameters:\r\n   *        the message object and the function that will need to be called in order to send a response back.\r\n   */\r\n  constructor ({ name, targetURL, targetIframeID, commModes, receiverCB } = {}) {\r\n    super({ name, commModes })\r\n\r\n    if (!targetURL) {\r\n      throw new Error('Target URL is not provided')\r\n    }\r\n\r\n    if (!targetIframeID) {\r\n      throw new Error('Target iframe ID is not provided')\r\n    }\r\n\r\n    /**\r\n     * A URL of a document within an iframe where messages will be sent.\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetURL = targetURL\r\n\r\n    /**\r\n     * An ID of an iframe element (without `#`).\r\n     *\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    this._targetIframeID = targetIframeID\r\n\r\n    if (this.ableToReceive) {\r\n      // Destination is initialized in the receive mode\r\n      if (!receiverCB) {\r\n        throw new Error('A receiver callback must be provided for a destination in the RECEIVE communication mode')\r\n      }\r\n      this._registeredRequestHandler = this._requestHandler.bind(this, receiverCB)\r\n      window.addEventListener('message', this._registeredRequestHandler, false)\r\n    }\r\n\r\n    // The following two props will keep track of request and response handlers registered for this destination.\r\n    this._registeredRequestHandler = null\r\n    this._registeredResponseHandler = null\r\n  }\r\n\r\n  /**\r\n   * Registers a function to call when a response from destination is received.\r\n   *\r\n   * @param {Function} callbackFn - A function to be called when response is received.\r\n   */\r\n  registerResponseCallback (callbackFn) {\r\n    this._registeredResponseHandler = this._responseHandler.bind(this)\r\n    window.addEventListener('message', this._registeredResponseHandler, false)\r\n    this._responseCallback = callbackFn\r\n  }\r\n\r\n  /**\r\n   * A function that will be called to send a request from origin to destination.\r\n   *\r\n   * @param {RequestMessage} requestMessage - A request message object.\r\n   */\r\n  sendRequest (requestMessage) {\r\n    const iframe = document.querySelector(`#${this._targetIframeID}`)\r\n    if (!iframe) {\r\n      throw new Error(`An #${this._targetIframeID} iframe does not exist in the document`)\r\n    }\r\n    const iframeWindow = iframe.contentWindow\r\n\r\n    /*\r\n    If we'll try to send a message to an iframe which content would not been loaded yet,\r\n    `postMessage` will throw an error. It will be impossible, however, to catch this error here because `postMessage`\r\n    executes asynchronously (please see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).\r\n    Once the cross-origin iframe content became available, it will throw a DOM security exception\r\n    if we try to access its `location` prop. We can use that to check whether an iframe content is loaded\r\n    before trying to send a message to it.\r\n     */\r\n    let contentNotLoaded = false\r\n    try {\r\n      contentNotLoaded = iframeWindow.location.href === 'about:blank'\r\n    } catch (err) {\r\n      if (err instanceof DOMException) {\r\n        // Do nothing. This error usually means that a cross-origin iframe content has become available.\r\n      } else {\r\n        // Re-throw an error\r\n        throw err\r\n      }\r\n    }\r\n\r\n    if (contentNotLoaded) {\r\n      // If we can access a target iframe location and its URL is blank it means an iframe content is not loaded yet.\r\n      throw new Error(`Target document ${this._targetURL} is not loaded yet`)\r\n    }\r\n    try {\r\n      iframeWindow.postMessage(requestMessage, this._targetURL)\r\n    } catch (err) {\r\n      if (err instanceof DOMException && err.name === 'DataCloneError') {\r\n        /*\r\n        A message body does not confirm the structured clone algorithm and thus cannot be send via `postMessage`.\r\n        See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n        for more details.\r\n        We'll try to convert it to a plain object.\r\n         */\r\n        console.warn('Request that does not confirm to the structured clone algorithm cannot be sent, ' +\r\n          'will try to convert it to a plain object and send again')\r\n        requestMessage.body = WindowIframeDestination._toPostable(requestMessage.body)\r\n        // Try to resend a message\r\n        iframeWindow.postMessage(requestMessage, this._targetURL)\r\n      } else {\r\n        // Some other error occurred, rethrow it\r\n        throw err\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A function that is used to send a response from destination to origin.\r\n   *\r\n   * @param {ResponseMessage} responseMessage - A response message object.\r\n   */\r\n  sendResponse (responseMessage) {\r\n    try {\r\n      window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n    } catch (err) {\r\n      if (err instanceof DOMException && err.name === 'DataCloneError') {\r\n        /*\r\n        A message body does not confirm the structured clone algorithm and thus cannot be send via `postMessage`.\r\n        See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n        for more details.\r\n        We'll try to convert it to a plain object.\r\n         */\r\n        console.warn('Response that does not confirm to the structured clone algorithm cannot be sent, ' +\r\n                     'will try to convert it to a plain object and send again')\r\n        responseMessage.body = WindowIframeDestination._toPostable(responseMessage.body)\r\n        // Try to resend a message\r\n        window.parent.postMessage(responseMessage, responseMessage.requestHeader.origin)\r\n      } else {\r\n        // Some other error occurred, rethrow it\r\n        throw err\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when request arrives to its destination.\r\n   *\r\n   * @param {Function} callbackFn - A client's callback function that will be called and\r\n   *                                passed a request (a `RequestMessage` object).\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _requestHandler (callbackFn, event) {\r\n    // Check if an event contains a valid Alpheios message object.\r\n    if (!WindowIframeDestination._isSupportedEvent(event)) { return }\r\n\r\n    // `data` prop of an event contains a request message object\r\n    let request = event.data // eslint-disable-line prefer-const\r\n    request.header.origin = event.origin\r\n    callbackFn(request, this.sendResponse.bind(this))\r\n  }\r\n\r\n  /**\r\n   * An internal handler that is called when response arrives from destination to origin.\r\n   *\r\n   * @param {Event} event - A browser's event object.\r\n   * @private\r\n   */\r\n  _responseHandler (event) {\r\n    // Check if an event contains a valid Alpheios message object.\r\n    if (!WindowIframeDestination._isSupportedEvent(event)) { return }\r\n\r\n    // `data` prop of an event contains a response message object\r\n    const responseMessage = event.data\r\n    if (this._responseCallback) {\r\n      this._responseCallback(responseMessage)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks whether an event contains a well-formed Alpheios message object.\r\n   *\r\n   * @param {Event} event - An event that may contain a message object in a `data` field.\r\n   * @returns {boolean} - True if an event contains a well-formed Alpheios message object, false otherwise.\r\n   * @private\r\n   */\r\n  static _isSupportedEvent (event) {\r\n    return Boolean(event && event.data && event.data.type && Message.isKnownType(event.data.type))\r\n  }\r\n\r\n  /**\r\n   * This function will be called by the messaging service when destination is deregistered or deleted.\r\n   * It must do a cleanup for a destination object.\r\n   */\r\n  deregister () {\r\n    // Remove event listeners for registered request and response handlers\r\n    if (this._registeredResponseHandler) {\r\n      window.removeEventListener('message', this._registeredResponseHandler, false)\r\n      this._registeredResponseHandler = null\r\n    }\r\n    if (!this._registeredRequestHandler) {\r\n      window.removeEventListener('message', this._registeredRequestHandler, false)\r\n      this._registeredRequestHandler = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts an object to the one that is conforms the structured clone algorithm.\r\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\r\n   * for more details.\r\n   *\r\n   * @param {object} message - An object to convert.\r\n   * @returns {object} - An object that conforms to the structured clone algorithm.\r\n   * @private\r\n   */\r\n  static _toPostable (message) {\r\n    let postable\r\n    if (message instanceof Error) {\r\n      /*\r\n      Due to the bug in FF, Errors cannot be sent via postMessage yet.\r\n      Please see https://bugzilla.mozilla.org/show_bug.cgi?id=1556604 for more details.\r\n      This code can be removed once the bug is fixed.\r\n       */\r\n      postable = {\r\n        name: message.name,\r\n        message: message.message\r\n      }\r\n    } else {\r\n      postable = JSON.parse(JSON.stringify(message))\r\n    }\r\n    return postable\r\n  }\r\n}\r\n","/**\r\n * @module Message\r\n */\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\n/** A base class for all types of messages */\r\nexport default class Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    /**\r\n     * A message's role (@see {@link Message.roles}). Will be defined in descendants.\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.role = undefined\r\n\r\n    /**\r\n     * A type of the message. Used to distinguish one kind of message from the other (@see {@link Message.types}).\r\n     *\r\n     * @type {string | undefined}\r\n     */\r\n    this.type = Message.types.GENERIC\r\n\r\n    /**\r\n     * A unique identifier of the message.\r\n     *\r\n     * @type {string}\r\n     */\r\n    this.ID = uuidv4()\r\n\r\n    /**\r\n     * An object with no methods representing a message body.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.body = body\r\n  }\r\n\r\n  static isKnownType (typeValue) {\r\n    return Object.values(Message.types).includes(typeValue)\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a message is request or response.\r\n */\r\nMessage.roles = {\r\n  REQUEST: 'Request',\r\n  RESPONSE: 'Response'\r\n}\r\n\r\n/**\r\n * Specifies a message type: what kind of message it is and what purpose it serves.\r\n * Message types are used to distinguish different types of messages from each other\r\n * and to distinguish Alpheios from non-Alpheios messages. All Alpheios messages\r\n * must start from an `ALPHEIOS_` prefix.\r\n */\r\nMessage.types = {\r\n  GENERIC: 'ALPHEIOS_MESSAGE' // A generic message of general purpose\r\n}\r\n","/**\r\n * @module RequestMessage\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\n\r\n/** A request message */\r\nexport default class RequestMessage extends Message {\r\n  /**\r\n   * @param {object} [body={}] - A plain JS object (with no methods) representing a body of the message.\r\n   */\r\n  constructor (body = {}) {\r\n    super(body)\r\n    this.role = Message.roles.REQUEST\r\n\r\n    /**\r\n     * A message header. Will contain routing information usually.\r\n     *\r\n     * @type {object}\r\n     */\r\n    this.header = {}\r\n  }\r\n}\r\n","/**\r\n * @module ResponseMessage\r\n */\r\nimport Message from '@messServ/messages/message.js'\r\nimport RequestMessage from '@messServ/messages/request-message.js'\r\n\r\n/** A response message that is sent as an answer to the request message. */\r\nexport default class ResponseMessage extends Message {\r\n  /**\r\n   * @param {RequestMessage} request - A request that initiated this response. Used to copy routing information mostly.\r\n   * @param {object} [body={}] - A body of the response, a plain JS object with no methods.\r\n   * @param {string} responseCode - A code to indicate results of the request handling: Success, Failure, etc.\r\n   * @param {object} options - Additional non-obligatory parameters:\r\n   * @param {number} options.errorCode - An error code indicating why request has failed.\r\n   */\r\n  constructor (request, body = {}, responseCode = ResponseMessage.responseCodes.UNDEFINED, { errorCode } = {}) {\r\n    super(body)\r\n    if (!request) throw new Error('Request is not provided')\r\n    if (!request.ID) throw new Error('Request has no ID')\r\n    this.role = Message.roles.RESPONSE\r\n    this.requestHeader = request.header || {}\r\n    this.requestID = request.ID // ID of the request to match request and response\r\n    this.responseCode = responseCode\r\n\r\n    /**\r\n     * If request failed this prop will contain an error code indicating the reason of the failure.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.errorCode = 0\r\n\r\n    if (responseCode === ResponseMessage.responseCodes.ERROR) {\r\n      // Request has failed. An error code must be provided.\r\n      if (!errorCode) {\r\n        throw new Error('An error code must be provided for failed requests')\r\n      }\r\n      this.errorCode = errorCode\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A builder for a response message with a SUCCESS response code.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {object} [body={}] - A body of response message.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Success (request, body = {}) {\r\n    return new this(request, body, ResponseMessage.responseCodes.SUCCESS)\r\n  }\r\n\r\n  /**\r\n   * A builder for a message with an ERROR response code. Error information will be sent within the message body.\r\n   *\r\n   * @param {RequestMessage} request - An original request.\r\n   * @param {Error} error - An error object containing error information.\r\n   * @param {number} errorCode - An error code indicating why a request failed.\r\n   * @returns {ResponseMessage} - A newly created response message with the SUCCESS return code.\r\n   * @class\r\n   */\r\n  static Error (request, error, errorCode) {\r\n    return new this(request, error, ResponseMessage.responseCodes.ERROR, { errorCode })\r\n  }\r\n\r\n  /**\r\n   * Checks if this message is a response (i.e. if it follows a response message format and conventions).\r\n   *\r\n   * @param {RequestMessage | ResponseMessage} message - A request or response message to be tested.\r\n   * @returns {boolean} - True if the message is a response, false otherwise.\r\n   */\r\n  static isResponse (message) {\r\n    return message.role &&\r\n      message.role === Message.roles.RESPONSE &&\r\n      message.requestHeader &&\r\n      message.requestID\r\n  }\r\n}\r\n\r\n/**\r\n * Specifies whether a request was processed successfully or not.\r\n */\r\nResponseMessage.responseCodes = {\r\n  // Request was processed successfully.\r\n  // In this case a message body may contain a response data object or be empty.\r\n  SUCCESS: 'Success',\r\n\r\n  // There is no information about what was the outcome of a request.\r\n  UNDEFINED: 'Undefined',\r\n\r\n  // Request failed. A message will contain information about an error.\r\n  ERROR: 'Error'\r\n}\r\n\r\n/**\r\n * If request failed, the error code will be used to indicate the reason of a failure.\r\n */\r\nResponseMessage.errorCodes = {\r\n  // A remote service has not been initialized yet\r\n  SERVICE_UNINITIALIZED: 1,\r\n  // An error occurred during initialization of a remote service\r\n  INITIALIZATION_ERROR: 2,\r\n  // Request of unknown type is received by a remote service\r\n  UNKNOWN_REQUEST: 3,\r\n  // An unspecified error has occurred inside a remote service\r\n  INTERNAL_ERROR: 4\r\n}\r\n","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar pkg = require('./../../package.json');\nvar createError = require('../core/createError');\nvar enhanceError = require('../core/enhanceError');\n\nvar isHttps = /https:?/;\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var resolve = function resolve(value) {\n      resolvePromise(value);\n    };\n    var reject = function reject(value) {\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n\n    // Set User-Agent (required by some servers)\n    // Only set header if it hasn't been set in config\n    // See https://github.com/axios/axios/issues/69\n    if (!headers['User-Agent'] && !headers['user-agent']) {\n      headers['User-Agent'] = 'axios/' + pkg.version;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(createError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers['Content-Length'] = data.length;\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth) {\n      delete headers.Authorization;\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' &&\n                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.hostname = proxy.host;\n      options.host = proxy.host;\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      options.port = proxy.port;\n      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;\n\n      // Basic proxy authorization\n      if (proxy.auth) {\n        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n        options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n      }\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxContentLength && config.maxContentLength > -1) {\n      options.maxBodyLength = config.maxContentLength;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n      switch (res.headers['content-encoding']) {\n      /*eslint default-case:0*/\n      case 'gzip':\n      case 'compress':\n      case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n        stream = (res.statusCode === 204) ? stream : stream.pipe(zlib.createUnzip());\n\n        // remove the content-encoding in order to not confuse downstream operations\n        delete res.headers['content-encoding'];\n        break;\n      }\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              config, null, lastRequest));\n          }\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          var responseData = Buffer.concat(responseBuffer);\n          if (config.responseType !== 'arraybuffer') {\n            responseData = responseData.toString(config.responseEncoding);\n          }\n\n          response.data = responseData;\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted) return;\n      reject(enhanceError(err, config, null, req));\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(config.timeout, function handleRequestTimeout() {\n        req.abort();\n        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));\n      });\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(cancel);\n      });\n    }\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(enhanceError(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',\n    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath'\n  ];\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {\n    if (utils.isObject(config2[prop])) {\n      config[prop] = utils.deepMerge(config1[prop], config2[prop]);\n    } else if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (utils.isObject(config1[prop])) {\n      config[prop] = utils.deepMerge(config1[prop]);\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys);\n\n  var otherKeys = Object\n    .keys(config2)\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Function equal to merge with the difference being that no reference\n * to original objects is kept.\n *\n * @see merge\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction deepMerge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = deepMerge(result[key], val);\n    } else if (typeof val === 'object') {\n      result[key] = deepMerge({}, val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  deepMerge: deepMerge,\n  extend: extend,\n  trim: trim\n};\n","var url = require(\"url\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar assert = require(\"assert\");\nvar Writable = require(\"stream\").Writable;\nvar debug = require(\"debug\")(\"follow-redirects\");\n\n// RFC72314.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data and end\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC72316.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC72316.4: Automatic redirection needs to done with\n    // care for methods not known to be safe [],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC72316.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = require('supports-color');\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/* @license\nPapa Parse\nv5.2.0\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n\n(function(root, factory)\n{\n\t/* globals define */\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n\t// in strict mode we cannot access arguments.callee, so we need a named reference to\n\t// stringify the factory method for the blob worker\n\t// eslint-disable-next-line func-name\n}(this, function moduleFactory()\n{\n\t'use strict';\n\n\tvar global = (function() {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n\t\t// When running tests none of the above have been defined\n\t\treturn {};\n\t})();\n\n\n\tfunction getWorkerBlob() {\n\t\tvar URL = global.URL || global.webkitURL || null;\n\t\tvar code = moduleFactory.toString();\n\t\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob(['(', code, ')();'], {type: 'text/javascript'})));\n\t}\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /blob:/i.test((global.location || {}).protocol);\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.NODE_STREAM_INPUT = 1;\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tPapa.DuplexStreamStreamer = DuplexStreamStreamer;\n\t}\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t};\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\tif (isFunction(dynamicTyping)) {\n\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t// Will be filled on first row call\n\t\t\tdynamicTyping = {};\n\t\t}\n\t\t_config.dynamicTyping = dynamicTyping;\n\n\t\t_config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined')\n\t\t{\n\t\t\t// create a node Duplex stream for use\n\t\t\t// with .pipe\n\t\t\tstreamer = new DuplexStreamStreamer(_config);\n\t\t\treturn streamer.getStream();\n\t\t}\n\t\telse if (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character(s) */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\t/** escaped quote character, either \"\" or <config.escapeChar>\" */\n\t\tvar _escapedQuote = _quoteChar + _quoteChar;\n\n\t\t/** whether to skip empty lines */\n\t\tvar _skipEmptyLines = false;\n\n\t\t/** the columns (keys) we expect when we unparse objects */\n\t\tvar _columns = null;\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (Array.isArray(_input))\n\t\t{\n\t\t\tif (!_input.length || Array.isArray(_input[0]))\n\t\t\t\treturn serialize(null, _input, _skipEmptyLines);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(_columns || objectKeys(_input[0]), _input, _skipEmptyLines);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (Array.isArray(_input.data))\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  Array.isArray(_input.data[0])\n\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(Array.isArray(_input.data[0])) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow new Error('Unable to serialize unrecognized input');\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n                && !Papa.BAD_DELIMITERS.filter(function(value) { return _config.delimiter.indexOf(value) !== -1; }).length)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| typeof _config.quotes === 'function'\n\t\t\t\t|| Array.isArray(_config.quotes))\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.skipEmptyLines === 'boolean'\n\t\t\t\t|| typeof _config.skipEmptyLines === 'string')\n\t\t\t\t_skipEmptyLines = _config.skipEmptyLines;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\n\t\t\tif (Array.isArray(_config.columns)) {\n\n\t\t\t\tif (_config.columns.length === 0) throw new Error('Option columns is empty');\n\n\t\t\t\t_columns = _config.columns;\n\t\t\t}\n\n\t\t\tif (_config.escapeChar !== undefined) {\n\t\t\t\t_escapedQuote = _config.escapeChar + _quoteChar;\n\t\t\t}\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data, skipEmptyLines)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = Array.isArray(fields) && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(Array.isArray(data[0]));\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tvar emptyLine = false;\n\t\t\t\tvar nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n\t\t\t\tif (skipEmptyLines && !hasHeader)\n\t\t\t\t{\n\t\t\t\t\temptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n\t\t\t\t}\n\t\t\t\tif (skipEmptyLines === 'greedy' && hasHeader) {\n\t\t\t\t\tvar line = [];\n\t\t\t\t\tfor (var c = 0; c < maxCol; c++) {\n\t\t\t\t\t\tvar cx = dataKeyedByField ? fields[c] : c;\n\t\t\t\t\t\tline.push(data[row][cx]);\n\t\t\t\t\t}\n\t\t\t\t\temptyLine = line.join('').trim() === '';\n\t\t\t\t}\n\t\t\t\tif (!emptyLine)\n\t\t\t\t{\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0 && !nullLine)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\t\t\t\tif (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tif (str.constructor === Date)\n\t\t\t\treturn JSON.stringify(str).slice(1, 25);\n\n\t\t\tvar escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (typeof _quotes === 'function' && _quotes(str, col))\n\t\t\t\t\t\t\t|| (Array.isArray(_quotes) && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| escapedQuoteStr.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(0) === ' '\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._finished = false;\n\t\tthis._completed = false;\n\t\tthis._halted = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk, isFakeChunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\t\t\tthis._halted = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\tthis._halted = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk) && !isFakeChunk)\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\t\tthis._halted = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\t\t\tthis._completed = true;\n\t\t\t}\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open(this._config.downloadRequestBody ? 'POST' : 'GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send(this._config.downloadRequestBody);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t};\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState !== 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n\t\t\tthis._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t};\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(new Error(errorText));\n\t\t};\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn parseInt(contentRange.substring(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t};\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t};\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t};\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t};\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk;\n\t\t\tif(size) {\n\t\t\t\tchunk = remaining.substring(0, size);\n\t\t\t\tremaining = remaining.substring(size);\n\t\t\t} else {\n\t\t\t\tchunk = remaining;\n\t\t\t\tremaining = '';\n\t\t\t}\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t};\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\t\tvar streamHasEnded = false;\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.pause.apply(this, arguments);\n\t\t\tthis._input.pause();\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.resume.apply(this, arguments);\n\t\t\tthis._input.resume();\n\t\t};\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t};\n\n\t\tthis._checkIsFinished = function()\n\t\t{\n\t\t\tif (streamHasEnded && queue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tthis._checkIsFinished();\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis._checkIsFinished();\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tstreamHasEnded = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\tfunction DuplexStreamStreamer(_config) {\n\t\tvar Duplex = require('stream').Duplex;\n\t\tvar config = copy(_config);\n\t\tvar parseOnWrite = true;\n\t\tvar writeStreamHasFinished = false;\n\t\tvar parseCallbackQueue = [];\n\t\tvar stream = null;\n\n\t\tthis._onCsvData = function(results)\n\t\t{\n\t\t\tvar data = results.data;\n\t\t\tif (!stream.push(data) && !this._handle.paused()) {\n\t\t\t\t// the writeable consumer buffer has filled up\n\t\t\t\t// so we need to pause until more items\n\t\t\t\t// can be processed\n\t\t\t\tthis._handle.pause();\n\t\t\t}\n\t\t};\n\n\t\tthis._onCsvComplete = function()\n\t\t{\n\t\t\t// node will finish the read stream when\n\t\t\t// null is pushed\n\t\t\tstream.push(null);\n\t\t};\n\n\t\tconfig.step = bindFunction(this._onCsvData, this);\n\t\tconfig.complete = bindFunction(this._onCsvComplete, this);\n\t\tChunkStreamer.call(this, config);\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t\tif (parseCallbackQueue.length) {\n\t\t\t\tparseCallbackQueue.shift()();\n\t\t\t} else {\n\t\t\t\tparseOnWrite = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._addToParseQueue = function(chunk, callback)\n\t\t{\n\t\t\t// add to queue so that we can indicate\n\t\t\t// completion via callback\n\t\t\t// node will automatically pause the incoming stream\n\t\t\t// when too many items have been added without their\n\t\t\t// callback being invoked\n\t\t\tparseCallbackQueue.push(bindFunction(function() {\n\t\t\t\tthis.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n\t\t\t\tif (isFunction(callback)) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tif (parseOnWrite) {\n\t\t\t\tparseOnWrite = false;\n\t\t\t\tthis._nextChunk();\n\t\t\t}\n\t\t};\n\n\t\tthis._onRead = function()\n\t\t{\n\t\t\tif (this._handle.paused()) {\n\t\t\t\t// the writeable consumer can handle more data\n\t\t\t\t// so resume the chunk parsing\n\t\t\t\tthis._handle.resume();\n\t\t\t}\n\t\t};\n\n\t\tthis._onWrite = function(chunk, encoding, callback)\n\t\t{\n\t\t\tthis._addToParseQueue(chunk, callback);\n\t\t};\n\n\t\tthis._onWriteComplete = function()\n\t\t{\n\t\t\twriteStreamHasFinished = true;\n\t\t\t// have to write empty string\n\t\t\t// so parser knows its done\n\t\t\tthis._addToParseQueue('');\n\t\t};\n\n\t\tthis.getStream = function()\n\t\t{\n\t\t\treturn stream;\n\t\t};\n\t\tstream = new Duplex({\n\t\t\treadableObjectMode: true,\n\t\t\tdecodeStrings: false,\n\t\t\tread: bindFunction(this._onRead, this),\n\t\t\twrite: bindFunction(this._onWrite, this)\n\t\t});\n\t\tstream.once('finish', bindFunction(this._onWriteComplete, this));\n\t}\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tDuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tDuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n\t}\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar MAX_FLOAT = Math.pow(2, 53);\n\t\tvar MIN_FLOAT = -MAX_FLOAT;\n\t\tvar FLOAT = /^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)(e[-+]?\\d+)?\\s*$/;\n\t\tvar ISO_DATE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _rowCounter = 0;\t// Number of rows that have been parsed so far\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse {\n\t\t\t\t\t\t_results.data = _results.data[0];\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tvar quoteChar = _config.quoteChar || '\"';\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input, quoteChar);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\n\t\t\t// If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n\t\t\t// otherwise we can get duplicate content within a row\n\t\t\t_input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tif(self.streamer._halted) {\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input, true);\n\t\t\t} else {\n\t\t\t\t// Bugfix: #636 In case the processing hasn't halted yet\n\t\t\t\t// wait for it to halt in order to resume\n\t\t\t\tsetTimeout(self.resume, 3);\n\t\t\t}\n\t\t};\n\n\t\tthis.aborted = function()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction testEmptyLine(s) {\n\t\t\treturn _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n\t\t}\n\n\t\tfunction testFloat(s) {\n\t\t\tif (FLOAT.test(s)) {\n\t\t\t\tvar floatValue = parseFloat(s);\n\t\t\t\tif (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\'' + Papa.DefaultDelimiter + '\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (testEmptyLine(_results.data[i]))\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTypingAndTransformation();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\n\t\t\tfunction addHeder(header)\n\t\t\t{\n\t\t\t\tif (isFunction(_config.transformHeader))\n\t\t\t\t\theader = _config.transformHeader(header);\n\n\t\t\t\t_fields.push(header);\n\t\t\t}\n\n\t\t\tif (Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\t_results.data[i].forEach(addHeder);\n\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\t\t// if _results.data[0] is not an array, we are in a step where _results.data is the row.\n\t\t\telse\n\t\t\t\t_results.data.forEach(addHeder);\n\t\t}\n\n\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t// Cache function values to avoid calling it for each row\n\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t}\n\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse if (testFloat(value))\n\t\t\t\t\treturn parseFloat(value);\n\t\t\t\telse if (ISO_DATE.test(value))\n\t\t\t\t\treturn new Date(value);\n\t\t\t\telse\n\t\t\t\t\treturn (value === '' ? null : value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTypingAndTransformation()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))\n\t\t\t\treturn _results;\n\n\t\t\tfunction processRow(rowSource, i)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < rowSource.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = rowSource[j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tif (_config.transform)\n\t\t\t\t\t\tvalue = _config.transform(value,field);\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t}\n\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\tvar incrementBy = 1;\n\t\t\tif (!_results.data.length || Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\t_results.data = _results.data.map(processRow);\n\t\t\t\tincrementBy = _results.data.length;\n\t\t\t}\n\t\t\telse\n\t\t\t\t_results.data = processRow(_results.data, 0);\n\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\n\t\t\t_rowCounter += incrementBy;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n\n\t\t\tdelimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n\t\t\tfor (var i = 0; i < delimitersToGuess.length; i++) {\n\t\t\t\tvar delim = delimitersToGuess[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tcomments: comments,\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++) {\n\t\t\t\t\tif (skipEmptyLines && testEmptyLine(preview.data[j])) {\n\t\t\t\t\t\temptyLinesCount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined') {\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 0) {\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta <= bestDelta)\n\t\t\t\t\t&& (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\tmaxFieldCount = avgFieldCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t};\n\t\t}\n\n\t\tfunction guessLineEndings(input, quoteChar)\n\t\t{\n\t\t\tinput = input.substring(0, 1024 * 1024);\t// max length 1 MB\n\t\t\t// Replace all the text inside quotes\n\t\t\tvar re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n\t\t\tinput = input.replace(re, '');\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\tvar error = {\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg\n\t\t\t};\n\t\t\tif(row !== undefined) {\n\t\t\t\terror.row = row;\n\t\t\t}\n\t\t\t_results.errors.push(error);\n\t\t}\n\t}\n\n\t/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\n\tfunction escapeRegExp(string)\n\t{\n\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n\t}\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar;\n\t\t/** Allows for no quoteChar by setting quoteChar to undefined in config */\n\t\tif (config.quoteChar === undefined) {\n\t\t\tquoteChar = '\"';\n\t\t} else {\n\t\t\tquoteChar = config.quoteChar;\n\t\t}\n\t\tvar escapeChar = quoteChar;\n\t\tif (config.escapeChar !== undefined) {\n\t\t\tescapeChar = config.escapeChar;\n\t\t}\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow new Error('Comment character same as delimiter');\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow new Error('Input must be a string');\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\trow = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substring(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n\t\t\tvar quoteSearch = input.indexOf(quoteChar, cursor);\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tquoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\tif (quoteSearch === inputLen - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t// If the quote character is the escape character, then check if the next character is the escape character\n\t\t\t\t\t\tif (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the quote character is not the escape character, then check if the previous character was the escape character\n\t\t\t\t\t\tif (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(nextDelim !== -1 && nextDelim < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nextNewline !== -1 && nextNewline < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check up to nextDelim or nextNewline, whichever is closest\n\t\t\t\t\t\tvar checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n\t\t\t\t\t\tvar spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n\t\t\t\t\t\t// Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n\n\t\t\t\t\t\t\t// If char after following delimiter is not quoteChar, we find next quote char position\n\t\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n\t\t\t\t\t\t// Closing quote followed by newline or 'unnecessary spaces + newLine'\n\t\t\t\t\t\tif (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\t// we search for first quote in next line\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\t// we check, if we have quotes, because delimiter char may be part of field enclosed in quotes\n\t\t\t\t\tif (quoteSearch > nextDelim) {\n\t\t\t\t\t\t// we have quotes, so we try to find the next delimiter not enclosed in quotes and also next starting quote char\n\t\t\t\t\t\tvar nextDelimObj = getNextUnquotedDelimiter(nextDelim, quoteSearch, nextNewline);\n\n\t\t\t\t\t\t// if we have next delimiter char which is not enclosed in quotes\n\t\t\t\t\t\tif (nextDelimObj && typeof nextDelimObj.nextDelim !== 'undefined') {\n\t\t\t\t\t\t\tnextDelim = nextDelimObj.nextDelim;\n\t\t\t\t\t\t\tquoteSearch = nextDelimObj.quoteSearch;\n\t\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\t\t// we look for next delimiter char\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */\n\t\t\tfunction extraSpaces(index) {\n\t\t\t\tvar spaceLength = 0;\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tvar textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\t\t\t\t\tif (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n\t\t\t\t\t\tspaceLength = textBetweenClosingQuoteAndIndex.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn spaceLength;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substring(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [];\n\t\t\t\terrors = [];\n\t\t\t}\n\n\t\t\t/** Gets the delimiter character, which is not inside the quoted field */\n\t\t\tfunction getNextUnquotedDelimiter(nextDelim, quoteSearch, newLine) {\n\t\t\t\tvar result = {\n\t\t\t\t\tnextDelim: undefined,\n\t\t\t\t\tquoteSearch: undefined\n\t\t\t\t};\n\t\t\t\t// get the next closing quote character\n\t\t\t\tvar nextQuoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t// if next delimiter is part of a field enclosed in quotes\n\t\t\t\tif (nextDelim > quoteSearch && nextDelim < nextQuoteSearch && (nextQuoteSearch < newLine || newLine === -1)) {\n\t\t\t\t\t// get the next delimiter character after this one\n\t\t\t\t\tvar nextNextDelim = input.indexOf(delim, nextQuoteSearch);\n\n\t\t\t\t\t// if there is no next delimiter, return default result\n\t\t\t\t\tif (nextNextDelim === -1) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t// find the next opening quote char position\n\t\t\t\t\tif (nextNextDelim > nextQuoteSearch) {\n\t\t\t\t\t\tnextQuoteSearch = input.indexOf(quoteChar, nextQuoteSearch + 1);\n\t\t\t\t\t}\n\t\t\t\t\t// try to get the next delimiter position\n\t\t\t\t\tresult = getNextUnquotedDelimiter(nextNextDelim, nextQuoteSearch, newLine);\n\t\t\t\t} else {\n\t\t\t\t\tresult = {\n\t\t\t\t\t\tnextDelim: nextDelim,\n\t\t\t\t\t\tquoteSearch: quoteSearch\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\n\t\tvar workerUrl = getWorkerBlob();\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow new Error('Not implemented.');\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object' || obj === null)\n\t\t\treturn obj;\n\t\tvar cpy = Array.isArray(obj) ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","/* Copyright 2015 William Summers, MetaTribal LLC\n * adapted from https://developer.mozilla.org/en-US/docs/JXON\n *\n * Licensed under the MIT License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/MIT\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @author William Summers\n *\n */\n\nvar xmlToJSON = (function () {\n\n    this.version = \"1.3.5\";\n\n    var options = { // set up the default options\n        mergeCDATA: true, // extract cdata and merge with text\n        grokAttr: true, // convert truthy attributes to boolean, etc\n        grokText: true, // convert truthy text/attr to boolean, etc\n        normalize: true, // collapse multiple spaces to single space\n        xmlns: true, // include namespaces as attribute in output\n        namespaceKey: '_ns', // tag name for namespace objects\n        textKey: '_text', // tag name for text nodes\n        valueKey: '_value', // tag name for attribute values\n        attrKey: '_attr', // tag for attr groups\n        cdataKey: '_cdata', // tag for cdata nodes (ignored if mergeCDATA is true)\n        attrsAsObject: true, // if false, key is used as prefix to name, set prefix to '' to merge children and attrs.\n        stripAttrPrefix: true, // remove namespace prefixes from attributes\n        stripElemPrefix: true, // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property\n        childrenAsArray: true // force children into arrays\n    };\n\n    var prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n    var trimMatch = new RegExp(/^\\s+|\\s+$/g);\n\n    this.grokType = function (sValue) {\n        if (/^\\s*$/.test(sValue)) {\n            return null;\n        }\n        if (/^(?:true|false)$/i.test(sValue)) {\n            return sValue.toLowerCase() === \"true\";\n        }\n        if (isFinite(sValue)) {\n            return parseFloat(sValue);\n        }\n        return sValue;\n    };\n\n    this.parseString = function (xmlString, opt) {\n        return this.parseXML(this.stringToXML(xmlString), opt);\n    }\n\n    this.parseXML = function (oXMLParent, opt) {\n\n        // initialize options\n        for (var key in opt) {\n            options[key] = opt[key];\n        }\n\n        var vResult = {},\n            nLength = 0,\n            sCollectedTxt = \"\";\n\n        // parse namespace information\n        if (options.xmlns && oXMLParent.namespaceURI) {\n            vResult[options.namespaceKey] = oXMLParent.namespaceURI;\n        }\n\n        // parse attributes\n        // using attributes property instead of hasAttributes method to support older browsers\n        if (oXMLParent.attributes && oXMLParent.attributes.length > 0) {\n            var vAttribs = {};\n\n            for (nLength; nLength < oXMLParent.attributes.length; nLength++) {\n                var oAttrib = oXMLParent.attributes.item(nLength);\n                vContent = {};\n                var attribName = '';\n\n                if (options.stripAttrPrefix) {\n                    attribName = oAttrib.name.replace(prefixMatch, '');\n\n                } else {\n                    attribName = oAttrib.name;\n                }\n\n                if (options.grokAttr) {\n                    vContent[options.valueKey] = this.grokType(oAttrib.value.replace(trimMatch, ''));\n                } else {\n                    vContent[options.valueKey] = oAttrib.value.replace(trimMatch, '');\n                }\n\n                if (options.xmlns && oAttrib.namespaceURI) {\n                    vContent[options.namespaceKey] = oAttrib.namespaceURI;\n                }\n\n                if (options.attrsAsObject) { // attributes with same local name must enable prefixes\n                    vAttribs[attribName] = vContent;\n                } else {\n                    vResult[options.attrKey + attribName] = vContent;\n                }\n            }\n\n            if (options.attrsAsObject) {\n                vResult[options.attrKey] = vAttribs;\n            } else { }\n        }\n\n        // iterate over the children\n        if (oXMLParent.hasChildNodes()) {\n            for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {\n                oNode = oXMLParent.childNodes.item(nItem);\n\n                if (oNode.nodeType === 4) {\n                    if (options.mergeCDATA) {\n                        sCollectedTxt += oNode.nodeValue;\n                    } else {\n                        if (vResult.hasOwnProperty(options.cdataKey)) {\n                            if (vResult[options.cdataKey].constructor !== Array) {\n                                vResult[options.cdataKey] = [vResult[options.cdataKey]];\n                            }\n                            vResult[options.cdataKey].push(oNode.nodeValue);\n\n                        } else {\n                            if (options.childrenAsArray) {\n                                vResult[options.cdataKey] = [];\n                                vResult[options.cdataKey].push(oNode.nodeValue);\n                            } else {\n                                vResult[options.cdataKey] = oNode.nodeValue;\n                            }\n                        }\n                    }\n                } /* nodeType is \"CDATASection\" (4) */\n                else if (oNode.nodeType === 3) {\n                    sCollectedTxt += oNode.nodeValue;\n                } /* nodeType is \"Text\" (3) */\n                else if (oNode.nodeType === 1) { /* nodeType is \"Element\" (1) */\n\n                    if (nLength === 0) {\n                        vResult = {};\n                    }\n\n                    // using nodeName to support browser (IE) implementation with no 'localName' property\n                    if (options.stripElemPrefix) {\n                        sProp = oNode.nodeName.replace(prefixMatch, '');\n                    } else {\n                        sProp = oNode.nodeName;\n                    }\n\n                    vContent = xmlToJSON.parseXML(oNode);\n\n                    if (vResult.hasOwnProperty(sProp)) {\n                        if (vResult[sProp].constructor !== Array) {\n                            vResult[sProp] = [vResult[sProp]];\n                        }\n                        vResult[sProp].push(vContent);\n\n                    } else {\n                        if (options.childrenAsArray) {\n                            vResult[sProp] = [];\n                            vResult[sProp].push(vContent);\n                        } else {\n                            vResult[sProp] = vContent;\n                        }\n                        nLength++;\n                    }\n                }\n            }\n        } else if (!sCollectedTxt) { // no children and no text, return null\n            if (options.childrenAsArray) {\n                vResult[options.textKey] = [];\n                vResult[options.textKey].push(null);\n            } else {\n                vResult[options.textKey] = null;\n            }\n        }\n\n        if (sCollectedTxt) {\n            if (options.grokText) {\n                var value = this.grokType(sCollectedTxt.replace(trimMatch, ''));\n                if (value !== null && value !== undefined) {\n                    vResult[options.textKey] = value;\n                }\n            } else if (options.normalize) {\n                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '').replace(/\\s+/g, \" \");\n            } else {\n                vResult[options.textKey] = sCollectedTxt.replace(trimMatch, '');\n            }\n        }\n\n        return vResult;\n    }\n\n\n    // Convert xmlDocument to a string\n    // Returns null on failure\n    this.xmlToString = function (xmlDoc) {\n        try {\n            var xmlString = xmlDoc.xml ? xmlDoc.xml : (new XMLSerializer()).serializeToString(xmlDoc);\n            return xmlString;\n        } catch (err) {\n            return null;\n        }\n    }\n\n    // Convert a string to XML Node Structure\n    // Returns null on failure\n    this.stringToXML = function (xmlString) {\n        try {\n            var xmlDoc = null;\n\n            if (window.DOMParser) {\n\n                var parser = new DOMParser();\n                xmlDoc = parser.parseFromString(xmlString, \"text/xml\");\n\n                return xmlDoc;\n            } else {\n                xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n                xmlDoc.async = false;\n                xmlDoc.loadXML(xmlString);\n\n                return xmlDoc;\n            }\n        } catch (e) {\n            return null;\n        }\n    }\n\n    return this;\n}).call({});\n\nif (typeof module != \"undefined\" && module !== null && module.exports) module.exports = xmlToJSON;\nelse if (typeof define === \"function\" && define.amd) define(function () { return xmlToJSON });\n","import { LanguageModelFactory as LMF, LatinLanguageModel, GreekLanguageModel, ResourceProvider, Lexeme, Lemma, Feature, Inflection, Homonym } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/alpheiostb/config.json'\r\nimport xmlToJSON from 'xmltojson'\r\n\r\nclass AlpheiosTreebankAdapter extends BaseAdapter {\r\n  /**\r\n   * Treebank adapter uploads config data and fills model property\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.models = { lat: LatinLanguageModel, grc: GreekLanguageModel }\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} wordref - a word reference for getting homonym from Treebank\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, wordref) {\r\n    const server = this.prepareRequest(wordref)\r\n    if (!server.url) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_URL', { word: wordref }))\r\n      return\r\n    }\r\n    try {\r\n      const res = await this.fetch(server.url, { type: 'xml' })\r\n\r\n      if (res.constructor.name === 'AdapterError') {\r\n        return\r\n      }\r\n\r\n      if (res) {\r\n        const langCode = LMF.getLanguageCodeFromId(languageID)\r\n\r\n        const jsonObj = xmlToJSON.parseString(res)\r\n        jsonObj.words[0].word[0].entry[0].dict[0].hdwd[0]._attr = { lang: { _value: langCode } }\r\n\r\n        const homonym = this.transform(jsonObj, jsonObj.words[0].word[0].form[0]._text, server.config)\r\n        return homonym\r\n      } else {\r\n        this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_ANSWER_FOR_WORD', { word: wordref }))\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method prepares the request from the config\r\n   * @param {String} wordref - a word reference for getting homonym\r\n   * @return {String} - constructed url for getting data from Treebank\r\n  */\r\n  prepareRequest (wordref) {\r\n    const [text, fragment] = wordref.split(/#/)\r\n    let requestServer = {} // eslint-disable-line prefer-const\r\n    if (text && fragment) {\r\n      for (const serverConfig of this.config.servers) {\r\n        if (serverConfig.isDefault || serverConfig.texts.includes(text)) {\r\n          requestServer.config = serverConfig\r\n          requestServer.url = serverConfig.url.replace('r_TEXT', text)\r\n          requestServer.url = requestServer.url.replace('r_WORD', fragment).replace('r_CLIENT', serverConfig.clientId)\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return requestServer\r\n  }\r\n\r\n  /**\r\n   * This method transform data from adapter to Homonym\r\n   * @param {Object} jsonObj - data from adapter\r\n   * @param {String} targetWord - word\r\n   * @param {String} config - server config\r\n   * @return {Homonym}\r\n  */\r\n  transform (jsonObj, targetWord, config) {\r\n    'use strict'\r\n    const providerUri = config.providerUri\r\n    const providerRights = config.providerRights\r\n    const provider = new ResourceProvider(providerUri, providerRights)\r\n\r\n    const hdwd = jsonObj.words[0].word[0].entry[0].dict[0].hdwd[0]\r\n    let lemmaText = hdwd._text\r\n    // the Alpheios v1 treebank data kept trailing digits on the lemmas\r\n    // these won't match morphology service lemmas which have them stripped\r\n    lemmaText = lemmaText.replace(/\\d+$/, '')\r\n\r\n    const model = this.models[hdwd._attr.lang._value]\r\n    let lemma = new Lemma(lemmaText, model.languageCode) // eslint-disable-line prefer-const\r\n    const lexmodel = new Lexeme(lemma, [])\r\n    let inflection = new Inflection(lemmaText, model.languageID, null, null, null) // eslint-disable-line prefer-const\r\n    const infl = jsonObj.words[0].word[0].entry[0].infl[0]\r\n    inflection.addFeature(new Feature(Feature.types.fullForm, targetWord, model.languageID))\r\n\r\n    const features = config.featuresArray\r\n    for (const feature of features) {\r\n      const localName = feature[0]\r\n      const featureType = feature[1]\r\n      const addToLemma = feature[2]\r\n      if (infl[localName]) {\r\n        const obj = model.typeFeature(Feature.types[featureType]).createFeatures(infl[localName][0]._text, 1)\r\n        inflection.addFeature(obj)\r\n        if (addToLemma) {\r\n          lemma.addFeature(obj)\r\n        }\r\n      }\r\n    }\r\n    lexmodel.inflections = [inflection]\r\n    return new Homonym([ResourceProvider.getProxy(provider, lexmodel)], targetWord)\r\n  }\r\n}\r\n\r\nexport default AlpheiosTreebankAdapter\r\n","import BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport AlpheiosLexiconTransformer from '@clAdapters/transformers/alpheios-lexicon-transformer'\r\nimport { LanguageModelFactory, Constants, Feature } from 'alpheios-data-models'\r\nimport ImportData from '@clAdapters/transformers/import-morph-data.js'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/alpheiostb/config.json'\r\nimport {\r\n  MessagingService, WindowIframeDestination as Destination, RequestMessage, ResponseMessage\r\n} from 'alpheios-messaging/dist/dev/alpheios-messaging.js'\r\n\r\nclass ArethusaTreebankAdapter extends BaseAdapter {\r\n  /**\r\n   * Treebank adapter uploads config data and fills model property\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.engineSet = null\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n  }\r\n\r\n  getMessagingService (config) {\r\n    if (!MessagingService.hasService(config.name)) {\r\n      MessagingService.createService(config.name, new Destination(config))\r\n    }\r\n    return MessagingService.getService(config.name)\r\n  }\r\n\r\n  async _fetchArethusaData (targetURL, sentenceId, wordId) {\r\n    const config = this._getMessageConfig(targetURL)\r\n    const svc = this.getMessagingService(config)\r\n    const requestBodyNav = {\r\n      gotoSentence: { sentenceId: sentenceId }\r\n    }\r\n    const message = new RequestMessage(requestBodyNav)\r\n    await svc.sendRequestTo(config.name, message)\r\n    const requestBodyMorph = {\r\n      getMorph: {\r\n        sentenceId: sentenceId,\r\n        wordId: wordId\r\n      }\r\n    }\r\n    const responseMessage = await svc.sendRequestTo(config.name, new RequestMessage(requestBodyMorph))\r\n    return responseMessage.body\r\n  }\r\n\r\n  _getMessageConfig (targetURL) {\r\n    return {\r\n      name: targetURL,\r\n      targetURL: targetURL,\r\n      targetIframeID: 'alpheios-treebank-frame'\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method refreshes the view of the Arethusa application\r\n   */\r\n  async refreshView (provider) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const requestBody = { refreshView: { } }\r\n    let response\r\n    try {\r\n      response = await svc.sendRequestTo(config.name, new RequestMessage(requestBody))\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n      return\r\n    }\r\n    return response.body\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - the target word\r\n   * @param {String} provider - the domain which provides Arethusa\r\n   * @param {String} sentenceId - the identifier for the sentence\r\n   * @param {String} wordId - the identifier for the word\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, word, provider, sentenceId, wordId) {\r\n    try {\r\n      if (typeof sentenceId !== 'undefined' && typeof wordId !== 'undefined') {\r\n        const tbRes = await this._fetchArethusaData(provider, sentenceId, wordId)\r\n        if (!tbRes || Object.keys(tbRes).length === 0) {\r\n          this.addError(this.l10n.getMsg('MORPH_TREEBANK_NO_ANSWER_FOR_WORD', { word: word }))\r\n          return\r\n        }\r\n        const languageModel = LanguageModelFactory.getLanguageModel(languageID)\r\n        if (!languageModel) {\r\n          this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNSUPPORTED_LANGUAGE', { languageId: languageID.toString() }))\r\n          return\r\n        }\r\n        let mapper = new ImportData(languageModel, 'arethusa') // eslint-disable-line prefer-const\r\n        mapper.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n          if (propertyName === 'pers') {\r\n            propertyValue = propertyValue.replace('first person', Constants.ORD_1ST)\r\n            propertyValue = propertyValue.replace('second person', Constants.ORD_2ND)\r\n            propertyValue = propertyValue.replace('third person', Constants.ORD_3RD)\r\n          }\r\n          return [propertyValue]\r\n        })\r\n        const transformAdapter = new AlpheiosLexiconTransformer(this, mapper, 'arethusa')\r\n        const homonym = transformAdapter.transformData(tbRes, word)\r\n        // handle verb participles in a way consistent with the morpheus parser\r\n        // which reports the pofs of the lemma as verb and pofs of the inflection as verb participle\r\n        if (homonym && homonym.lexemes && homonym.lexemes.length === 1 &&\r\n           homonym.lexemes[0].lemma.features[Feature.types.part].value === Constants.POFS_VERB &&\r\n           homonym.lexemes[0].inflections.length === 1 &&\r\n           homonym.lexemes[0].inflections[0][Feature.types.mood].value === Constants.MOOD_PARTICIPLE) {\r\n          homonym.lexemes[0].inflections[0].addFeature(new Feature(Feature.types.part, Constants.POFS_VERB_PARTICIPLE, languageModel.languageID))\r\n        }\r\n        return homonym\r\n      } else {\r\n        this.addError(this.l10n.getMsg('MORPH_TREEBANK_MISSING_REF', { request: word }))\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_TREEBANK_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  async findWord (provider, word, prefix, suffix, sentenceId) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const gotoSentenceBody = {\r\n      gotoSentence: { sentenceId }\r\n    }\r\n    try {\r\n      await svc.sendRequestTo(config.name, new RequestMessage(gotoSentenceBody))\r\n      const findWordBody = { findWord: { sentenceId, word, prefix, suffix } }\r\n      const response = await svc.sendRequestTo(config.name, new RequestMessage(findWordBody))\r\n      return response.body\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n    }\r\n  }\r\n\r\n  async gotoSentence (provider, sentenceId, wordIds = []) {\r\n    const config = this._getMessageConfig(provider)\r\n    const svc = this.getMessagingService(config)\r\n    const gotoSentenceBody = {\r\n      gotoSentence: { sentenceId, wordIds }\r\n    }\r\n    try {\r\n      const response = await svc.sendRequestTo(config.name, new RequestMessage(gotoSentenceBody))\r\n      return response.body\r\n    } catch (response) {\r\n      if (response instanceof ResponseMessage) {\r\n        // This is an error from a treebank template app\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      } else {\r\n        // This is some other error\r\n        this.addError(response.message)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default ArethusaTreebankAdapter\r\n","import axios from 'axios'\r\nimport { Logger, L10n } from 'alpheios-data-models'\r\nimport AdapterError from '@clAdapters/errors/adapter-error'\r\nimport RemoteError from '@clAdapters/errors/remote-error.js'\r\n\r\nimport Locales from '@clAdapters/locales/locales.js'\r\nimport enUS from '@clAdapters/locales/en-us/messages.json'\r\nimport enGB from '@clAdapters/locales/en-gb/messages.json'\r\n\r\nclass BaseAdapter {\r\n  /**\r\n   * Every adapter has errors array and L10n property for localizing messages\r\n  */\r\n  constructor () {\r\n    this.errors = []\r\n    this.l10n = new L10n()\r\n      .addMessages(enUS, Locales.en_US)\r\n      .addMessages(enGB, Locales.en_GB)\r\n      .setLocale(Locales.en_US)\r\n  }\r\n\r\n  /**\r\n   * This method is used for adding error meassage with additional data\r\n   * @param {String} message  - message text for the error\r\n  */\r\n  addError (message) {\r\n    const error = new AdapterError(this.config.category, this.config.adapterName, this.config.method, message)\r\n    this.errors.push(error)\r\n  }\r\n\r\n  addRemoteError (errorCode, message) {\r\n    const error = new RemoteError(this.config.category, this.config.adapterName, this.config.method, errorCode, message)\r\n    this.errors.push(error)\r\n  }\r\n\r\n  /**\r\n   * This method is used for uploding config property from current properties and default properties\r\n   * @param {Object} config - properties with higher priority\r\n   * @param {Object} defaultConfig - default properties\r\n   * @return {Object} - configuration data\r\n  */\r\n  uploadConfig (config, defaultConfig) {\r\n    let configRes = {} // eslint-disable-line prefer-const\r\n    Object.keys(config).forEach(configKey => {\r\n      configRes[configKey] = config[configKey]\r\n    })\r\n\r\n    Object.keys(defaultConfig).forEach(configKey => {\r\n      if (configRes[configKey] === undefined) {\r\n        configRes[configKey] = defaultConfig[configKey]\r\n      }\r\n    })\r\n\r\n    return configRes\r\n  }\r\n\r\n  /**\r\n   * This method is used for creating timeout Promise\r\n   * @param {Number} ms - amount of ms for creation timeout\r\n   * @return {Promise}\r\n  */\r\n  timeout (ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms))\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using window.fetch\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   * @return {Object|String}\r\n  */\r\n  async fetchWindow (url, options = { type: 'json' }) {\r\n    if (url) {\r\n      try {\r\n        const response = await window.fetch(url)\r\n        if (!response.ok) {\r\n          this.addError(this.l10n.getMsg('BASIC_ADAPTER_URL_RESPONSE_FAILED', { statusCode: response.status, statusText: response.statusText }))\r\n          return\r\n        }\r\n        if (options.type === 'xml') {\r\n          return response.text()\r\n        } else {\r\n          return response.json()\r\n        }\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using window.fetch with timeout reject\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Promise}\r\n  */\r\n  fetchWindowTimeout (url, options) {\r\n    if (url) {\r\n      let didTimeOut = false\r\n      return new Promise((resolve, reject) => {\r\n        const timeout = setTimeout(() => {\r\n          didTimeOut = true\r\n          reject(new Error('Request timed out', url))\r\n        }, options.timeout)\r\n\r\n        window.fetch(url)\r\n          .then((response) => {\r\n            clearTimeout(timeout)\r\n            if (!didTimeOut) {\r\n              if (options.type === 'xml') {\r\n                resolve(response.text())\r\n              } else {\r\n                resolve(response.json())\r\n              }\r\n            }\r\n          })\r\n          .catch((err) => {\r\n            this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n            if (didTimeOut) return\r\n            reject(err)\r\n          })\r\n      })\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using axios\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Object|String}\r\n  */\r\n  async fetchAxios (url, options) {\r\n    if (url) {\r\n      try {\r\n        let res\r\n        if (options && options.timeout > 0) {\r\n          res = await axios.get(encodeURI(decodeURI(url)), { timeout: options.timeout })\r\n        } else {\r\n          res = await axios.get(encodeURI(decodeURI(url)))\r\n        }\r\n        return res.data\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_NO_DATA_FROM_URL', { url: url }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n\r\n  printError (error) {\r\n    if (error.response) {\r\n      // The request was made and the server responded with a status code\r\n      // that falls out of the range of 2xx\r\n      Logger.getInstance().error('Alpheios error: unexpected response retrieving data from service', error)\r\n    } else if (error.request) {\r\n      // The request was made but no response was received\r\n      // `error.request` is an instance of XMLHttpRequest in the browser and an instance of\r\n      // http.ClientRequest in node.js\r\n      Logger.getInstance().error('Alpheios error: no response from service', error)\r\n    } else {\r\n      // Something happened in setting up the request that triggered an Error\r\n      Logger.getInstance().error('Alpheios error: unexpected error requesting data from service', error.message)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method is used for fetching data using different methods. If window is defined - than it would be used window.fetch.\r\n   * Otherwise axios would be used.\r\n   * @param {String} url - url for fetching data\r\n   * @param {Object} options\r\n   *     @param {String} options.type - json is default, also it could be xml. This property defines output format.\r\n   *                                    xml - response.text(), otherwise - response.json()\r\n   *     @param {Number} options.timeout - timeout ms amount\r\n   * @return {Object|String}\r\n  */\r\n  async fetch (url, options) {\r\n    let res\r\n\r\n    if (url) {\r\n      try {\r\n        if (typeof window !== 'undefined' && typeof window.fetch !== 'undefined') {\r\n          if (options && options.timeout > 0) {\r\n            res = await this.fetchWindowTimeout(url, options)\r\n          } else {\r\n            res = await this.fetchWindow(url, options)\r\n          }\r\n        } else {\r\n          res = await this.fetchAxios(url, options)\r\n        }\r\n\r\n        return res\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('BASIC_ADAPTER_UNKNOWN_ERROR', { message: error.message }))\r\n      }\r\n    } else {\r\n      this.addError(this.l10n.getMsg('BASIC_ADAPTER_EMPTY_URL'))\r\n    }\r\n  }\r\n}\r\n\r\nexport default BaseAdapter\r\n","/* eslint-disable no-unused-vars */\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport { ChineseLanguageModel, Lemma, Lexeme, Homonym, Feature, Definition } from 'alpheios-data-models'\r\nimport {\r\n  MessagingService, WindowIframeDestination as Destination, CedictDestinationConfig as CedictConfig, RequestMessage\r\n} from 'alpheios-messaging'\r\n\r\nexport const CedictCharacterForms = {\r\n  SIMPLIFIED: 'simplified',\r\n  TRADITIONAL: 'traditional'\r\n}\r\n\r\nconst msgServiceName = 'AdaptersLexisService'\r\n\r\nclass AlpheiosChineseLocAdapter extends BaseAdapter {\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = config\r\n    this.cedictConfig = CedictConfig\r\n    if (!this.config.serviceUrl) {\r\n      throw new Error('An obligatory serviceUrl parameter is missing')\r\n    }\r\n    this.cedictConfig.targetURL = this.config.serviceUrl\r\n\r\n    /*\r\n    AlpheiosChineseLocAdapter is created every time when a new lexical request for Chinese data comes in.\r\n    We do not want to create a new instance of a messaging service with that. Thus, we'll use a single\r\n    instance of the service that will be created once and reused across consecutive constructor invocations.\r\n     */\r\n    if (!MessagingService.hasService(msgServiceName)) {\r\n      MessagingService.createService(msgServiceName, new Destination({\r\n        name: this.cedictConfig.name,\r\n        targetURL: this.cedictConfig.targetURL,\r\n        targetIframeID: this.cedictConfig.targetIframeID,\r\n        commModes: [Destination.commModes.SEND]\r\n      }))\r\n    }\r\n    this._messagingService = MessagingService.getService(msgServiceName)\r\n  }\r\n\r\n  get languageID () { return ChineseLanguageModel.languageID }\r\n\r\n  /**\r\n   * Creates a list of words that will be requested from a CEDICT service.\r\n   * This method builds a list of words that would make sense in a context of a Chinese language\r\n   * out of the word selected by user and its surrounding texts (context forward represents\r\n   * the text that is located at the right of the selected word.\r\n   *\r\n   * @param {string} targetWord - A word that was selected by the user.\r\n   * @param {string} contextForward - A piece of text that follows the selected word in a text.\r\n   * @returns {[string]} An array of words that will be requested from a CEDICT service.\r\n   * @private\r\n   */\r\n  static _buildWordList (targetWord, contextForward) {\r\n    const wordList = [targetWord]\r\n    if (contextForward) {\r\n      for (let i = 0; i < contextForward.length; i++) {\r\n        wordList.push(`${targetWord}${contextForward.slice(0, i + 1)}`)\r\n      }\r\n    }\r\n    return wordList\r\n  }\r\n\r\n  async getHomonym (targetWord, contextForward) {\r\n    try {\r\n      const requestBody = {\r\n        getWords: {\r\n          words: this.constructor._buildWordList(targetWord, contextForward)\r\n        }\r\n      }\r\n      let response\r\n      try {\r\n        response = await this._messagingService.sendRequestTo(this.cedictConfig.name, new RequestMessage(requestBody))\r\n      } catch (response) {\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n        return\r\n      }\r\n\r\n      if (Object.keys(response.body).length === 0) {\r\n        this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: targetWord, languageId: this.languageID.toString() }))\r\n        return\r\n      }\r\n      const homonym = this._transformData(response.body, targetWord)\r\n      if (!homonym) {\r\n        this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: targetWord, languageId: this.languageID.toString() }))\r\n        return\r\n      }\r\n      return homonym\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  async loadData (timeout) {\r\n    try {\r\n      const requestBody = {\r\n        loadData: {}\r\n      }\r\n      let response\r\n      try {\r\n        response = await this._messagingService.sendRequestTo(this.cedictConfig.name, new RequestMessage(requestBody), timeout)\r\n      } catch (response) {\r\n        this.addRemoteError(response.errorCode, response.body.message)\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  _transformData (cedictEntries, targetWord) {\r\n    // eslint-disable-next-line no-prototype-builtins\r\n    const characterForm = cedictEntries.hasOwnProperty(CedictCharacterForms.SIMPLIFIED)\r\n      ? CedictCharacterForms.SIMPLIFIED\r\n      : CedictCharacterForms.TRADITIONAL\r\n    let lexemes = [] // eslint-disable-line prefer-const\r\n    const wordEntries = Object.values(cedictEntries[characterForm]).flat()\r\n    wordEntries.forEach(entry => {\r\n      const cfData = entry[characterForm]\r\n      const headword = cfData.headword\r\n      let lemma = new Lemma(headword, this.languageID, []) // eslint-disable-line prefer-const\r\n\r\n      // eslint-disable-next-line prefer-const\r\n      let pronunciationValues = entry.pinyin ? [ChineseLanguageModel.formatPinyin(entry.pinyin)] : []\r\n      pronunciationValues = ['mandarin', 'cantonese', 'tang'].reduce((arr, i) => {\r\n        // Add all of the values listed above to an array or pronunciation feature. Each feature value will be preceded with its name.\r\n        // TODO: Update once we decide on a better format of storing pronunciation in a Feature object.\r\n        if (cfData[i]) arr.push(`${i} - ${cfData[i]}`); return arr\r\n      }, pronunciationValues)\r\n      lemma.addFeature(this._createFeature(Feature.types.pronunciation, pronunciationValues))\r\n      lemma.addFeature(this._createFeature(Feature.types.note, characterForm))\r\n      if (cfData.radical && cfData.radical.character) lemma.addFeature(this._createFeature(Feature.types.radical, cfData.radical.character))\r\n      if (cfData.frequency) lemma.addFeature(this._createFeature(Feature.types.frequency, cfData.frequency, 10))\r\n\r\n      let lexModel = new Lexeme(lemma, []) // eslint-disable-line prefer-const\r\n      const shortDefs = entry.definitions.map(entry => new Definition(entry, 'eng', 'text/plain', headword))\r\n      lexModel.meaning.appendShortDefs(shortDefs)\r\n      lexemes.push(lexModel)\r\n    })\r\n    let homonym = new Homonym(lexemes, targetWord) // eslint-disable-line prefer-const\r\n    /*\r\n    As a temporary measure, until HomonymSet is introduced, we will place several Chinese homonyms\r\n    into the single Homonym object as individual lexemes. We will use an `isMultiHomonym` prop set to true\r\n    to mark Homonym objects like this.\r\n     */\r\n    homonym.isMultiHomonym = AlpheiosChineseLocAdapter._wordsFound(cedictEntries[characterForm]) > 1\r\n    return homonym\r\n  }\r\n\r\n  /**\r\n   * Returns the number of words that has some matching CEDICT entries.\r\n   *\r\n   * @param {object} result - Data returned from CEDICT, an object whose keys are words and values are arrays\r\n   *        either empty (if no entries in CEDICT are found for a word) or containing CEDICT records.\r\n   * @returns {number} A number of words that has some matching CECIDT records.\r\n   * @private\r\n   */\r\n  static _wordsFound (result) {\r\n    return Object.keys(result).filter(key => result[key].length > 0).length\r\n  }\r\n\r\n  _createFeature (featureType, values) {\r\n    return new Feature(featureType, values, this.languageID)\r\n  }\r\n}\r\n\r\nexport default AlpheiosChineseLocAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/concordance/config.json'\r\nimport AuthorWorkConfigConfig from '@clAdapters/adapters/concordance/author-work.json'\r\n\r\nimport { ResourceProvider, Author, TextWork, WordUsageExample, LanguageModelFactory } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nclass AlpheiosConcordanceAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data and creates provider\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.provider = new ResourceProvider(this.config.url, this.config.rights)\r\n    this.authors = []\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of available authors and textWorks.\r\n  * For now it uploads data from json file, but later it will fetch data from cordance api\r\n  * @param {Boolean} reload - if true - data will be forced to reload from source\r\n  * @return {Author[]]}\r\n  */\r\n  async getAuthorsWorks (reload = false) {\r\n    try {\r\n      if (reload || this.authors.length === 0) {\r\n        this.authorWorkData = await this.uploadConfig({}, AuthorWorkConfigConfig)\r\n\r\n        this.authors = []\r\n        for (const authorWorkDataItem of Object.values(this.authorWorkData.authors)) {\r\n          const author = this.createAuthor(authorWorkDataItem)\r\n          this.authors.push(author)\r\n        }\r\n      }\r\n      return this.authors\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('CONCORDANCE_AUTHOR_UPLOAD_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of word usage examples from corcondance api and creates WordUsageExample-s.\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @param {Object} sort - { } - it is an empty property for future sort feature\r\n  * @return {Object} - with the following format\r\n  *         {\r\n  *           {WordUsageExample[]} wordUsageExamples - result wordUsageExamples\r\n  *           {String} targetWord - source targetWord\r\n  *           {String} language - source languageCode\r\n  *           {ResourceProvider} provider - provider data\r\n  *         }\r\n  */\r\n  async getWordUsageExamples (homonym, filters = {}, pagination = {}, sort = {}) {\r\n    try {\r\n      const url = this.createFetchURL(homonym, filters, pagination, sort)\r\n      const wordUsageListRes = await this.fetch(url)\r\n      if (Array.isArray(wordUsageListRes)) {\r\n        const parsedWordUsageList = await this.parseWordUsageResult(wordUsageListRes, homonym)\r\n        return {\r\n          wordUsageExamples: parsedWordUsageList,\r\n          targetWord: homonym.targetWord,\r\n          language: LanguageModelFactory.getLanguageCodeFromId(homonym.languageID),\r\n          provider: this.provider\r\n        }\r\n      } else {\r\n        return []\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('CONCORDANCE_WORD_USAGE_FETCH_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method constructs full url for getting data for getWordUsageExamples method using properties.\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @param {Object} sort - { } - it is an empty property for future sort feature\r\n  * @return {String}\r\n  */\r\n  createFetchURL (homonym, filters, pagination, sort) {\r\n    const filterFormatted = this.formatFilter(filters)\r\n    const paginationFormatted = this.formatPagination(pagination)\r\n    return `${this.config.url}${encodeURIComponent(homonym.targetWord)}${filterFormatted}${paginationFormatted}`\r\n  }\r\n\r\n  /**\r\n  * This method formats filters property for fetch url.\r\n  * @param {Object} filters - { author: {Author}, textWork: {TextWork} } - filter's property for getting data,\r\n  *                           it could be filtered: no filter, by author, by author and textWork\r\n  * @return {String}\r\n  */\r\n  formatFilter (filters) {\r\n    if (filters && filters.author) {\r\n      if (filters.textWork) {\r\n        return `[${filters.author.ID}:${filters.textWork.ID}]`\r\n      }\r\n      return `[${filters.author.ID}]`\r\n    }\r\n    return ''\r\n  }\r\n\r\n  /**\r\n  * This method formats pagination property for fetch url.\r\n  * @param {Object} pagination - { property: 'max', value: {Integer} } - property for setting max limit for the result\r\n  * @return {String}\r\n  */\r\n  formatPagination (pagination) {\r\n    // the PHI service supports two pagination parameters: authmax and max\r\n    // authmax sets the max hits to return per author and max sets the max hits to return over alpheios-data-models\r\n    // max trumps authmax - i.e. only the max number of hits will be returned, and authmax applies after that\r\n    // given that there a finite number of authors, we want to set the values for these differently depending upon whether\r\n    // the request is filtered by author or not - and allowing user specification of the max across all authors probably\r\n    // isn't a good idea, because what we really want in this case is no overall max applied, but that option is not\r\n    // avaliable from the service at the moment\r\n    if (pagination && pagination.property && (pagination.property === 'authmax') && pagination.value) {\r\n      return `?${pagination.property}=${parseInt(pagination.value)}&max=${this.config.maxResultsOverride}`\r\n    } else if (pagination && pagination.property && (pagination.property === 'max') && pagination.value) {\r\n      return `?${pagination.property}=${parseInt(pagination.value)}`\r\n    }\r\n    return ''\r\n  }\r\n\r\n  /**\r\n  * This method parses json result from concordance source for word usage examples.\r\n  * @param {Object} jsonObj - json response from url\r\n  * @param {Homonym} homonym - homonym for retrieving word usage examples\r\n  * @param {Author} author - author from filter\r\n  * @param {TextWork} textWork - textWork from filter\r\n  * @return {WordUsageExample[]}\r\n  */\r\n  async parseWordUsageResult (jsonObj, homonym) {\r\n    let wordUsageExamples = [] // eslint-disable-line prefer-const\r\n    let author, textWork, passage\r\n\r\n    if (this.authors.length === 0) {\r\n      await this.getAuthorsWorks()\r\n    }\r\n\r\n    for (const jsonObjItem of jsonObj) {\r\n      author = this.getAuthorByAbbr(jsonObjItem)\r\n      if (author) {\r\n        textWork = this.getTextWorkByAbbr(author, jsonObjItem)\r\n        if (textWork) {\r\n          passage = this.getPassage(jsonObjItem)\r\n\r\n          let wordUsageExample = this.createWordUsageExample(jsonObjItem, homonym, author, textWork, passage) // eslint-disable-line prefer-const\r\n          wordUsageExamples.push(wordUsageExample)\r\n        }\r\n      }\r\n    }\r\n    return wordUsageExamples\r\n  }\r\n\r\n  getAuthorByAbbr (jsonObj) {\r\n    if (jsonObj.cit && this.authors.length > 0) {\r\n      const authorAbbr = jsonObj.cit.split('.')[0]\r\n      return this.authors.find(author => Object.values(author.abbreviations).includes(authorAbbr))\r\n    }\r\n    return null\r\n  }\r\n\r\n  getTextWorkByAbbr (author, jsonObj) {\r\n    if (jsonObj.cit && author && author.works.length > 0) {\r\n      const parts = jsonObj.cit.split('.')\r\n      // if we have only 2 parts in the citation, it's probably an author without a work\r\n      // which in the phi data is really when the author and work are referenced as the same thing\r\n      // as in an anonymous work\r\n      if (parts.length > 2) {\r\n        const textWorkAbbr = parts[1]\r\n        return author.works.find(textWork => Object.values(textWork.abbreviations).includes(textWorkAbbr))\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  getPassage (jsonObj) {\r\n    let passage = null\r\n    if (jsonObj.cit) {\r\n      const parts = jsonObj.cit.split('.')\r\n      // if we have only 2 parts in the citation, it's probably an author without a work\r\n      // which in the phi data is really when the author and work are referenced as the same thing\r\n      // as in an anonymous work\r\n      if (parts.length === 2) {\r\n        passage = parts.slice(1).join('.')\r\n      } else if (parts.length > 2) {\r\n        passage = parts.slice(2).join('.')\r\n      }\r\n    }\r\n    return passage\r\n  }\r\n\r\n  /**\r\n  * This property is used to define prefix fr extract ID\r\n  * @returns {String}\r\n  */\r\n  get defaultIDPrefix () {\r\n    return 'phi'\r\n  }\r\n\r\n  /**\r\n  * Method returns Author for given jsonObj (from concordance API)\r\n  * @param {Object} jsonObj - json object with data of the Author\r\n  * @returns {Author}\r\n  */\r\n  createAuthor (jsonObj) {\r\n    let titles = {} // eslint-disable-line prefer-const\r\n    jsonObj.title.forEach(titleItem => {\r\n      titles[titleItem['@lang']] = titleItem['@value']\r\n    })\r\n\r\n    let abbreviations = {} // eslint-disable-line prefer-const\r\n    jsonObj.abbreviations.forEach(abbrItem => {\r\n      abbreviations[abbrItem['@lang']] = abbrItem['@value'].replace('.', '')\r\n    })\r\n\r\n    let author = new Author(jsonObj.urn, titles, abbreviations) // eslint-disable-line prefer-const\r\n    author.ID = this.extractIDFromURNAuthor(author.urn)\r\n    let works = [] // eslint-disable-line prefer-const\r\n\r\n    jsonObj.works.forEach(workItem => {\r\n      works.push(this.createTextWork(author, workItem))\r\n    })\r\n\r\n    author.works = works\r\n    return author\r\n  }\r\n\r\n  /**\r\n  * Method extracts ID from the urn, if it is correct. Otherwise it returns null.\r\n  * @returns {Number, null}\r\n  */\r\n  extractIDFromURNAuthor (urn) {\r\n    const partsUrn = urn.split(':')\r\n    if (Array.isArray(partsUrn) && partsUrn.length >= 4) {\r\n      const workIDPart = partsUrn[3].indexOf('.') === -1 ? partsUrn[3] : partsUrn[3].substr(0, partsUrn[3].indexOf('.'))\r\n      return parseInt(workIDPart.replace(this.defaultIDPrefix, ''))\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n  * Method returns TextWork for given jsonObj (from concordance API)\r\n  * @param {Author} author - author of the textWork\r\n  * @param {Object} jsonObj - json object with data of the TextWork\r\n  * @returns {TextWork}\r\n  */\r\n  createTextWork (author, jsonObj) {\r\n    let titles = {} // eslint-disable-line prefer-const\r\n    jsonObj.title.forEach(titleItem => {\r\n      titles[titleItem['@lang']] = titleItem['@value']\r\n    })\r\n\r\n    let abbreviations = {} // eslint-disable-line prefer-const\r\n    jsonObj.abbreviations.forEach(abbrItem => {\r\n      abbreviations[abbrItem['@lang']] = abbrItem['@value'].replace('.', '')\r\n    })\r\n\r\n    let textWork = new TextWork(author, jsonObj.urn, titles, abbreviations) // eslint-disable-line prefer-const\r\n    textWork.ID = this.extractIDFromURNTextWork(textWork.urn)\r\n    return textWork\r\n  }\r\n\r\n  /**\r\n  * Method extracts ID from the urn, if it is correct. Otherwise it returns null.\r\n  * @returns {Number, null}\r\n  */\r\n  extractIDFromURNTextWork (urn) {\r\n    const partsUrn = urn.split(':')\r\n\r\n    if (Array.isArray(partsUrn) && partsUrn.length >= 4) {\r\n      const workIDPart = partsUrn[3].indexOf('.') === -1 ? null : partsUrn[3].substr(partsUrn[3].indexOf('.') + 1)\r\n\r\n      return parseInt(workIDPart.replace(this.defaultIDPrefix, ''))\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n  * Creates WordUsageExample object from jsonObj, homonym, author, textWork and link from the adapter config\r\n  * @param {Object} jsonObj - json object from concordance api\r\n  * @param {Homonym} homonym - source homonym object\r\n  * @param {Author} author - source author object, could be undefined\r\n  * @param {TextWork} textWork - source textWork object, could be undefined\r\n  * @param {String} passage - passage string, could be null\r\n  * @returns {WordUsageExample}\r\n  */\r\n  createWordUsageExample (jsonObj, homonym, author, textWork, passage) {\r\n    const source = this.config.sourceTextUrl + jsonObj.link\r\n    let wordUsageExample = new WordUsageExample( // eslint-disable-line prefer-const\r\n      LanguageModelFactory.getLanguageCodeFromId(homonym.languageID), jsonObj.target, jsonObj.left, jsonObj.right, source, jsonObj.cit\r\n    )\r\n    wordUsageExample.author = author\r\n    wordUsageExample.textWork = textWork\r\n    wordUsageExample.passage = passage\r\n    wordUsageExample.homonym = homonym\r\n    wordUsageExample.provider = this.provider\r\n\r\n    return wordUsageExample\r\n  }\r\n}\r\n\r\nexport default AlpheiosConcordanceAdapter\r\n","import { LanguageModelFactory as LMF, Definition, ResourceProvider } from 'alpheios-data-models'\r\nimport papaparse from 'papaparse'\r\n\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport DefaultConfig from '@clAdapters/adapters/lexicons/config.json'\r\n\r\nlet cachedDefinitions = new Map() // eslint-disable-line prefer-const\r\nlet uploadStarted = new Map() // eslint-disable-line prefer-const\r\n\r\nclass AlpheiosLexiconsAdapter extends BaseAdapter {\r\n  /**\r\n  * Lexicons adapter uploads config data, defines default options and inits data\r\n  * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.options = { timeout: this.config.timeout ? this.config.timeout : 0 }\r\n    this.async = Boolean(this.config.callBackEvtSuccess)\r\n  }\r\n\r\n  /**\r\n  * This method retrieves short definitions for given homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  */\r\n  async fetchShortDefs (homonym, options = {}) {\r\n    await this.fetchDefinitions(homonym, options, 'short')\r\n  }\r\n\r\n  /**\r\n  * This method retrieves full definitions for given homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  */\r\n  async fetchFullDefs (homonym, options = {}) {\r\n    await this.fetchDefinitions(homonym, options, 'full')\r\n  }\r\n\r\n  /**\r\n  * This method creates Promise for getting short definitions, for being able to parallel requests\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {String} urlKey - urlIndex for geting data from config\r\n  */\r\n  prepareShortDefPromise (homonym, urlKey) {\r\n    const url = this.config[urlKey].urls.short\r\n    const requestType = 'shortDefs'\r\n\r\n    const resCheckCached = this.checkCachedData(url)\r\n    return resCheckCached.then(\r\n      async (result) => {\r\n        if (result) {\r\n          const res = cachedDefinitions.get(url)\r\n          await this.updateShortDefs(res, homonym, this.config[urlKey])\r\n          this.prepareSuccessCallback(requestType, homonym)\r\n        }\r\n      },\r\n      error => {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        this.prepareFailedCallback(requestType, homonym)\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n  * This method creates Promise for getting full definitions, for being able to parallel requests\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {String} urlKey - urlIndex for geting data from config\r\n  */\r\n  prepareFullDefPromise (homonym, urlKey) {\r\n    const url = this.config[urlKey].urls.index\r\n    const requestType = 'fullDefs'\r\n\r\n    const resCheckCached = this.checkCachedData(url)\r\n    return resCheckCached.then(\r\n      async (result) => {\r\n        if (result) {\r\n          const fullDefsRequests = this.collectFullDefURLs(cachedDefinitions.get(url), homonym, this.config[urlKey])\r\n          const resFullDefs = this.updateFullDefsAsync(fullDefsRequests, this.config[urlKey], homonym)\r\n          resFullDefs.catch(error => {\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n            this.prepareFailedCallback(requestType, homonym)\r\n          })\r\n        }\r\n      },\r\n      error => {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        this.prepareFailedCallback(requestType, homonym)\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n  * This method checks if there is a callBackEvtSuccess defined and publish it if exists\r\n  * @param {String} requestType - name of the request - shortDef and fullDef\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  prepareSuccessCallback (requestType, homonym) {\r\n    if (this.config.callBackEvtSuccess) {\r\n      this.config.callBackEvtSuccess.pub({\r\n        requestType: requestType,\r\n        homonym: homonym\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if there is a callBackEvtFailed defined and publish it if exists\r\n  * @param {String} requestType - name of the request - shortDef and fullDef\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  prepareFailedCallback (requestType, homonym) {\r\n    if (this.config.callBackEvtFailed) {\r\n      this.config.callBackEvtFailed.pub({\r\n        requestType: requestType,\r\n        homonym: homonym\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a generic method that retrieves definitions for homonym\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} options - options\r\n  * @param {Object} lookupFunction - type of definitions - short, full\r\n  * @return {Boolean} - result of fetching\r\n  */\r\n  async fetchDefinitions (homonym, options, lookupFunction) {\r\n    Object.assign(this.options, options)\r\n    if (!this.options.allow || this.options.allow.length === 0) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_NO_ALLOWED_URL'))\r\n      return\r\n    }\r\n\r\n    if (this.async) {\r\n      return this.fetchDefsAsync(homonym, lookupFunction)\r\n    } else {\r\n      if (lookupFunction === 'short') {\r\n        return this.fetchShortDefsSync(homonym)\r\n      } else if (lookupFunction === 'full') {\r\n        return this.fetchFullDefsSync(homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a sync method that retrieves short definitions for homonym synchronously\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  async fetchShortDefsSync (homonym) {\r\n    try {\r\n      const languageID = homonym.lexemes[0].lemma.languageID\r\n      const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n      for (const urlKey of urlKeys) {\r\n        const url = this.config[urlKey].urls.short\r\n        const result = await this.checkCachedData(url)\r\n\r\n        if (result) {\r\n          const res = cachedDefinitions.get(url)\r\n          await this.updateShortDefs(res, homonym, this.config[urlKey])\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is a sync method that retrieves full definitions for homonym synchronously\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  */\r\n  async fetchFullDefsSync (homonym) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n    for (const urlKey of urlKeys) {\r\n      const url = this.config[urlKey].urls.index\r\n      const result = await this.checkCachedData(url)\r\n\r\n      if (result) {\r\n        const fullDefsRequests = this.collectFullDefURLs(cachedDefinitions.get(url), homonym, this.config[urlKey])\r\n        await this.updateFullDefs(fullDefsRequests, this.config[urlKey], homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This is an async method that retrieves definitions for homonym with getting result inside callbacks\r\n  * @param {Homonym} homonym - homonym for retrieving definitions\r\n  * @param {Object} lookupFunction - type of definitions - short, full\r\n  * @return {Boolean} - result of fetching\r\n  */\r\n\r\n  fetchDefsAsync (homonym, lookupFunction) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const urlKeys = this.getRequests(languageID).filter(url => this.options.allow.includes(url))\r\n\r\n    for (const urlKey of urlKeys) {\r\n      if (lookupFunction === 'short') {\r\n        this.prepareShortDefPromise(homonym, urlKey, lookupFunction)\r\n      }\r\n      if (lookupFunction === 'full') {\r\n        this.prepareFullDefPromise(homonym, urlKey, lookupFunction)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if data from url is already cached and if not - it uploads data from url to cache\r\n  * @param {String} url - url from what we need to cache data\r\n  * @param {Null|Map|String} externalData - data that would be used as fixture for the url\r\n  * @param {Boolean} skipFetch - when this check is true, then fetch would not be execute in any case, it is used for Full Definitions\r\n  * @return {Boolean} - true - if cached is successed\r\n  */\r\n  async checkCachedData (url, externalData = null, skipFetch = false) {\r\n    if (!externalData && skipFetch) {\r\n      return false\r\n    }\r\n    if (!cachedDefinitions.has(url) && !uploadStarted.has(url)) {\r\n      try {\r\n        uploadStarted.set(url, true)\r\n\r\n        let data = externalData\r\n        if (!externalData) {\r\n          const unparsed = await this.fetch(url, { type: 'xml', timeout: this.options.timeout })\r\n          const parsed = papaparse.parse(unparsed, { quoteChar: '\\u{0000}', delimiter: '|' })\r\n          data = this.fillMap(parsed.data)\r\n        }\r\n\r\n        cachedDefinitions.set(url, data)\r\n        uploadStarted.set(url, false)\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error.message }))\r\n        uploadStarted.set(url, false)\r\n        return false\r\n      }\r\n    } else if (uploadStarted.has(url) && uploadStarted.get(url)) {\r\n      setTimeout(() => {\r\n        this.checkCachedData(url)\r\n      }, this.options.timeout)\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n  * This method searches for definitions in cached text, creates definitions and updates lexemes\r\n  * @param {Map} data - cached data from definition's url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  * @param {Object} config - config data for url\r\n  */\r\n  async updateShortDefs (data, homonym, config) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const model = LMF.getLanguageModel(languageID)\r\n\r\n    for (let lexeme of homonym.lexemes) { // eslint-disable-line prefer-const\r\n      const deftexts = this.lookupInDataIndex(data, lexeme.lemma, model)\r\n      if (deftexts) {\r\n        for (const d of deftexts) {\r\n          const text = d.field1\r\n          const providerCode = d.field2\r\n          const format = config.format && config.format.short ? config.format.short : 'text/plain'\r\n          try {\r\n            let rightsText = config.rights\r\n            let rightsUri = config.urls.short\r\n            if (providerCode && config.rights_keys && config.rights_keys[providerCode]) {\r\n              rightsUri = rightsUri + `#${providerCode}`\r\n              rightsText = config.rights_keys[providerCode]\r\n            }\r\n            const provider = new ResourceProvider(rightsUri, rightsText)\r\n            const def = new Definition(text, config.langs.target, format, lexeme.lemma.word)\r\n            const definition = ResourceProvider.getProxy(provider, def)\r\n            lexeme.meaning.appendShortDefs(definition)\r\n          } catch (error) {\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n            continue\r\n          }\r\n        }\r\n      } else {\r\n        const url = config.urls.short\r\n        this.addError(this.l10n.getMsg('LEXICONS_NO_DATA_FROM_URL', { url: url }))\r\n        this.prepareFailedCallback('shortDefs', homonym)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method creates requests to full definitions url for each lexeme and given config\r\n  * @param {Map} data - cached data from definition's index url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  * @param {Object} config - config data for url\r\n  * @return {[String]} - array of urls for retrieving data\r\n  */\r\n  collectFullDefURLs (data, homonym, config) {\r\n    const languageID = homonym.lexemes[0].lemma.languageID\r\n    const model = LMF.getLanguageModel(languageID)\r\n    const urlFull = config.urls.full\r\n\r\n    if (!urlFull) {\r\n      this.addError(this.l10n.getMsg('LEXICONS_NO_FULL_URL'))\r\n      return\r\n    }\r\n\r\n    let requests = [] // eslint-disable-line prefer-const\r\n    for (const lexeme of homonym.lexemes) {\r\n      const ids = this.lookupInDataIndex(data, lexeme.lemma, model)\r\n      if (urlFull && ids) {\r\n        for (const id of ids) {\r\n          requests.push({ url: `${urlFull}&n=${id.field1}`, lexeme: lexeme })\r\n        }\r\n      } else if (urlFull) {\r\n        requests.push({ url: `${urlFull}&l=${encodeURIComponent(lexeme.lemma.word)}`, lexeme: lexeme })\r\n      }\r\n    }\r\n    return requests\r\n  }\r\n\r\n  /**\r\n  * This method fetches data from request and update homonym with full definition - it is made as Promises with calback to make it parallel\r\n  * @param {[String]} fullDefsRequests - array of full definitions url\r\n  * @param {Object} config - config data for url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  */\r\n  async updateFullDefsAsync (fullDefsRequests, config, homonym) {\r\n    for (let request of fullDefsRequests) { // eslint-disable-line prefer-const\r\n      let fullDefDataRes\r\n      if (cachedDefinitions.has(request.url)) {\r\n        fullDefDataRes = new Promise((resolve, reject) => resolve(cachedDefinitions.get(request.url)))\r\n      } else {\r\n        fullDefDataRes = this.fetch(request.url, { type: 'xml' })\r\n      }\r\n\r\n      fullDefDataRes.then(\r\n        async (fullDefData) => {\r\n          if (fullDefData && fullDefData.match(/alph:error|alpheios-lex-error/)) {\r\n            const error = fullDefData.match(/no entries found/i) ? 'No entries found.' : fullDefData\r\n            this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error }))\r\n            this.prepareFailedCallback('fullDefs', homonym)\r\n          } else {\r\n            const provider = new ResourceProvider(config.urls.full, config.rights)\r\n            const def = new Definition(fullDefData, config.langs.target, 'text/plain', request.lexeme.lemma.word)\r\n            const definition = ResourceProvider.getProxy(provider, def)\r\n            request.lexeme.meaning.appendFullDefs(definition)\r\n            this.prepareSuccessCallback('fullDefs', homonym)\r\n          }\r\n        },\r\n        error => {\r\n          this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method fetches data from request and update homonym with full definition synchronously\r\n  * @param {[String]} fullDefsRequests - array of full definitions url\r\n  * @param {Object} config - config data for url\r\n  * @param {Homonym} homonym - homonym we search definitions for\r\n  */\r\n  async updateFullDefs (fullDefsRequests, config, homonym) {\r\n    for (let request of fullDefsRequests) { // eslint-disable-line prefer-const\r\n      let fullDefData\r\n      if (cachedDefinitions.has(request.url)) {\r\n        fullDefData = cachedDefinitions.get(request.url)\r\n      } else {\r\n        fullDefData = await this.fetch(request.url, { type: 'xml' })\r\n      }\r\n\r\n      try {\r\n        if (fullDefData && fullDefData.match(/alph:error|alpheios-lex-error/)) {\r\n          const error = fullDefData.match(/no entries found/i) ? 'No entries found.' : fullDefData\r\n          this.addError(this.l10n.getMsg('LEXICONS_FAILED_CACHED_DATA', { message: error }))\r\n        } else {\r\n          const provider = new ResourceProvider(config.urls.full, config.rights)\r\n          const def = new Definition(fullDefData, config.langs.target, 'text/plain', request.lexeme.lemma.word)\r\n          const definition = ResourceProvider.getProxy(provider, def)\r\n          request.lexeme.meaning.appendFullDefs(definition)\r\n        }\r\n      } catch (error) {\r\n        this.addError(this.l10n.getMsg('LEXICONS_FAILED_APPEND_DEFS', { message: error.message }))\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This method retrieves urls from config for given languageCode\r\n  * @param {Symbol} languageID\r\n  */\r\n  getRequests (languageID) {\r\n    const languageCode = LMF.getLanguageCodeFromId(languageID)\r\n    return Object.keys(this.config).filter(url => this.config[url] && this.config[url].langs && this.config[url].langs.source === languageCode)\r\n  }\r\n\r\n  /**\r\n   * fills the data map with the rows from the parsed file\r\n   * we need a method to do this because there may be homonyms in\r\n   * the files\r\n   * @param {string[]} rows\r\n   * @return {Map} the filled map\r\n   */\r\n  fillMap (rows) {\r\n    let data = new Map() // eslint-disable-line prefer-const\r\n    for (const row of rows) {\r\n      const def = { field1: row[1], field2: null }\r\n      if (row.length > 2) {\r\n        def.field2 = row[2]\r\n      }\r\n      if (data.has(row[0])) {\r\n        data.get(row[0]).push(def)\r\n      } else {\r\n        data.set(row[0], [def])\r\n      }\r\n    }\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Lookup a Lemma object in an Alpheios v1 data index\r\n   * @param {Map} data the data inddex\r\n   * @param {Lemma} lemma the lemma to lookupInDataIndex\r\n   * @param {LanguageModel} model a language model for language specific methods\r\n   * @return {string} the index entry as a text string\r\n   */\r\n  lookupInDataIndex (data, lemma, model) {\r\n    // legacy behavior from Alpheios lemma data file indices\r\n    // first look to see if we explicitly have an instance of this lemma\r\n    // with capitalization retained\r\n    let found\r\n\r\n    let alternatives = []\r\n    let altEncodings = [] // eslint-disable-line prefer-const\r\n    for (const l of [lemma.word, ...lemma.principalParts]) {\r\n      alternatives.push(l)\r\n      for (const a of model.alternateWordEncodings({ word: l, preserveCase: true })) {\r\n        // we gather altEncodings separately because they should\r\n        // be tried last after the lemma and principalParts in their\r\n        // original form\r\n        altEncodings.push(a)\r\n      }\r\n      const nosense = l.replace(/_?\\d+$/, '')\r\n      if (l !== nosense) {\r\n        alternatives.push(nosense)\r\n      }\r\n    }\r\n    alternatives = [...alternatives, ...altEncodings]\r\n    for (const lookup of alternatives) {\r\n      // let's first just look for the word in its supplied case\r\n      found = false\r\n      if (data && lookup) {\r\n        found = data.get(lookup)\r\n\r\n        // and if we don't find it, then try lower case\r\n        if (!found) {\r\n          found = data.get(lookup.toLocaleLowerCase())\r\n        }\r\n\r\n        if (found) {\r\n          found = this._lookupSpecial(data, lookup, found)\r\n        }\r\n        if (found) {\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // if we still don't have a match, we can do a last ditch check without\r\n    // any diacritics at all in those languages that support it\r\n    if (!found) {\r\n      let lastAlt = [] // eslint-disable-line prefer-const\r\n      for (const l of [lemma.word, ...lemma.principalParts]) {\r\n        const strippedAll = model.alternateWordEncodings({\r\n          word: l,\r\n          encoding: 'strippedAll',\r\n          preserveCase: true\r\n        })\r\n        if (strippedAll.length > 0) {\r\n          lastAlt.push(strippedAll[0])\r\n        }\r\n      }\r\n      if (lastAlt.length > 0) {\r\n        for (const l of lastAlt) {\r\n          for (let entry of data.entries()) { // eslint-disable-line prefer-const\r\n            // a normal lookup in the dataset map would only return\r\n            // an entry preceding with '@' as a result of the _lookupSpecial\r\n            // test but because we are looping through and testing each entry\r\n            // the test on case without any diacritics will find those matches\r\n            // and we need to remove the @ flag to make sure it doesn't fail them\r\n            const originalKey = entry[0].replace(/^@/, '')\r\n            const value = entry[1]\r\n            const strippedKey = model.alternateWordEncodings({\r\n              word: originalKey,\r\n              encoding: 'strippedAll',\r\n              preserveCase: true\r\n            })\r\n            if (strippedKey.length > 0 && strippedKey[0] === l) {\r\n              found = this._lookupSpecial(data, originalKey, value)\r\n              if (found) {\r\n                break\r\n              }\r\n            }\r\n          }\r\n          if (found) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return found\r\n  }\r\n\r\n  /**\r\n   * When we created the lexicon indices we normalized the lemmas\r\n   * as all lower case and applied some additional character normalizations\r\n   * in the case of homonyms however, sometimes the normalization meant 1\r\n   * index entry for two distinct words. In these cases, we created a \"special\"\r\n   * syntax, whereby we set the value of the normalized index entry to '@'\r\n   * which mean to look for the word under it's pre-normalized entry,\r\n   * which was kept and made available in an entry prefixed with '@'\r\n   * @param {Map} data the dataset to search in\r\n   * @param {lookup} lookup the original pre-normalized lemma\r\n   * @param {lemmas} the value returned by the lookup on the normalized lemma\r\n   **/\r\n  _lookupSpecial (data, lookup, lemmas) {\r\n    if (lemmas.length === 1 && lemmas[0].field1 === '@') {\r\n      return data.get(`@${lookup}`)\r\n    } else {\r\n      return lemmas\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosLexiconsAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/logeion/config.json'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nimport { LanguageModelFactory as LMF, Constants } from 'alpheios-data-models'\r\n\r\nclass AlpheiosLogeionAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.limit = parseInt(this.config.limit)\r\n    this.available = this.config.availableLangs.includes(this.config.lang)\r\n    this.sourceData = config.sourceData\r\n    this.fetchOptions = config.fetchOptions\r\n  }\r\n\r\n  /**\r\n  * This method retrieves a list of words for lookup autocomplete\r\n  * @param {String} text - text for retrieving variants\r\n  * @return {Array} - array of words\r\n  */\r\n  async getWords (text) {\r\n    try {\r\n      const url = this.createFetchURL(text)\r\n      if (!url) {\r\n        this.addError(this.l10n.getMsg('LOGEION_FETCH_OPTIONS_ERROR'))\r\n        return\r\n      }\r\n\r\n      if (this.sourceData) {\r\n        return this.sourceData\r\n      } else {\r\n        const wordsVariants = await this.fetch(url)\r\n\r\n        if (wordsVariants.words && Array.isArray(wordsVariants.words)) {\r\n          return this.filterAndLimitWords(wordsVariants.words)\r\n        } else {\r\n          return []\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('LOGEION_FETCH_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method constructs full url for getting words\r\n  * @param {String} text - text for retrieving variants\r\n  * @return {String}\r\n  */\r\n  createFetchURL (text) {\r\n    if (this.fetchOptions) {\r\n      return `${this.fetchOptions.baseurl}?key=${this.fetchOptions.apikey}&q=${text}&lang=${this.logeionLangCode}`\r\n    }\r\n  }\r\n\r\n  get logeionLangCode () {\r\n    if (this.config.lang === Constants.STR_LANG_CODE_GRC) {\r\n      return 'greek'\r\n    } else if ([Constants.STR_LANG_CODE_LAT, Constants.STR_LANG_CODE_LA].includes(this.config.lang)) {\r\n      return 'latin'\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method removes words from the other language - checks two variants - greek and the other\r\n  * @param {[Array]} words - list of words that should be checked and filtered\r\n  * @return {Array}\r\n  */\r\n  filterAndLimitWords (words) {\r\n    const finalWords = []\r\n    const model = LMF.getLanguageModelFromCode(this.config.lang)\r\n    const otherModels = []\r\n    this.config.availableLangs.forEach(lang => {\r\n      const modelLang = LMF.getLanguageModelFromCode(lang)\r\n      if (lang !== this.config.lang && modelLang.isValidUnicode) {\r\n        otherModels.push(modelLang)\r\n      }\r\n    })\r\n\r\n    for (let i = 0; i < words.length; i++) {\r\n      if ((model.isValidUnicode && model.isValidUnicode(words[i])) ||\r\n          (!model.isValidUnicode && otherModels.every(modelLang => !modelLang.isValidUnicode(words[i])))) {\r\n        finalWords.push(words[i])\r\n      }\r\n\r\n      if (finalWords.length === this.limit) {\r\n        break\r\n      }\r\n    }\r\n    return finalWords\r\n  }\r\n}\r\n\r\nexport default AlpheiosLogeionAdapter\r\n","import DefaultConfig from '@clAdapters/adapters/translations/config.json'\r\n\r\nimport { ResourceProvider, Translation, LanguageModelFactory as LMF } from 'alpheios-data-models'\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\n\r\nclass AlpheiosLemmaTranslationsAdapter extends BaseAdapter {\r\n  /**\r\n   * Adapter uploads config data, creates provider and inits mapLangUri (Object for storing data for available languages)\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.mapLangUri = {}\r\n    this.provider = new ResourceProvider(this.config.url, this.config.rights)\r\n    this.sourceData = config.sourceData\r\n  }\r\n\r\n  /**\r\n   * This method updates homonym with retrieved translations, if an error occurs it will be added to errors property of an adapter\r\n   * @param {Homonym} homonym\r\n   * @param {String} browserLang - language of the translation (for example its, spa)\r\n  */\r\n  async getTranslationsList (homonym, browserLang) {\r\n    let lemmaList = [] // eslint-disable-line prefer-const\r\n    if (!homonym || !homonym.lexemes) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_INCORRECT_LEXEMES'))\r\n      return\r\n    }\r\n\r\n    for (const lexeme of homonym.lexemes) {\r\n      lemmaList.push(lexeme.lemma)\r\n    }\r\n\r\n    const inLang = LMF.getLanguageCodeFromId(homonym.lexemes[0].lemma.languageID)\r\n    const outLang = this.config.langMap[browserLang] || this.config.defaultLang\r\n\r\n    const input = this.prepareInput(lemmaList)\r\n\r\n    if (!input) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_INPUT_PREPARE_ERROR', { input: input.toString() }))\r\n      return\r\n    }\r\n\r\n    try {\r\n      const urlLang = await this.getAvailableResLang(inLang, outLang)\r\n      if (urlLang && urlLang.constructor.name === 'AdapterError') {\r\n        return\r\n      }\r\n\r\n      if (input && urlLang) {\r\n        try {\r\n          const url = urlLang + '?input=' + input\r\n          let translationsList\r\n          if (this.sourceData && this.sourceData.translations) {\r\n            translationsList = this.sourceData.translations\r\n          } else {\r\n            translationsList = await this.fetch(url)\r\n          }\r\n          if (translationsList && translationsList.constructor.name === 'AdapterError') {\r\n            return\r\n          }\r\n\r\n          for (const lemma of lemmaList) {\r\n            Translation.loadTranslations(lemma, outLang, translationsList, this.provider)\r\n          }\r\n        } catch (error) {\r\n          this.addError(this.l10n.getMsg('TRANSLATION_UNKNOWN_ERROR', { message: error.message }))\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('TRANSLATION_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method creates a string with unique lemma's words form lemmas list\r\n   * @param {[Lemma]} lemmaList\r\n  */\r\n  prepareInput (lemmaList) {\r\n    const inputList = lemmaList.map(lemma => encodeURIComponent(lemma.word)).filter((item, index, self) => self.indexOf(item) === index)\r\n    return inputList.length > 0 ? inputList.join(',') : undefined\r\n  }\r\n\r\n  /**\r\n   * This method fetches an url for translation\r\n   * @param {String} inLang  - translate from language  (for example, lat)\r\n   * @param {String} outLang  - translate to language  (for example, es, it)\r\n  */\r\n  async getAvailableResLang (inLang, outLang) {\r\n    if (this.mapLangUri[inLang] === undefined) {\r\n      const urlAvaLangsRes = this.config.url + '/' + inLang + '/'\r\n\r\n      let unparsed\r\n\r\n      if (!this.sourceData || !this.sourceData.langs) {\r\n        unparsed = await this.fetch(urlAvaLangsRes)\r\n      } else {\r\n        unparsed = this.sourceData.langs\r\n      }\r\n\r\n      if (unparsed && unparsed.constructor.name === 'AdapterError') {\r\n        return unparsed\r\n      }\r\n\r\n      let mapLangUri = {} // eslint-disable-line prefer-const\r\n      unparsed.forEach(function (langItem) {\r\n        mapLangUri[langItem.lang] = langItem.uri\r\n      })\r\n\r\n      if (Object.keys(mapLangUri).length > 0) {\r\n        this.mapLangUri[inLang] = mapLangUri\r\n      }\r\n    }\r\n\r\n    return this.mapLangUri[inLang] ? this.mapLangUri[inLang][outLang] : undefined\r\n  }\r\n}\r\n\r\nexport default AlpheiosLemmaTranslationsAdapter\r\n","import { LanguageModelFactory as LMF, Lexeme, Feature, Constants } from 'alpheios-data-models'\r\n\r\nimport BaseAdapter from '@clAdapters/adapters/base-adapter'\r\nimport AlpheiosLexiconTransformer from '@clAdapters/transformers/alpheios-lexicon-transformer'\r\n\r\nimport DefaultConfig from '@clAdapters/adapters/tufts/config.json'\r\nimport EnginesSet from '@clAdapters/adapters/tufts/engines-set'\r\n\r\nclass AlpheiosTuftsAdapter extends BaseAdapter {\r\n  /**\r\n   * Tufts adapter uploads config data, uploads available engines and creates EnginesSet from them\r\n   * @param {Object} config - properties with higher priority\r\n  */\r\n  constructor (config = {}) {\r\n    super()\r\n    this.config = this.uploadConfig(config, DefaultConfig)\r\n    this.uploadEngines(this.config.engine)\r\n    this.engineSet = new EnginesSet(this.engines)\r\n    this.sourceData = config.sourceData\r\n  }\r\n\r\n  /**\r\n   * This method creates engines object with the following format:\r\n   * LanguageID: array of available engines from config files, for example Symbol(Latin): [\"whitakerLat\"]\r\n   * @param {Object} engineConfig - engines config data\r\n  */\r\n  uploadEngines (engineConfig) {\r\n    if (this.engine === undefined) {\r\n      this.engines = {}\r\n    }\r\n    Object.keys(engineConfig).forEach(langCode => {\r\n      const langID = LMF.getLanguageIdFromCode(langCode)\r\n\r\n      if (langID !== Constants.LANG_UNDEFINED && this.engines[langID] === undefined) {\r\n        this.engines[langID] = engineConfig[langCode]\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * This method gets data from adapter's engine. All errors are added to adapter.errors\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - a word for getting homonym\r\n   * Returned values:\r\n   *      - {Homonym} - if successed\r\n   *      - {undefined} - if failed\r\n  */\r\n  async getHomonym (languageID, word) {\r\n    let res\r\n    try {\r\n      if (this.sourceData) {\r\n        res = this.sourceData\r\n      } else {\r\n        const url = this.prepareRequestUrl(languageID, word)\r\n        if (!url) {\r\n          this.addError(this.l10n.getMsg('MORPH_TUFTS_NO_ENGINE_FOR_LANGUAGE', { languageID: languageID.toString() }))\r\n          return\r\n        }\r\n        res = await this.fetch(url)\r\n        if (res.constructor.name === 'AdapterError') {\r\n          return\r\n        }\r\n      }\r\n\r\n      if (res) {\r\n        const mappingData = this.engineSet.getEngineByCode(languageID)\r\n        if (!mappingData) {\r\n          this.addError(this.l10n.getMsg('MORPH_TRANSFORM_NO_MAPPING_DATA', { language: languageID.toString() }))\r\n          return\r\n        }\r\n        const transformAdapter = new AlpheiosLexiconTransformer(this, mappingData, this)\r\n        let homonym = transformAdapter.transformData(res, word) // eslint-disable-line prefer-const\r\n\r\n        if (!homonym) {\r\n          this.addError(this.l10n.getMsg('MORPH_NO_HOMONYM', { word: word, languageID: languageID.toString() }))\r\n          return\r\n        }\r\n\r\n        if (homonym && homonym.lexemes) {\r\n          homonym.lexemes.sort(Lexeme.getSortByTwoLemmaFeatures(Feature.types.frequency, Feature.types.part))\r\n        }\r\n\r\n        return homonym\r\n      }\r\n    } catch (error) {\r\n      this.addError(this.l10n.getMsg('MORPH_UNKNOWN_ERROR', { message: error.message }))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method creates url with url from config and chosen engine\r\n   * @param {Symbol} languageID - languageID for getting homonym\r\n   * @param {String} word - a word for getting homonym\r\n   * Returned url:\r\n   *     - {String} - constructed url for getting data from Tufts if engine is correct\r\n   *     - {null} - if engine is not correct\r\n  */\r\n  prepareRequestUrl (languageID, word) {\r\n    const langCode = LMF.getLanguageCodeFromId(languageID)\r\n    const engine = this.engineSet.getEngineByCode(languageID)\r\n\r\n    if (engine) {\r\n      const code = engine.engine\r\n      return this.config.url.replace('r_WORD', encodeURIComponent(word)).replace('r_ENGINE', code).replace('r_LANG', langCode).replace('r_CLIENT', this.config.clientId)\r\n    } else {\r\n      return null\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosTuftsAdapter\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.ArabicLanguageModel, 'aramorph')\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nlet data = new ImportData(Models.PersianLanguageModel, 'hazm') // eslint-disable-line prefer-const\r\n\r\n// hazm allow all lemmas in without respect features as all we use it for is lemmatizing\r\ndata.setLexemeFilter(function (lexeme) { return Boolean(lexeme.lemma.word) })\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nlet data = new ImportData(Models.GreekLanguageModel, 'morpheusgrc') // eslint-disable-line prefer-const\r\n\r\n// Morpheus uses 'irregular' as pofs for some pronouns, override with lemma\r\n// the dictionary entry's conjugation if it's available\r\ndata.inflectionOverrides = {\r\n  [Models.Feature.types.part]: (i, ls) => i[Models.Feature.types.part].value === Models.Constants.TYPE_IRREGULAR && ls.filter(l => l.features[Models.Feature.types.part].value === Models.Constants.POFS_PRONOUN)\r\n}\r\n/*\r\nBelow are value conversion maps for each grammatical feature to be parsed.\r\nFormat:\r\ndata.addFeature(typeName).add(providerValueName, LibValueName);\r\n(functions are chainable)\r\nTypes and values that are unknown (undefined) will be skipped during parsing.\r\n */\r\n\r\ndata.addFeature(Models.Feature.types.gender).importer\r\n  .map('masculine feminine', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2]])\r\n\r\ndata.addFeature(Models.Feature.types.declension).importer\r\n  .map('1st & 2nd', [[Models.Constants.ORD_1ST, 1], [Models.Constants.ORD_2ND, 2]])\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'decl') {\r\n    propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n  } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n    propertyValues = []\r\n  } else if (propertyName === 'pofs' && propertyValue === 'irregular' &&\r\n    inputElem.hdwd && inputElem.hdwd.$ === '') {\r\n    propertyValues = [Models.Constants.POFS_PRONOUN]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.SyriacLanguageModel, 'sedra')\r\n\r\n// allow lexemes  if they have at least a meaning or a part of speech\r\ndata.setLexemeFilter(function (lexeme) {\r\n  return Boolean(lexeme.meaning.shortDefs.length > 0 ||\r\n    lexeme.lemma.features[Models.Feature.types.part])\r\n})\r\n\r\n//\r\ndata.setMeaningParser(function (meaning, targetWord) {\r\n  const lang = meaning.lang ? meaning.lang : Models.Constants.STR_LANG_CODE_ENG\r\n  const meaningText = meaning.$ || ''\r\n  return new Models.Definition(meaningText, lang, 'text/html', targetWord)\r\n})\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'paradigm') {\r\n    // state has some extra \"\" around values\r\n    propertyValues = [propertyValue.replace(/\"/g, '')]\r\n  } else if (propertyName === 'src') {\r\n    // replace the '[from sedra.bethmardutho.org, accessed on XXXXX]' as duplicative\r\n    // with rights\r\n    propertyValues = [propertyValue.replace(/\\[from sedra.bethmardutho.org, .*?\\]/g, '')]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.GeezLanguageModel, 'traces')\r\n\r\nexport default data\r\n","import ImportData from '@clAdapters/transformers/import-morph-data.js'\r\nimport * as Models from 'alpheios-data-models'\r\n\r\nconst data = new ImportData(Models.LatinLanguageModel, 'whitakerLat')\r\n\r\n// Whitaker's has weird inflection data for conjugation, we prefer\r\n// the dictionary entry's conjugation if it's available\r\ndata.inflectionOverrides = { [Models.Feature.types.conjugation]: (i, ls) => true }\r\n\r\n/*\r\nBelow are value conversion maps for each grammatical feature to be parsed.\r\nFormat:\r\ndata.addFeature(typeName).add(providerValueName, LibValueName);\r\n(functions are chainable)\r\nTypes and values that are unknown (undefined) will be skipped during parsing.\r\n */\r\n\r\n// TODO  - per inflections.xsd\r\n// Whitakers Words uses packon and tackon in POFS, not sure how\r\n\r\ndata.addFeature(Models.Feature.types.gender).importer\r\n  .map('common', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2]])\r\n  .map('all', [[Models.Constants.GEND_MASCULINE, 1], [Models.Constants.GEND_FEMININE, 2], [Models.Constants.GEND_NEUTER, 3]])\r\n\r\ndata.addFeature(Models.Feature.types.tense).importer\r\n  .map('future_perfect', Models.Constants.TENSE_FUTURE_PERFECT)\r\n\r\ndata.setPropertyParser(function (propertyName, propertyValue, inputElem) {\r\n  let propertyValues = []\r\n  if (propertyName === 'decl') {\r\n    propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n  } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n    propertyValues = []\r\n  } else if (propertyName === 'conj' && propertyValue.match(/5th|6th|7th|8th/)) {\r\n    // these are irregular verbs\r\n    propertyValues = [Models.Constants.TYPE_IRREGULAR]\r\n  } else {\r\n    propertyValues = [propertyValue]\r\n  }\r\n  return propertyValues\r\n})\r\n\r\ndata.setLexemeAggregator(function (lexemeSet, inflections) {\r\n  let lexemes = [] // eslint-disable-line prefer-const\r\n  for (let lex of lexemeSet) { // eslint-disable-line prefer-const\r\n    if (this.reportLexeme(lex)) {\r\n      if (lex.meaning.shortDefs.length === 0 && lexemeSet.length > 1) {\r\n        for (let otherLex of lexemeSet) { // eslint-disable-line prefer-const\r\n          // same headword and same part of speech\r\n          if (otherLex.meaning.shortDefs.length > 0 && otherLex.lemma.isFullHomonym(lex.lemma)) {\r\n            let featuresMatch = true\r\n            for (const feature of Object.entries(lex.lemma.features)) {\r\n              // check the other features excluding frequency, source and age\r\n              if ((feature[0] !== Models.Feature.types.frequency) &&\r\n                   (feature[0] !== Models.Feature.types.source) &&\r\n                   (feature[0] !== Models.Feature.types.age) &&\r\n                   !(feature[1].isEqual(otherLex.lemma.features[feature[0]]))) {\r\n                featuresMatch = false\r\n                break\r\n              }\r\n            }\r\n            // same lemma, same features, must be principal parts mismatch\r\n            if (featuresMatch) {\r\n              // if this lemma has a higher frequency, make it the main lemma of the Lexeme and the existing one an alternative\r\n              if (lex.lemma.features[Models.Feature.types.frequency].compareTo(otherLex.lemma.features[Models.Feature.types.frequency]) < 1) {\r\n                otherLex.addAltLemma(otherLex.lemma)\r\n                otherLex.lemma = lex.lemma\r\n              } else {\r\n                // otherwise just add it to the alternative lemmas\r\n                otherLex.addAltLemma(lex.lemma)\r\n              }\r\n            } else {\r\n              lex.inflections = inflections.map(inflection => inflection.clone())\r\n              lexemes.push(lex)\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        lex.inflections = inflections.map(inflection => inflection.clone())\r\n        lexemes.push(lex)\r\n      }\r\n    }\r\n  }\r\n  return lexemes\r\n}\r\n)\r\n\r\ndata.setLemmaParser(function (lemma) {\r\n  // Whitaker's Words returns principal parts for some words\r\n  // and sometimes has a space separted stem and suffix\r\n  let parsed, primary\r\n  let parts = [] // eslint-disable-line prefer-const\r\n  const lemmas = lemma.split(', ')\r\n  for (const [index, l] of lemmas.entries()) {\r\n    const normalized = l.split(' ')[0]\r\n    if (index === 0) {\r\n      primary = normalized\r\n    }\r\n    parts.push(normalized)\r\n  }\r\n  if (primary) {\r\n    parsed = new Models.Lemma(primary, this.model.languageCode, parts)\r\n  }\r\n\r\n  return parsed\r\n})\r\n\r\nexport default data\r\n","import Whitakers from '@clAdapters/adapters/tufts/engine/whitakers'\r\nimport Morpheusgrc from '@clAdapters/adapters/tufts/engine/morpheusgrc'\r\nimport Aramorph from '@clAdapters/adapters/tufts/engine/aramorph'\r\nimport Hazm from '@clAdapters/adapters/tufts/engine/hazm'\r\nimport Traces from '@clAdapters/adapters/tufts/engine/traces'\r\nimport Sedra from '@clAdapters/adapters/tufts/engine/sedra'\r\n\r\nimport { LanguageModelFactory as LMF } from 'alpheios-data-models'\r\n\r\nclass EnginesSet {\r\n  /**\r\n   * @param {Object} adapterConfigEngines - it is the following format - Symbol(Latin): [\"whitakerLat\"]\r\n  */\r\n  constructor (adapterConfigEngines) {\r\n    this.engine = adapterConfigEngines\r\n  }\r\n\r\n  /**\r\n   * This method returns engine class by languageID\r\n   * @param {Symbol} languageID\r\n   * @return {Engine Class}\r\n  */\r\n  getEngineByCode (languageID) {\r\n    if (this.engine[languageID]) {\r\n      const engineCode = this.engine[languageID][0]\r\n      const allEngines = new Map(([Whitakers, Morpheusgrc, Aramorph, Hazm, Traces, Sedra]).map((e) => { return [e.engine, e] }))\r\n      return allEngines.get(engineCode)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method returns engine class by languageCode\r\n   * @param {String} languageCode\r\n   * @return {Engine Class}\r\n  */\r\n  getEngineByCodeFromLangCode (languageCode) {\r\n    const languageID = LMF.getLanguageIdFromCode(languageCode)\r\n    return this.getEngineByCode(languageID)\r\n  }\r\n}\r\n\r\nexport default EnginesSet\r\n","import AlpheiosTuftsAdapter from '@clAdapters/adapters/tufts/adapter'\r\nimport AlpheiosChineseLocAdapter from '@clAdapters/adapters/chineseloc/adapter'\r\nimport AlpheiosTreebankAdapter from '@clAdapters/adapters/alpheiostb/adapter'\r\nimport AlpheiosLemmaTranslationsAdapter from '@clAdapters/adapters/translations/adapter'\r\nimport AlpheiosLexiconsAdapter from '@clAdapters/adapters/lexicons/adapter'\r\nimport AlpheiosConcordanceAdapter from '@clAdapters/adapters/concordance/adapter'\r\nimport ArethusaTreebankAdapter from '@clAdapters/adapters/arethusa/adapter'\r\nimport AlpheiosLogeionAdapter from '@clAdapters/adapters/logeion/adapter'\r\n\r\nimport WrongMethodError from '@clAdapters/errors/wrong-method-error'\r\nimport NoRequiredParamError from '@clAdapters/errors/no-required-param-error'\r\n\r\nimport AdaptersConfig from '@clAdapters/adapters/adapters-config.json'\r\n\r\nlet cachedConfig = new Map() // eslint-disable-line prefer-const\r\nlet cachedAdaptersList = new Map() // eslint-disable-line prefer-const\r\n\r\nclass ClientAdapters {\r\n  /**\r\n   * it is used for uploading data from AdaptersConfig to cachedConfig and CachedAdaptersList\r\n  */\r\n  static init () {\r\n    if (cachedConfig.size === 0) {\r\n      for (const category in AdaptersConfig) {\r\n        let adapters = {} // eslint-disable-line prefer-const\r\n        for (const adapterKey in AdaptersConfig[category]) {\r\n          const adapterData = AdaptersConfig[category][adapterKey]\r\n\r\n          adapters[adapterKey] = {\r\n            adapter: ClientAdapters[adapterData.adapter],\r\n            methods: adapterData.methods,\r\n            params: adapterData.params\r\n          }\r\n        }\r\n        cachedConfig.set(category, adapters)\r\n      }\r\n\r\n      for (const key of cachedConfig.keys()) {\r\n        const res = {}\r\n        Object.keys(cachedConfig.get(key)).forEach(typeAdapter => {\r\n          res[typeAdapter] = cachedConfig.get(key)[typeAdapter].adapter\r\n        })\r\n\r\n        cachedAdaptersList.set(key, res)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  *  Additional abstraction layer for structuring adapters\r\n  *  it is used for retrieving data from morphology category\r\n  */\r\n  static get morphology () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('morphology')\r\n  }\r\n\r\n  /**\r\n  * it is used for retrieving data from lexicon category\r\n  */\r\n  static get lexicon () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('lexicon')\r\n  }\r\n\r\n  /**\r\n  * it is used for retrieving data from lemmatranslation category\r\n  */\r\n  static get lemmatranslation () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('lemmatranslation')\r\n  }\r\n\r\n  static get wordusageExamples () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('wordusageExamples')\r\n  }\r\n\r\n  static get autocompleteWords () {\r\n    ClientAdapters.init()\r\n    return cachedAdaptersList.get('autocompleteWords')\r\n  }\r\n\r\n  /**\r\n  * This method checks if given method is registered in config for category.adapterName\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {String} methodName - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkMethod (category, adapterName, methodName) {\r\n    if (!cachedConfig.get(category)[adapterName].methods.includes(methodName)) {\r\n      throw new WrongMethodError(category, adapterName, methodName)\r\n    }\r\n  }\r\n\r\n  /**\r\n  * This method checks if given array with parameteres doesn't have required parameters, registered in config file\r\n  * @param {[String]} params - array of parameter's names for being checked\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {String} methodName - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkParam (params, category, adapterName, methodName) {\r\n    if (cachedConfig.get(category)[adapterName].params) {\r\n      cachedConfig.get(category)[adapterName].params[methodName].forEach(paramName => {\r\n        // Param values other than `undefined` such as `null` or empty strings could be valid values\r\n        if (typeof params[paramName] === 'undefined') {\r\n          throw new NoRequiredParamError(category, adapterName, methodName, paramName)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /*\r\n  * This method executes both checks for given options - checks method and given parameters from options\r\n  * @param {String} category - category name - morphology, lemmatranslation, lexicon\r\n  * @param {String} adapterName - adapter name - tufts, treebankAdapter, alpheios\r\n  * @param {Object} options - method name - method name that should be checked, for example getHomonym, fetchTranslations and etc.\r\n  */\r\n  static checkMethodParam (category, adapterName, options) {\r\n    ClientAdapters.checkMethod(category, adapterName, options.method)\r\n    ClientAdapters.checkParam(options.params, category, adapterName, options.method)\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from morph adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {String} options.params.word - target word for what we will receive morph data\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n  */\r\n  static async maAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'tufts', options)\r\n\r\n    const localMaAdapter = new AlpheiosTuftsAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'tufts',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      sourceData: options.sourceData\r\n    })\r\n\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localMaAdapter.getHomonym(options.params.languageID, options.params.word)\r\n      return { result: homonym, errors: localMaAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async chineseAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'chineseloc', options)\r\n\r\n    const localChineseAdapter = new AlpheiosChineseLocAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'chineseloc',\r\n      method: options.method,\r\n      // A URL of a CEDICT service\r\n      serviceUrl: options.serviceUrl\r\n    })\r\n\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localChineseAdapter.getHomonym(options.params.word, options.params.checkContextForward)\r\n      return { result: homonym, errors: localChineseAdapter.errors }\r\n    }\r\n    if (options.method === 'loadData') {\r\n      const result = await localChineseAdapter.loadData(options.params.timeout)\r\n      return { result, errors: localChineseAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from treebank adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {String} options.params.wordref - target wordref for getting data from treebank adapter\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n*/\r\n\r\n  static async tbAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'alpheiosTreebank', options)\r\n\r\n    const localTbAdapter = new AlpheiosTreebankAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'alpheiosTreebank',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localTbAdapter.getHomonym(options.params.languageID, options.params.wordref)\r\n      return { result: homonym, errors: localTbAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from arethusa\r\n   * @param {Object} options - object contains parameters:\r\n   *    @param {String} options.method - for now one value - \"getHomonym\" - action that should be done wth the help of adapter\r\n   *    @param {Symbol} options.params.languageID - languageID value for the word\r\n   *    @param {Symbol} options.params.word - target word\r\n   *    @param {String} options.params.provider - the provider url for Arethusa\r\n   *    @param {String} options.params.sentenceId - the sentence identifier\r\n   *    @param {String} options.params.wordId - the word identifier\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Homonym, errors: [AdapterError] }\r\n*/\r\n\r\n  static async arethusaAdapter (options) {\r\n    ClientAdapters.checkMethodParam('morphology', 'arethusaTreebank', options)\r\n\r\n    const localAdapter = new ArethusaTreebankAdapter({\r\n      category: 'morphology',\r\n      adapterName: 'arethusaTreebank',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n    if (options.method === 'getHomonym') {\r\n      const homonym = await localAdapter.getHomonym(options.params.languageID,\r\n        options.params.word,\r\n        options.params.provider,\r\n        options.params.sentenceId,\r\n        options.params.wordId)\r\n      return { result: homonym, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'refreshView') {\r\n      const resp = await localAdapter.refreshView(options.params.provider)\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'gotoSentence') {\r\n      const resp = await localAdapter.gotoSentence(\r\n        options.params.provider,\r\n        options.params.sentenceId,\r\n        options.params.wordIds\r\n      )\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    if (options.method === 'findWord') {\r\n      const resp = await localAdapter.findWord(\r\n        options.params.provider,\r\n        options.params.word,\r\n        options.params.prefix,\r\n        options.params.suffix,\r\n        options.params.sentenceId\r\n      )\r\n      return { result: resp, errors: localAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from translations adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - for now one value - \"fetchTranslations\" - action that should be done wth the help of adapter\r\n   *    @param {Homonym} options.params.homonym - homonym for retrieving translations\r\n   *    @param {String} options.params.browserLang - language for translations\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Boolean, errors: [AdapterError] }\r\n*/\r\n  static async lemmaTranslations (options) {\r\n    ClientAdapters.checkMethodParam('lemmatranslation', 'alpheios', options)\r\n\r\n    const localLemmasAdapter = new AlpheiosLemmaTranslationsAdapter({\r\n      category: 'lemmatranslation',\r\n      adapterName: 'alpheios',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      sourceData: options.sourceData\r\n    })\r\n\r\n    if (options.method === 'fetchTranslations') {\r\n      await localLemmasAdapter.getTranslationsList(options.params.homonym, options.params.browserLang)\r\n      return { errors: localLemmasAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async wordUsageExamples (options) {\r\n    ClientAdapters.checkMethodParam('wordusageExamples', 'concordance', options)\r\n\r\n    const localLemmasAdapter = new AlpheiosConcordanceAdapter({\r\n      category: 'wordUsage',\r\n      adapterName: 'concordance',\r\n      method: options.method,\r\n      clientId: options.clientId\r\n    })\r\n\r\n    if (options.method === 'getAuthorsWorks') {\r\n      const res = await localLemmasAdapter.getAuthorsWorks()\r\n      return { result: res, errors: localLemmasAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'getWordUsageExamples') {\r\n      const res = await localLemmasAdapter.getWordUsageExamples(options.params.homonym, options.params.filters, options.params.pagination, options.params.sort)\r\n      return { result: res, errors: localLemmasAdapter.errors }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * it is used for getting data from lexicons adapter\r\n   * @param {Object} options - object contains parametes:\r\n   *    @param {String} options.method - action that should be done wth the help of adapter - fetchShortDefs and fetchFullDefs\r\n   *    @param {Homonym} options.params.homonym - homonym for retrieving translations\r\n   *    @param {Object(allow: [String])} options.params.opts - an object with array of urls for dictionaries\r\n   *    @param {PSEvent} options.params.callBackEvtSuccess - an event that should be published on success result\r\n   *    @param {PSEvent} options.params.callBackEvtFailed - an event that should be published on failed result\r\n   * Returned values:\r\n   *    - throw an Error if there is used a wrong metod or not enough required parameters\r\n   *    - null, method is registered in configuration file but not implemented here\r\n   *    - { result: Boolean, errors: [AdapterError] }\r\n*/\r\n  static async lexicons (options) {\r\n    ClientAdapters.checkMethodParam('lexicon', 'alpheios', options)\r\n\r\n    const adapterParams = {\r\n      category: 'lexicon',\r\n      adapterName: 'alpheios',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      timeout: options.params && options.params.timeout ? options.params.timeout : 3000,\r\n      callBackEvtSuccess: options.params ? options.params.callBackEvtSuccess : null,\r\n      callBackEvtFailed: options.params ? options.params.callBackEvtFailed : null\r\n    }\r\n\r\n    const localLexiconsAdapter = new AlpheiosLexiconsAdapter(adapterParams)\r\n\r\n    if (options.method === 'fetchShortDefs') {\r\n      await localLexiconsAdapter.fetchShortDefs(options.params.homonym, options.params.opts)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n    if (options.method === 'fetchFullDefs') {\r\n      await localLexiconsAdapter.fetchFullDefs(options.params.homonym, options.params.opts)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'checkCachedData') {\r\n      await localLexiconsAdapter.checkCachedData(options.params.url, options.params.externalData, options.params.skipFetch)\r\n      return { errors: localLexiconsAdapter.errors }\r\n    }\r\n\r\n    if (options.method === 'getConfig') {\r\n      return localLexiconsAdapter.config\r\n    }\r\n    return null\r\n  }\r\n\r\n  static async autoCompleteWords (options) {\r\n    ClientAdapters.checkMethodParam('autocompleteWords', 'logeion', options)\r\n\r\n    const localLogeionAdapter = new AlpheiosLogeionAdapter({\r\n      category: 'autocompleteWords',\r\n      adapterName: 'logeion',\r\n      method: options.method,\r\n      clientId: options.clientId,\r\n      limit: options.params.limit,\r\n      lang: options.params.lang,\r\n      sourceData: options.params.sourceData,\r\n      fetchOptions: options.params.fetchOptions\r\n    })\r\n\r\n    if (localLogeionAdapter.available && options.method === 'getWords') {\r\n      const res = await localLogeionAdapter.getWords(options.params.text)\r\n      return { result: res, errors: localLogeionAdapter.errors }\r\n    }\r\n    return null\r\n  }\r\n}\r\n\r\nexport default ClientAdapters\r\n","class AdapterError extends Error {\r\n  constructor (category, adapterName, methodName, messageError) {\r\n    super(messageError)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.methodName = methodName\r\n\r\n    if (this.adapter && this.methodName) {\r\n      this.message = `${this.message} (${this.adapter}.${this.methodName})`\r\n    }\r\n    try {\r\n      Error.captureStackTrace(this, AdapterError)\r\n    } catch (e) {\r\n      // Continue if environment does not support captureStackTrace.\r\n    }\r\n  }\r\n\r\n  update (config) {\r\n    this.adapter = `${config.category}.${config.adapterName}`\r\n    this.methodName = config.method\r\n\r\n    this.message = `${this.message} (${this.adapter}.${this.methodName})`\r\n    return this\r\n  }\r\n}\r\n\r\nexport default AdapterError\r\n","class NoRequiredParamError extends Error {\r\n  constructor (category, adapterName, methodName, paramName) {\r\n    const message = `There is no required parameter - ${paramName} for ${category}.${adapterName} - ${methodName}`\r\n    super(message)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.methodName = methodName\r\n    this.paramName = paramName\r\n    Error.captureStackTrace(this, NoRequiredParamError)\r\n  }\r\n}\r\n\r\nexport default NoRequiredParamError\r\n","export default class RemoteError extends Error {\r\n  constructor (category, adapterName, methodName, errorCode, errorMessage) {\r\n    super(errorMessage)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.methodName = methodName\r\n    this.errorCode = errorCode\r\n  }\r\n\r\n  update (config) {\r\n    this.adapter = `${config.category}.${config.adapterName}`\r\n    this.methodName = config.method\r\n\r\n    this.message = `${this.errorCode}: ${this.message} (${this.adapter}.${this.methodName})`\r\n    return this\r\n  }\r\n}\r\n","class WrongMethodError extends Error {\r\n  constructor (category, adapterName, methodName) {\r\n    const message = `Wrong method for ${category}.${adapterName} - ${methodName}`\r\n    super(message)\r\n    this.adapter = `${category}.${adapterName}`\r\n    this.method = methodName\r\n    Error.captureStackTrace(this, WrongMethodError)\r\n  }\r\n}\r\n\r\nexport default WrongMethodError\r\n","import ClientAdapters from '@clAdapters/client-adapters.js'\r\nimport RemoteError from '@clAdapters/errors/remote-error.js'\r\n\r\nexport { ClientAdapters, RemoteError }\r\n","import EnUs from './en-us/messages.json'\r\nimport EnGb from './en-gb/messages.json'\r\n\r\nexport default {\r\n  en_US: 'en-US',\r\n  en_GB: 'en-GB',\r\n  messages: {\r\n    en_US: EnUs,\r\n    en_GB: EnGb\r\n  }\r\n}\r\n","import { ResourceProvider, Lexeme, Constants, Feature, Inflection, Homonym } from 'alpheios-data-models'\r\n\r\n/**\r\n Transforms morphological output adhering to the Alpheios lexicon\r\n schema to an Alpheios Homonym data model object\r\n*/\r\n\r\nconst featuresArray = [\r\n  ['pofs', 'part'],\r\n  ['case', 'grmCase'],\r\n  ['gend', 'gender'],\r\n  ['decl', 'declension'],\r\n  ['conj', 'conjugation'],\r\n  ['area', 'area'],\r\n  ['age', 'age'],\r\n  ['geo', 'geo'],\r\n  ['freq', 'frequency'],\r\n  ['note', 'note'],\r\n  ['pron', 'pronunciation'],\r\n  ['kind', 'kind'],\r\n  ['src', 'source']\r\n]\r\n\r\nconst featuresArrayAll = [\r\n  ['pofs', 'part'],\r\n  ['case', 'grmCase'],\r\n  ['gend', 'gender'],\r\n  ['decl', 'declension'],\r\n  ['conj', 'conjugation'],\r\n  ['num', 'number'],\r\n  ['tense', 'tense'],\r\n  ['voice', 'voice'],\r\n  ['mood', 'mood'],\r\n  ['pers', 'person'],\r\n  ['comp', 'comparison'],\r\n  ['stemtype', 'stemtype'],\r\n  ['derivtype', 'derivtype'],\r\n  ['dial', 'dialect'],\r\n  ['morph', 'morph']\r\n]\r\n\r\nconst attributeBasedFeatures = [\r\n  ['paradigm', 'cat']\r\n]\r\n\r\nclass AlpheiosLexiconTransformer {\r\n  constructor (adapter, mappingData) {\r\n    this.adapter = adapter\r\n    this.mappingData = mappingData\r\n    this.allowUnknownValues = true\r\n  }\r\n\r\n  /**\r\n   * This method extract parameter by defined path\r\n   * @param {Object} source - json object to retrieve data from\r\n   * @param {String} nameParam - parameter name that should be retrieved\r\n   * @return {String|Object} - extracted data\r\n  */\r\n  extractData (source, nameParam) {\r\n    const schema = {\r\n      providerUri: ['RDF', 'Annotation', 'creator', 'Agent', 'about'],\r\n      providerRights: ['RDF', 'Annotation', 'rights', '$'],\r\n      inflections: ['rest', 'entry', 'infl'],\r\n      dictData: ['rest', 'entry', 'dict']\r\n    }\r\n    let res\r\n\r\n    if (schema[nameParam]) {\r\n      res = source\r\n      for (const pathPart of schema[nameParam]) {\r\n        if (res[pathPart]) {\r\n          res = res[pathPart]\r\n        } else {\r\n          res = undefined\r\n          break\r\n        }\r\n      }\r\n    }\r\n    return res\r\n  }\r\n\r\n  /**\r\n   * This method checks if data is array, if not - converts to array\r\n   * @param {?} data - value that should be checked\r\n   * @param {?} defaultData - default value, if data is null\r\n   * @return {Array}\r\n  */\r\n  checkToBeArray (data, defaultData = []) {\r\n    let resData = data\r\n    if (!Array.isArray(data)) {\r\n      if (data) {\r\n        resData = [data]\r\n      } else {\r\n        resData = defaultData\r\n      }\r\n    }\r\n    return resData\r\n  }\r\n\r\n  /**\r\n   * This method creates hdwd from source json object\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * @param {Symbol} direction - define the word direction\r\n   * @return {Array} - array with parts for hdwr\r\n  */\r\n  collectHdwdArray (data, term, direction) {\r\n    let hdwd = [] // eslint-disable-line prefer-const\r\n\r\n    if (data && !Array.isArray(data) && (!data.hdwd || !data.hdwd.$) && term) {\r\n      hdwd.push(term.prefix ? term.prefix.$ : '')\r\n      hdwd.push(term.stem ? term.stem.$ : '')\r\n      hdwd.push(term.suff ? term.suff.$ : '')\r\n\r\n      if (direction === Constants.LANG_DIR_RTL) {\r\n        hdwd.reverse()\r\n      }\r\n    }\r\n\r\n    return hdwd\r\n  }\r\n\r\n  /**\r\n   * This method defines language from dictData nd inflections data\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * @return {String}  - language code\r\n  */\r\n  defineLanguage (data, term) {\r\n    let lemmaData = Array.isArray(data) ? data[0] : data // eslint-disable-line prefer-const\r\n    if (!lemmaData.hdwd && term) {\r\n      lemmaData.hdwd = {}\r\n      lemmaData.hdwd.lang = term.lang\r\n    }\r\n    return lemmaData.hdwd ? lemmaData.hdwd.lang : lemmaData.lang\r\n  }\r\n\r\n  /**\r\n   * This method defines language from dictData nd inflections data\r\n   * @param {Object} data - jsonObj from adapter\r\n   * @param {Object} term - data from inflections\r\n   * Returned values:\r\n   *     - {Homonym}\r\n   *     - {undefined}\r\n  */\r\n  transformData (jsonObj, targetWord) {\r\n    let lexemes = [] // eslint-disable-line prefer-const\r\n    const annotationBody = this.checkToBeArray(jsonObj.RDF.Annotation.Body)\r\n\r\n    const providerUri = this.extractData(jsonObj, 'providerUri')\r\n    const providerRights = this.extractData(jsonObj, 'providerRights')\r\n\r\n    const provider = new ResourceProvider(providerUri, providerRights)\r\n\r\n    for (const lexeme of annotationBody) {\r\n      const inflectionsJSON = this.checkToBeArray(this.extractData(lexeme, 'inflections'))\r\n      const inflectionsJSONTerm = inflectionsJSON.length > 0 ? inflectionsJSON[0].term : undefined\r\n\r\n      const dictData = this.extractData(lexeme, 'dictData')\r\n\r\n      const lemmaElements = this.checkToBeArray(dictData, inflectionsJSONTerm ? [inflectionsJSONTerm] : [])\r\n      const language = this.defineLanguage(lemmaElements, inflectionsJSONTerm)\r\n      if (!language) {\r\n        this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_NO_LANGUAGE'))\r\n        continue\r\n      }\r\n\r\n      const reconstructHdwd = this.collectHdwdArray(dictData, inflectionsJSONTerm, this.mappingData.model.direction)\r\n      if (reconstructHdwd.length > 0) {\r\n        lemmaElements[0].hdwd.$ = reconstructHdwd.join('')\r\n      }\r\n\r\n      let lemmas = [] // eslint-disable-line prefer-const\r\n      let lexemeSet = [] // eslint-disable-line prefer-const\r\n\r\n      for (const entry of lemmaElements.entries()) {\r\n        const index = entry[0]\r\n        const elem = entry[1]\r\n\r\n        // if the parser has a number in the hdwd the JSON will have it as a number\r\n        // and not a String\r\n        const lemmaText = elem.hdwd && elem.hdwd.$ ? `${elem.hdwd.$}` : ''\r\n        if (!lemmaText) {\r\n          this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_NO_LEMMA'))\r\n          continue\r\n        }\r\n        const lemma = this.mappingData.parseLemma(lemmaText, language)\r\n        lemmas.push(lemma)\r\n\r\n        const features = featuresArray\r\n        for (const feature of features) {\r\n          this.mappingData.mapFeature(lemma, elem, ...feature, this.allowUnknownValues)\r\n        }\r\n\r\n        let shortdefs = [] // eslint-disable-line prefer-const\r\n        let meanings = lexeme.rest.entry.mean\r\n        if (!Array.isArray(meanings)) {\r\n          meanings = [meanings]\r\n        }\r\n        meanings = meanings.filter((m) => m)\r\n\r\n        // if we have multiple dictionary elements, take the meaning with the matching index\r\n        if (lemmaElements.length > 1) {\r\n          if (meanings && meanings[index] && meanings[index].$) {\r\n            const meaning = meanings[index]\r\n            shortdefs.push(ResourceProvider.getProxy(provider,\r\n              this.mappingData.parseMeaning(meaning, lemmas[index].word)))\r\n          }\r\n        } else {\r\n          // Changed to prevent some weird \"Array Iterator.prototype.next called on incompatible receiver [object Unknown]\" error\r\n          const sDefs = meanings.filter((m) => m.$).map(meaning => {\r\n            return ResourceProvider.getProxy(provider,\r\n              this.mappingData.parseMeaning(meaning, lemma.word))\r\n          })\r\n          shortdefs.push(...sDefs)\r\n        }\r\n        let lexmodel = new Lexeme(lemma, []) // eslint-disable-line prefer-const\r\n\r\n        lexmodel.meaning.appendShortDefs(shortdefs)\r\n        lexemeSet.push(ResourceProvider.getProxy(provider, lexmodel))\r\n      }\r\n\r\n      if (lemmas.length === 0) {\r\n        continue\r\n      }\r\n\r\n      const inflections = []\r\n      for (const inflectionJSON of inflectionsJSON) {\r\n        const stem = inflectionJSON.term && inflectionJSON.term.stem ? inflectionJSON.term.stem.$ : null\r\n        const form = inflectionJSON.term && inflectionJSON.term.form ? inflectionJSON.term.form.$ : null\r\n        const suffix = inflectionJSON.term && inflectionJSON.term.suff ? inflectionJSON.term.suff.$ : null\r\n        const prefix = inflectionJSON.term && inflectionJSON.term.pref ? inflectionJSON.term.pref.$ : null\r\n        const xmpl = inflectionJSON.xmpl ? inflectionJSON.xmpl.$ : null\r\n        const inflWord = stem || form\r\n        let inflection\r\n        try {\r\n          inflection = new Inflection(inflWord, this.mappingData.model.languageID, suffix, prefix, xmpl)\r\n        } catch (e) {\r\n          this.adapter.addError(this.adapter.l10n.getMsg('MORPH_TRANSFORM_INFLECTION_ERROR', { error: e.message }))\r\n          continue\r\n        }\r\n        if (targetWord) {\r\n          inflection.addFeature(new Feature(Feature.types.fullForm, targetWord, this.mappingData.model.languageID))\r\n        }\r\n        // Parse whatever grammatical features we're interested in and are provided\r\n        for (const f of featuresArrayAll) {\r\n          try {\r\n            this.mappingData.mapFeature(inflection, inflectionJSON, ...f, this.allowUnknownValues)\r\n            this.mappingData.overrideInflectionFeatureIfRequired(Feature.types[f[1]], inflection, lemmas)\r\n          } catch (e) {\r\n            // quietly continue\r\n          }\r\n        }\r\n\r\n        // Parse attribute based features\r\n        for (const f of attributeBasedFeatures) {\r\n          try {\r\n            this.mappingData.mapFeatureByAttribute(inflection, inflectionJSON, ...f, this.allowUnknownValues)\r\n            this.mappingData.overrideInflectionFeatureIfRequired(Feature.types[f[1]], inflection, lemmas)\r\n          } catch (e) {\r\n            // quietly continue\r\n          }\r\n        }\r\n\r\n        // we only use the inflection if it tells us something the dictionary details do not\r\n        if (inflection[Feature.types.grmCase] ||\r\n          inflection[Feature.types.tense] ||\r\n          inflection[Feature.types.mood] ||\r\n          inflection[Feature.types.voice] ||\r\n          inflection[Feature.types.person] ||\r\n          inflection[Feature.types.comparison] ||\r\n          inflection[Feature.types.stemtype] || /** greek - morpheus **/\r\n          inflection[Feature.types.derivtype] || /** greek - morpheus **/\r\n          inflection[Feature.types.dialect] || /** greek **/\r\n          inflection[Feature.types.morph] || /** arabic - aramorph **/\r\n          inflection[Feature.types.kaylo] || /** syriac - sedra **/\r\n          inflection[Feature.types.state] || /** syriac - sedra **/\r\n          inflection[Feature.types.example]) {\r\n          inflections.push(inflection)\r\n        }\r\n        // inflection can provide lemma decl, pofs, conj\r\n        for (const lemma of lemmas) {\r\n          if (!lemma.features[Feature.types.part]) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'pofs', 'part', this.allowUnknownValues)\r\n          }\r\n          // only take declension from inflection if lemma has no part of speech or its the same as the inflection\r\n          if (!lemma.features[Feature.types.declension] &&\r\n            (!lemma.features[Feature.types.part] || lemma.features[Feature.types.part].isEqual(inflection[Feature.types.part]))) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'decl', 'declension', this.allowUnknownValues)\r\n          }\r\n          // only take conjugation from inflection if lemma has a part of speech and its the same as the inflection\r\n          if (!lemma.features[Feature.types.conjugation] &&\r\n            (!lemma.features[Feature.types.part] || lemma.features[Feature.types.part].isEqual(inflection[Feature.types.part]))) {\r\n            this.mappingData.mapFeature(lemma, inflectionJSON, 'conj', 'conjugation', this.allowUnknownValues)\r\n          }\r\n        }\r\n      }\r\n      const aggregated = this.mappingData.aggregateLexemes(lexemeSet, inflections)\r\n      lexemes.push(...aggregated)\r\n    }\r\n    if (lexemes.length > 0) {\r\n      return new Homonym(lexemes, targetWord)\r\n    } else {\r\n      return undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport default AlpheiosLexiconTransformer\r\n","/*\r\nObjects of a morphology analyzer's library\r\n */\r\nimport { Feature, Lemma, FeatureImporter, Definition, Constants, Logger } from 'alpheios-data-models'\r\n\r\n/**\r\n * Holds all information required to transform from morphological analyzer's grammatical feature values to the\r\n * library standards. There is one ImportMorphData object per language.\r\n */\r\nclass ImportMorphData {\r\n  /**\r\n     * Creates an ImportMorphData object for the language provided.\r\n     * @param {Function<LanguageModel>} model - A language model of the import data.\r\n     * @param {String} engine - a code for the engine that is using this mapping model\r\n     */\r\n  constructor (model, engine) {\r\n    'use strict'\r\n    this.model = model\r\n    this.engine = engine\r\n    // add all the features that the language supports so that we\r\n    // can return the default values if we don't need to import a mapping\r\n    for (const featureName of Object.keys(this.model.features)) {\r\n      this.addFeature(featureName)\r\n    }\r\n    // may be overridden by specific engine to handle vagaries in reporting of dictionary entries\r\n    // default just returns them as provided\r\n    this.aggregateLexemes = function (lexemeSet, inflections) {\r\n      let lexemes = [] // eslint-disable-line prefer-const\r\n      for (const lex of lexemeSet) {\r\n        // only process if we have a lemma that differs from the target\r\n        // word or if we have at least a part of speech\r\n        if (this.reportLexeme(lex)) {\r\n          lex.inflections = inflections.map(inflection => inflection.clone())\r\n          lexemes.push(lex)\r\n        }\r\n      }\r\n      return lexemes\r\n    }\r\n    // may be overridden by specific engine use via setLemmaParser\r\n    this.parseLemma = function (lemma) { return new Lemma(lemma, this.model.languageID) }\r\n\r\n    // may be overridden by specific engine use via setMeaningParser\r\n    this.parseMeaning = function (meaning, targetWord) {\r\n      const lang = meaning.lang ? meaning.lang : Constants.STR_LANG_CODE_ENG\r\n      return new Definition(meaning.$, lang, 'text/plain', targetWord)\r\n    }\r\n\r\n    // may be overridden by specific engine use via setPropertyParser - default just returns the property value\r\n    // as a list\r\n    this.parseProperty = function (propertyName, propertyValue, inputElem) {\r\n      let propertyValues = []\r\n      if (propertyName === 'decl') {\r\n        propertyValues = propertyValue.split('&').map((p) => p.trim())\r\n      } else if (propertyName === 'comp' && propertyValue === 'positive') {\r\n        propertyValues = []\r\n      } else {\r\n        propertyValues = [propertyValue]\r\n      }\r\n      return propertyValues\r\n    }\r\n\r\n    // may be overridden by specifc engine use via setLexemeFilter - default assumes we will have a part of speech\r\n    this.reportLexeme = function (lexeme) {\r\n      return lexeme.lemma.features[Feature.types.part]\r\n    }\r\n\r\n    // may be overriden by specific engine use to a list of of featureTypes which\r\n    // should be overridden in the inflection data from the lemma data\r\n    this.inflectionOverrides = []\r\n  }\r\n\r\n  /**\r\n     * Adds a grammatical feature whose values to be mapped.\r\n     * @param {string} featureName - A name of a grammatical feature (i.e. declension, number, etc.)\r\n     * @return {Object} An object that represent a newly created grammatical feature.\r\n     */\r\n  addFeature (featureName) {\r\n    this[featureName] = {}\r\n    const model = this.model\r\n\r\n    this[featureName].add = function add (providerValue, alpheiosValue) {\r\n      this[providerValue] = alpheiosValue\r\n      return this\r\n    }\r\n\r\n    this[featureName].get = function get (providerValue, sortOrder = 1, allowUnknownValues = false) {\r\n      let mappedValue = []\r\n      if (!this.importer.has(providerValue)) {\r\n        // if the providerValue matches the model value or the model value\r\n        // is unrestricted, return a feature with the providerValue and order\r\n        if (model.typeFeature(featureName).hasValue(providerValue) ||\r\n            model.typeFeature(featureName).valuesUnrestricted) {\r\n          mappedValue = model.typeFeature(featureName).createFeature(providerValue, sortOrder)\r\n        } else {\r\n          const message = `Unknown value \"${providerValue}\" of feature \"${featureName}\" for ${model.languageCode} (allowed = ${allowUnknownValues})`\r\n          if (allowUnknownValues) {\r\n            mappedValue = model.typeFeature(featureName).createFeature(providerValue, sortOrder)\r\n          } else {\r\n            throw new Error(message)\r\n          }\r\n        }\r\n      } else {\r\n        const tempValue = this.importer.get(providerValue)\r\n        if (Array.isArray(tempValue)) {\r\n          mappedValue = model.typeFeature(featureName).createFeatures(tempValue, sortOrder)\r\n        } else {\r\n          mappedValue = model.typeFeature(featureName).createFeature(tempValue, sortOrder)\r\n        }\r\n      }\r\n      return mappedValue\r\n    }\r\n\r\n    /**\r\n     * @param {Object[]} data - An array of objects with `providerData` (an item value) and `sortOrder` fields\r\n     * @param allowUnknownValues\r\n     * @return {Feature}\r\n     */\r\n    this[featureName].getMultiple = function get (data, allowUnknownValues = false) {\r\n      let values = [] // Converts values from `data` into `values` array\r\n      for (const item of data) {\r\n        if (this.importer.has(item.providerValue)) {\r\n          const value = this.importer.get(item.providerValue)\r\n          if (Array.isArray(value)) {\r\n            // if the import returns an array, it should already have the sortOrder\r\n            values = value\r\n          } else {\r\n            values = [[value, item.sortOrder]]\r\n          }\r\n        } else if (model.typeFeature(featureName).hasValue(item.providerValue) ||\r\n          model.typeFeature(featureName).valuesUnrestricted) {\r\n          values.push([item.providerValue, item.sortOrder])\r\n        } else {\r\n          const message = `Unknown value \"${item.providerValue}\" of feature \"${featureName}\" for ${model.languageCode} (allowed = ${allowUnknownValues})`\r\n          if (allowUnknownValues) {\r\n            values.push([item.providerValue, item.sortOrder])\r\n          } else {\r\n            throw new Error(message)\r\n          }\r\n        }\r\n      }\r\n      return model.typeFeature(featureName).createFeatures(values)\r\n    }\r\n\r\n    this[featureName].importer = new FeatureImporter()\r\n\r\n    return this[featureName]\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific lexeme aggregator\r\n   */\r\n  setLexemeAggregator (callback) {\r\n    this.aggregateLexemes = callback\r\n  }\r\n\r\n  /**\r\n  /**\r\n   * Add an engine-specific lemma parser\r\n   */\r\n  setLemmaParser (callback) {\r\n    this.parseLemma = callback\r\n  }\r\n\r\n  setMeaningParser (callback) {\r\n    this.parseMeaning = callback\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific property parser\r\n   */\r\n  setPropertyParser (callback) {\r\n    this.parseProperty = callback\r\n  }\r\n\r\n  /**\r\n   * Add an engine-specific lexeme filter\r\n   */\r\n  setLexemeFilter (callback) {\r\n    this.reportLexeme = callback\r\n  }\r\n\r\n  /**\r\n   * Maps property of a single feature type to a single Feature object with one or more values\r\n   * (if this feature has multiple values). Feature is stored as a property of the supplied model object.\r\n   * @param {object} model the model object to which the feature will be added\r\n   * @param {object} inputElem the input data element\r\n   * @param {object} inputName the  property name in the input data\r\n   * @param {string} featureName the name of the feature it will be mapped to\r\n   * @param {boolean} allowUnknownValues flag to indicate if unknown values are allowed\r\n   */\r\n  mapFeature (model, inputElem, inputName, featureName, allowUnknownValues) {\r\n    const inputItem = inputElem[inputName]\r\n    if (inputItem && (Array.isArray(inputItem) || inputItem.$)) {\r\n      let values = []\r\n      if (Array.isArray(inputItem)) {\r\n        // There are multiple values of this feature\r\n        for (const e of inputItem) {\r\n          values.push(...this.parseProperty(inputName, e.$, inputElem))\r\n        }\r\n      } else {\r\n        values = this.parseProperty(inputName, inputItem.$, inputElem)\r\n      }\r\n      // `values` is always an array as an array is a return value of `parseProperty`\r\n      if (values.length > 0) {\r\n        // There are some values found\r\n        values = values.map(v => { return { providerValue: v, sortOrder: inputItem.order ? inputItem.order : 1 } })\r\n        const feature = this[Feature.types[featureName]].getMultiple(values, allowUnknownValues)\r\n        model.addFeature(feature)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Maps property of a single feature type to a single Feature object with one\r\n   * or more values, using an attribute to determine the mapped-to feature name\r\n   * (if this feature has multiple values). Feature is stored as a property of\r\n   * the supplied model object.\r\n   * @param {object} model the model object to which the feature will be added\r\n   * @param {object} inputElem the input data element\r\n   * @param {object} inputName the  property name in the input data\r\n   * @param {string} attributeName the attribute to use to get the feature name\r\n   * @param {boolean} allowUnknownValues flag to indicate if unknown values are allowed\r\n   */\r\n  mapFeatureByAttribute (model, inputElem, inputName, attributeName, allowUnknownValues) {\r\n    const inputItem = inputElem[inputName]\r\n    let featureName\r\n    if (inputItem && (Array.isArray(inputItem) || inputItem.$)) {\r\n      let values = []\r\n      if (Array.isArray(inputItem)) {\r\n        // There are multiple values of this feature\r\n        for (const e of inputItem) {\r\n          if (featureName && featureName !== e[attributeName]) {\r\n            Logger.getInstance().warn('Mutiple feature values with mismatching attribute value', inputElem)\r\n          }\r\n          featureName = e[attributeName]\r\n          values.push(...this.parseProperty(inputName, e.$, inputElem))\r\n        }\r\n      } else {\r\n        featureName = inputItem[attributeName]\r\n        values = this.parseProperty(inputName, inputItem.$, inputElem)\r\n      }\r\n      // `values` is always an array as an array is a return value of `parseProperty`\r\n      if (values.length > 0) {\r\n        // There are some values found\r\n        values = values.map(v => { return { providerValue: v, sortOrder: inputItem.order ? inputItem.order : 1 } })\r\n        const feature = this[Feature.types[featureName]].getMultiple(values, allowUnknownValues, inputItem.cat)\r\n        model.addFeature(feature)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overrides feature data from an inflection with feature data from the lemma\r\n   * if required by an engine-specific list of featureTypes\r\n   * @param {String} featureType the feature type name\r\n   * @param {Inflection} inflection the inflection object\r\n   * @param {Lemma[]} lemmas the lemma objects\r\n   */\r\n  overrideInflectionFeatureIfRequired (featureType, inflection, lemmas) {\r\n    if (this.inflectionOverrides[featureType] &&\r\n        this.inflectionOverrides[featureType](inflection, lemmas)) {\r\n      for (const lemma of lemmas.filter(l => l.features[featureType])) {\r\n        inflection.addFeature(lemma.features[featureType])\r\n      }\r\n    }\r\n  }\r\n}\r\nexport default ImportMorphData\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE_alpheios_data_models__;","module.exports = __WEBPACK_EXTERNAL_MODULE_alpheios_messaging__;","module.exports = require(\"assert\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"stream\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./index.js\");\n"],"sourceRoot":""}