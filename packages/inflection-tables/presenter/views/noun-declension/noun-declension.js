import * as Lib from "../../../lib/lib.js";
import * as LibLatin from "../../../lib/lang/latin.js";
import * as Templates from "../views.js";

export {render};

/**
 * A name of a template as auto generated by Handlebars compiler
 */
let templateName = 'noun-declension/noun-declension';

/**
 * These values are used to define sorting and grouping order. 'featureOrder' determine a sequence in which
 * feature will be used for sorting. The same sequence will be used to group items when building a view matrix.
 * All feature types has a default sort order. This order is defined by a sequence of feature values provided
 * as arguments to each feature type constructor. However, this can be overriden here, as shown by the 'gender'
 * example. If endings with several values must be combines, such values can be provided within an array,
 * as shown by 'masculine' and 'feminine' values.
 */
let genderFeature = LibLatin.genders;
genderFeature.order = [[LibLatin.genders.masculine, LibLatin.genders.feminine], LibLatin.genders.neuter];
let featureOrder = [LibLatin.numbers, LibLatin.cases, LibLatin.declensions, genderFeature, LibLatin.types];

/**
 * By what feature (multiple features not supported yet) should endings be combined within a table cell. If this is
 * set to 'gender', and there are ending that has an 'gender' feature group, and their 'gender' values are not the
 * same and within group values, those ending records will be combined into one
 */
let deduplicateBy = LibLatin.genders;


/**
 * A compare function that can be used to sort ending according to specific requirements of the current view
 * @param featureOrder
 * @param a
 * @param b
 */
let compare = function(featureOrder, a, b) {
    "use strict";

    // Set custom sort order if necessary
    // Custom sort order for each declension
    //LibLatin.genders.order = [LibLatin.genders.feminine];


    for (let [index, feature] of featureOrder.entries()) {
        let featureTypeA = a.features[feature.type],
            featureTypeB = b.features[feature.type];

        if (feature.orderLookup[featureTypeA] > feature.orderLookup[featureTypeB]) {
            return 1;
        }
        else if (feature.orderLookup[featureTypeA] < feature.orderLookup[featureTypeB]) {
            return -1;
        }
        /*
         If values on this level are equal, continue comparing to the next level. If we are at the last level of
         comparison and elements are equal, return 0.
         */
        else if (index == featureOrder.length-1) {
            // This is the last sort order item
            return 0;
        }
    }

};

/**
 *
 * @param featureType
 * @param featureValues
 * @param ending
 * @returns {boolean}
 */
let filter = function filter(featureType, featureValues, ending) {
    "use strict";

    // If not an array, convert it to array for uniformity
    if (!Array.isArray(featureValues)) {
        featureValues = [featureValues];
    }
    for (const value of featureValues) {
        if (ending.features[featureType] === value) {
            return true;
        }
    }

    return false;
};

// TODO: Works with one feature and two values so far. Need to simplify
let deduplicate = function deduplicate(endings) {

    if (endings.length <=0) {
        return endings;
    }

    // Specify how to combine
    let result = Lib.Ending.combineGroups(endings);


    return result;
};

let splitByFeature = function splitByFeature(values, splitFeatures, currentLevel) {
    let feature = splitFeatures[currentLevel];
    let splitted = [];
    for (const featureValue of feature.orderIndex) {
        let result = {
            type: feature.type,
            value: featureValue
        };
        let splitResult = values.filter(filter.bind(this, feature.type, featureValue));
        if (currentLevel < splitFeatures.length - 1) {
            // Split more
            splitResult = splitByFeature(splitResult, splitFeatures, currentLevel + 1);
        }
        else {
            // This is the last level
            // Split result has a list of endings in a table cell. We can now deduplicate them if we want
            splitResult = deduplicate(splitResult);
        }
        result.data = splitResult;
        splitted.push(result);
    }
    return splitted;
};

let render = function data(resultSet) {
    "use strict";

    //let sorted = resultSet.endings.sort(compare.bind(this, featureOrder));

    // Create data structure for a template
    let displayData = {};

    displayData.endings = splitByFeature(resultSet.endings, featureOrder, 0);
    displayData.footnotes = resultSet.footnotes;

    return Handlebars.templates[templateName](displayData);

};